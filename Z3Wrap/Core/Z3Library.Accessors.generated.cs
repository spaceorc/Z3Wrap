// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Accessors.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Return <c>Z3_INT_SYMBOL</c> if the symbol was constructed using <see cref="MkIntSymbol"/> , and <c>Z3_STRING_SYMBOL</c> if the symbol was constructed using <see cref="MkStringSymbol"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_symbol">symbol parameter</param>
    /// <returns ctype="Z3_symbol_kind">symbol_kind value</returns>
    public SymbolKind GetSymbolKind(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetSymbolKind(c, s);
        CheckError(c);
        return (SymbolKind)result;
    }

    /// <summary>
    ///  Return the symbol int value.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_symbol">symbol parameter</param>
    /// <returns ctype="int">int value</returns>
    /// <remarks>
    /// Precondition: Z3_get_symbol_kind(s) == Z3_INT_SYMBOL
    /// </remarks>
    /// <seealso cref="MkIntSymbol"/>
    public int GetSymbolInt(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetSymbolInt(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the symbol name.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_symbol">symbol parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Precondition: Z3_get_symbol_kind(s) == Z3_STRING_SYMBOL
    /// Warning: The returned buffer is statically allocated by Z3. It will be automatically deallocated when <see cref="DelContext"/> is invoked. So, the buffer is invalidated in the next call to <c>Z3_get_symbol_string</c> .
    /// </remarks>
    /// <seealso cref="MkStringSymbol"/>
    public string GetSymbolString(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetSymbolString(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(GetSymbolString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return the sort name as a symbol.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_symbol">symbol value</returns>
    public IntPtr GetSortName(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.GetSortName(c, d);
        CheckError(c);
        return CheckHandle(result, nameof(GetSortName));
    }

    /// <summary>
    ///  Return a unique identifier for <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    public uint GetSortId(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetSortId(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Convert a <c>Z3_sort</c> into <c>Z3_ast</c> . This is just type casting.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr SortToAst(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SortToAst(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(SortToAst));
    }

    /// <summary>
    ///  compare sorts.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s1" ctype="Z3_sort">sort parameter</param>
    /// <param name="s2" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsEqSort(IntPtr c, IntPtr s1, IntPtr s2)
    {
        var result = nativeLibrary.IsEqSort(c, s1, s2);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the sort kind (e.g., array, tuple, int, bool, etc).
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_sort_kind">sort_kind value</returns>
    /// <seealso cref="SortKind"/>
    public SortKind GetSortKind(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetSortKind(c, t);
        CheckError(c);
        return (SortKind)result;
    }

    /// <summary>
    ///  Return the size of the given bit-vector sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(c, t) == Z3_BV_SORT
    /// </remarks>
    /// <seealso cref="MkBvSort"/>
    /// <seealso cref="GetSortKind"/>
    public uint GetBvSortSize(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetBvSortSize(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Store the size of the sort in <c>r</c> . Return <c>false</c> if the call failed. That is, Z3_get_sort_kind(s) == Z3_FINITE_DOMAIN_SORT.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <param name="r" ctype="uint64_t*">uint64_t parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool GetFiniteDomainSortSize(IntPtr c, IntPtr s, out ulong r)
    {
        var result = nativeLibrary.GetFiniteDomainSortSize(c, s, out r);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the arity (number of dimensions) of the given array sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(s) == Z3_ARRAY_SORT
    /// </remarks>
    /// <seealso cref="GetArraySortDomainN"/>
    public uint GetArrayArity(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetArrayArity(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the domain of the given array sort. In the case of a multi-dimensional array, this function returns the sort of the first dimension.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="GetSortKind"/>
    /// <seealso cref="GetArraySortDomainN"/>
    public IntPtr GetArraySortDomain(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetArraySortDomain(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(GetArraySortDomain));
    }

    /// <summary>
    ///  Return the i'th domain sort of an n-dimensional array.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="GetSortKind"/>
    /// <seealso cref="GetArraySortDomain"/>
    public IntPtr GetArraySortDomainN(IntPtr c, IntPtr t, uint idx)
    {
        var result = nativeLibrary.GetArraySortDomainN(c, t, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetArraySortDomainN));
    }

    /// <summary>
    ///  Return the range of the given array sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="GetSortKind"/>
    public IntPtr GetArraySortRange(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetArraySortRange(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(GetArraySortRange));
    }

    /// <summary>
    ///  Return the constructor declaration of the given tuple sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT
    /// </remarks>
    /// <seealso cref="MkTupleSort"/>
    /// <seealso cref="GetSortKind"/>
    public IntPtr GetTupleSortMkDecl(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetTupleSortMkDecl(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(GetTupleSortMkDecl));
    }

    /// <summary>
    ///  Return the number of fields of the given tuple sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT
    /// </remarks>
    /// <seealso cref="MkTupleSort"/>
    /// <seealso cref="GetSortKind"/>
    public uint GetTupleSortNumFields(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetTupleSortNumFields(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the i-th field declaration (i.e., projection function declaration) of the given tuple sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
    /// Precondition: i &lt; Z3_get_tuple_sort_num_fields(c, t)
    /// </remarks>
    /// <seealso cref="MkTupleSort"/>
    /// <seealso cref="GetSortKind"/>
    public IntPtr GetTupleSortFieldDecl(IntPtr c, IntPtr t, uint i)
    {
        var result = nativeLibrary.GetTupleSortFieldDecl(c, t, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetTupleSortFieldDecl));
    }

    /// <summary>
    ///  Check if <c>s</c> is a recursive datatype sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsRecursiveDatatypeSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsRecursiveDatatypeSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return number of constructors for datatype.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
    /// </remarks>
    /// <seealso cref="GetDatatypeSortConstructor"/>
    /// <seealso cref="GetDatatypeSortRecognizer"/>
    /// <seealso cref="GetDatatypeSortConstructorAccessor"/>
    public uint GetDatatypeSortNumConstructors(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetDatatypeSortNumConstructors(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return idx'th constructor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
    /// Precondition: idx &lt; Z3_get_datatype_sort_num_constructors(c, t)
    /// </remarks>
    /// <seealso cref="GetDatatypeSortNumConstructors"/>
    /// <seealso cref="GetDatatypeSortRecognizer"/>
    /// <seealso cref="GetDatatypeSortConstructorAccessor"/>
    public IntPtr GetDatatypeSortConstructor(IntPtr c, IntPtr t, uint idx)
    {
        var result = nativeLibrary.GetDatatypeSortConstructor(c, t, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetDatatypeSortConstructor));
    }

    /// <summary>
    ///  Return idx'th recognizer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
    /// Precondition: idx &lt; Z3_get_datatype_sort_num_constructors(c, t)
    /// </remarks>
    /// <seealso cref="GetDatatypeSortNumConstructors"/>
    /// <seealso cref="GetDatatypeSortConstructor"/>
    /// <seealso cref="GetDatatypeSortConstructorAccessor"/>
    public IntPtr GetDatatypeSortRecognizer(IntPtr c, IntPtr t, uint idx)
    {
        var result = nativeLibrary.GetDatatypeSortRecognizer(c, t, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetDatatypeSortRecognizer));
    }

    /// <summary>
    ///  Return idx_a'th accessor for the idx_c'th constructor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_sort">sort parameter</param>
    /// <param name="idxC" ctype="unsigned">unsigned parameter</param>
    /// <param name="idxA" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
    /// Precondition: idx_c &lt; Z3_get_datatype_sort_num_constructors(c, t)
    /// Precondition: idx_a &lt; Z3_get_domain_size(c, Z3_get_datatype_sort_constructor(c, idx_c))
    /// </remarks>
    /// <seealso cref="GetDatatypeSortNumConstructors"/>
    /// <seealso cref="GetDatatypeSortConstructor"/>
    /// <seealso cref="GetDatatypeSortRecognizer"/>
    public IntPtr GetDatatypeSortConstructorAccessor(IntPtr c, IntPtr t, uint idxC, uint idxA)
    {
        var result = nativeLibrary.GetDatatypeSortConstructorAccessor(c, t, idxC, idxA);
        CheckError(c);
        return CheckHandle(result, nameof(GetDatatypeSortConstructorAccessor));
    }

    /// <summary>
    ///  Update record field with a value.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="fieldAccess" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <param name="value" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(Z3_get_sort(c, t)) == Z3_get_domain(c, field_access, 1) == Z3_DATATYPE_SORT
    /// Precondition: Z3_get_sort(c, value) == Z3_get_range(c, field_access)
    /// </remarks>
    /// <seealso cref="MkStore"/>
    public IntPtr DatatypeUpdateField(IntPtr c, IntPtr fieldAccess, IntPtr t, IntPtr value)
    {
        var result = nativeLibrary.DatatypeUpdateField(c, fieldAccess, t, value);
        CheckError(c);
        return CheckHandle(result, nameof(DatatypeUpdateField));
    }

    /// <summary>
    ///  Return arity of relation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(s) == Z3_RELATION_SORT
    /// </remarks>
    /// <seealso cref="GetRelationColumn"/>
    public uint GetRelationArity(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetRelationArity(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return sort at i'th column of relation sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <param name="col" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: Z3_get_sort_kind(c, s) == Z3_RELATION_SORT
    /// Precondition: col &lt; Z3_get_relation_arity(c, s)
    /// </remarks>
    /// <seealso cref="GetRelationArity"/>
    public IntPtr GetRelationColumn(IntPtr c, IntPtr s, uint col)
    {
        var result = nativeLibrary.GetRelationColumn(c, s, col);
        CheckError(c);
        return CheckHandle(result, nameof(GetRelationColumn));
    }

    /// <summary>
    ///  Pseudo-Boolean relations.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="k" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Encode p1 + p2 + ... + pn &lt;= k
    /// </remarks>
    public IntPtr MkAtmost(IntPtr c, uint numArgs, IntPtr[] args, uint k)
    {
        var result = nativeLibrary.MkAtmost(c, numArgs, args, k);
        CheckError(c);
        return CheckHandle(result, nameof(MkAtmost));
    }

    /// <summary>
    ///  Pseudo-Boolean relations.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="k" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Encode p1 + p2 + ... + pn &gt;= k
    /// </remarks>
    public IntPtr MkAtleast(IntPtr c, uint numArgs, IntPtr[] args, uint k)
    {
        var result = nativeLibrary.MkAtleast(c, numArgs, args, k);
        CheckError(c);
        return CheckHandle(result, nameof(MkAtleast));
    }

    /// <summary>
    ///  Pseudo-Boolean relations.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="coeffs" ctype="int const[]">int parameter</param>
    /// <param name="k" ctype="int">int parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Encode k1*p1 + k2*p2 + ... + kn*pn &lt;= k
    /// </remarks>
    public IntPtr MkPble(IntPtr c, uint numArgs, IntPtr[] args, int[] coeffs, int k)
    {
        var result = nativeLibrary.MkPble(c, numArgs, args, coeffs, k);
        CheckError(c);
        return CheckHandle(result, nameof(MkPble));
    }

    /// <summary>
    ///  Pseudo-Boolean relations.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="coeffs" ctype="int const[]">int parameter</param>
    /// <param name="k" ctype="int">int parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Encode k1*p1 + k2*p2 + ... + kn*pn &gt;= k
    /// </remarks>
    public IntPtr MkPbge(IntPtr c, uint numArgs, IntPtr[] args, int[] coeffs, int k)
    {
        var result = nativeLibrary.MkPbge(c, numArgs, args, coeffs, k);
        CheckError(c);
        return CheckHandle(result, nameof(MkPbge));
    }

    /// <summary>
    ///  Pseudo-Boolean relations.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="coeffs" ctype="int const[]">int parameter</param>
    /// <param name="k" ctype="int">int parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Encode k1*p1 + k2*p2 + ... + kn*pn = k
    /// </remarks>
    public IntPtr MkPbeq(IntPtr c, uint numArgs, IntPtr[] args, int[] coeffs, int k)
    {
        var result = nativeLibrary.MkPbeq(c, numArgs, args, coeffs, k);
        CheckError(c);
        return CheckHandle(result, nameof(MkPbeq));
    }

    /// <summary>
    ///  Convert a <c>Z3_func_decl</c> into <c>Z3_ast</c> . This is just type casting.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr FuncDeclToAst(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.FuncDeclToAst(c, f);
        CheckError(c);
        return CheckHandle(result, nameof(FuncDeclToAst));
    }

    /// <summary>
    ///  Compare terms.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f1" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="f2" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsEqFuncDecl(IntPtr c, IntPtr f1, IntPtr f2)
    {
        var result = nativeLibrary.IsEqFuncDecl(c, f1, f2);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return a unique identifier for <c>f</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    public uint GetFuncDeclId(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.GetFuncDeclId(c, f);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the constant declaration name as a symbol.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_symbol">symbol value</returns>
    public IntPtr GetDeclName(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.GetDeclName(c, d);
        CheckError(c);
        return CheckHandle(result, nameof(GetDeclName));
    }

    /// <summary>
    ///  Return declaration kind corresponding to declaration.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_decl_kind">decl_kind value</returns>
    public DeclKind GetDeclKind(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.GetDeclKind(c, d);
        CheckError(c);
        return (DeclKind)result;
    }

    /// <summary>
    ///  Return the number of parameters of the given declaration.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="GetArity"/>
    public uint GetDomainSize(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.GetDomainSize(c, d);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Alias for <c>Z3_get_domain_size</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="GetDomainSize"/>
    public uint GetArity(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.GetArity(c, d);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the sort of the i-th parameter of the given function declaration.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: i &lt; Z3_get_domain_size(d)
    /// </remarks>
    /// <seealso cref="GetDomainSize"/>
    public IntPtr GetDomain(IntPtr c, IntPtr d, uint i)
    {
        var result = nativeLibrary.GetDomain(c, d, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetDomain));
    }

    /// <summary>
    ///  Return the range of the given declaration.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// If <c>d</c> is a constant (i.e., has zero arguments), then this function returns the sort of the constant.
    /// </remarks>
    public IntPtr GetRange(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.GetRange(c, d);
        CheckError(c);
        return CheckHandle(result, nameof(GetRange));
    }

    /// <summary>
    ///  Return the number of parameters associated with a declaration.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    public uint GetDeclNumParameters(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.GetDeclNumParameters(c, d);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the parameter type associated with a declaration.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> the context </param>
    /// <param name="d" ctype="Z3_func_decl"> the function declaration </param>
    /// <param name="idx" ctype="unsigned"> is the index of the named parameter it should be between 0 and the number of parameters. </param>
    /// <returns ctype="Z3_parameter_kind">parameter_kind value</returns>
    public ParameterKind GetDeclParameterKind(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclParameterKind(c, d, idx);
        CheckError(c);
        return (ParameterKind)result;
    }

    /// <summary>
    ///  Return the integer value associated with an integer parameter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="int">int value</returns>
    /// <remarks>
    /// Precondition: Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_INT
    /// </remarks>
    public int GetDeclIntParameter(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclIntParameter(c, d, idx);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the double value associated with an double parameter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="double">double value</returns>
    /// <remarks>
    /// Precondition: Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_DOUBLE
    /// </remarks>
    public double GetDeclDoubleParameter(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclDoubleParameter(c, d, idx);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the double value associated with an double parameter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_symbol">symbol value</returns>
    /// <remarks>
    /// Precondition: Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SYMBOL
    /// </remarks>
    public IntPtr GetDeclSymbolParameter(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclSymbolParameter(c, d, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetDeclSymbolParameter));
    }

    /// <summary>
    ///  Return the sort value associated with a sort parameter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SORT
    /// </remarks>
    public IntPtr GetDeclSortParameter(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclSortParameter(c, d, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetDeclSortParameter));
    }

    /// <summary>
    ///  Return the expression value associated with an expression parameter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_AST
    /// </remarks>
    public IntPtr GetDeclAstParameter(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclAstParameter(c, d, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetDeclAstParameter));
    }

    /// <summary>
    ///  Return the expression value associated with an expression parameter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_FUNC_DECL
    /// </remarks>
    public IntPtr GetDeclFuncDeclParameter(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclFuncDeclParameter(c, d, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetDeclFuncDeclParameter));
    }

    /// <summary>
    ///  Return the rational value, as a string, associated with a rational parameter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Precondition: Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_RATIONAL
    /// </remarks>
    public string GetDeclRationalParameter(IntPtr c, IntPtr d, uint idx)
    {
        var result = nativeLibrary.GetDeclRationalParameter(c, d, idx);
        CheckError(c);
        result = CheckHandle(result, nameof(GetDeclRationalParameter));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Convert a <c>Z3_app</c> into <c>Z3_ast</c> . This is just type casting.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_app">app parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr AppToAst(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.AppToAst(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(AppToAst));
    }

    /// <summary>
    ///  Return the declaration of a constant or function application.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_app">app parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    public IntPtr GetAppDecl(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetAppDecl(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetAppDecl));
    }

    /// <summary>
    ///  Return the number of argument of an application. If <c>t</c> is an constant, then the number of arguments is 0.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_app">app parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="GetAppArg"/>
    public uint GetAppNumArgs(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetAppNumArgs(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the i-th argument of the given application.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_app">app parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: i &lt; Z3_get_app_num_args(c, a)
    /// </remarks>
    /// <seealso cref="GetAppNumArgs"/>
    public IntPtr GetAppArg(IntPtr c, IntPtr a, uint i)
    {
        var result = nativeLibrary.GetAppArg(c, a, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetAppArg));
    }

    /// <summary>
    ///  Compare terms.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsEqAst(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.IsEqAst(c, t1, t2);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return a unique identifier for <c>t</c> . The identifier is unique up to structural equality. Thus, two ast nodes created by the same context and having the same children and same function symbols have the same identifiers. Ast nodes created in the same context, but having different children or different functions have different identifiers. Variables and quantifiers are also assigned different identifiers according to their structure.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    public uint GetAstId(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.GetAstId(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return a hash code for the given AST. The hash code is structural but two different AST objects can map to the same hash. The result of <c>Z3_get_ast_id</c> returns an identifier that is unique over the set of live AST objects.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    public uint GetAstHash(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetAstHash(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the sort of an AST node.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// The AST node must be a constant, application, numeral, bound variable, or quantifier.
    /// </remarks>
    public IntPtr GetSort(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetSort(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetSort));
    }

    /// <summary>
    ///  Return <c>true</c> if the given expression <c>t</c> is well sorted.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsWellSorted(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.IsWellSorted(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return <c>Z3_L_TRUE</c> if <c>a</c> is true, <c>Z3_L_FALSE</c> if it is false, and <c>Z3_L_UNDEF</c> otherwise.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_lbool">lbool value</returns>
    public Lbool GetBoolValue(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetBoolValue(c, a);
        CheckError(c);
        return (Lbool)result;
    }

    /// <summary>
    ///  Return the kind of the given AST.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast_kind">ast_kind value</returns>
    public AstKind GetAstKind(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetAstKind(c, a);
        CheckError(c);
        return (AstKind)result;
    }

    /// <summary>IsApp</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsApp(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsApp(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>IsGround</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsGround(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsGround(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>GetDepth</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    public uint GetDepth(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetDepth(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>IsNumeralAst</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsNumeralAst(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsNumeralAst(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return <c>true</c> if the given AST is a real algebraic number.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsAlgebraicNumber(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsAlgebraicNumber(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Convert an <c>ast</c> into an <c>APP_AST</c> . This is just type casting.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_app">app value</returns>
    /// <remarks>
    /// Precondition: <code>
    /// Z3_get_ast_kind(c, a) == \c Z3_APP_AST
    /// </code>
    /// </remarks>
    public IntPtr ToApp(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.ToApp(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(ToApp));
    }

    /// <summary>
    ///  Convert an AST into a FUNC_DECL_AST. This is just type casting.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: <code>
    /// Z3_get_ast_kind(c, a) == Z3_FUNC_DECL_AST
    /// </code>
    /// </remarks>
    public IntPtr ToFuncDecl(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.ToFuncDecl(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(ToFuncDecl));
    }

    /// <summary>
    ///  Return numeral value, as a decimal string of a numeric constant term.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
    /// </remarks>
    public string GetNumeralString(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetNumeralString(c, a);
        CheckError(c);
        result = CheckHandle(result, nameof(GetNumeralString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return numeral value, as a binary string of a numeric constant term.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
    /// Precondition: a represents a non-negative integer
    /// </remarks>
    public string GetNumeralBinaryString(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetNumeralBinaryString(c, a);
        CheckError(c);
        result = CheckHandle(result, nameof(GetNumeralBinaryString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return numeral as a string in decimal notation. The result has at most <c>precision</c> decimal places.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="precision" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)
    /// </remarks>
    public string GetNumeralDecimalString(IntPtr c, IntPtr a, uint precision)
    {
        var result = nativeLibrary.GetNumeralDecimalString(c, a, precision);
        CheckError(c);
        result = CheckHandle(result, nameof(GetNumeralDecimalString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return numeral as a double.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="double">double value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)
    /// </remarks>
    public double GetNumeralDouble(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetNumeralDouble(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the numerator (as a numeral AST) of a numeral AST of sort Real.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
    /// </remarks>
    public IntPtr GetNumerator(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetNumerator(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetNumerator));
    }

    /// <summary>
    ///  Return the denominator (as a numeral AST) of a numeral AST of sort Real.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
    /// </remarks>
    public IntPtr GetDenominator(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetDenominator(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetDenominator));
    }

    /// <summary>
    ///  Return numeral value, as a pair of 64 bit numbers if the representation fits.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="a" ctype="Z3_ast"> term. </param>
    /// <param name="num" ctype="int64_t*"> numerator. </param>
    /// <param name="den" ctype="int64_t*"> denominator. </param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Return <c>true</c> if the numeral value fits in 64 bit numerals, <c>false</c> otherwise. Equivalent to <c>Z3_get_numeral_rational_int64</c> except that for unsupported expression arguments <c>Z3_get_numeral_small</c> signals an error while <c>Z3_get_numeral_rational_int64</c> returns <c>false</c> .
    /// Precondition: Z3_get_ast_kind(a) == Z3_NUMERAL_AST
    /// </remarks>
    public bool GetNumeralSmall(IntPtr c, IntPtr a, out long num, out long den)
    {
        var result = nativeLibrary.GetNumeralSmall(c, a, out num, out den);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Similar to <see cref="GetNumeralString"/> , but only succeeds if the value can fit in a machine int. Return <c>true</c> if the call succeeded.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="int*">int parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
    /// </remarks>
    /// <seealso cref="GetNumeralString"/>
    public bool GetNumeralInt(IntPtr c, IntPtr v, out int i)
    {
        var result = nativeLibrary.GetNumeralInt(c, v, out i);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Similar to <see cref="GetNumeralString"/> , but only succeeds if the value can fit in a machine unsigned int. Return <c>true</c> if the call succeeded.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="u" ctype="unsigned*">unsigned parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
    /// </remarks>
    /// <seealso cref="GetNumeralString"/>
    public bool GetNumeralUint(IntPtr c, IntPtr v, out uint u)
    {
        var result = nativeLibrary.GetNumeralUint(c, v, out u);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Similar to <see cref="GetNumeralString"/> , but only succeeds if the value can fit in a machine <c>uint64_t</c> int. Return <c>true</c> if the call succeeded.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="u" ctype="uint64_t*">uint64_t parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
    /// </remarks>
    /// <seealso cref="GetNumeralString"/>
    public bool GetNumeralUint64(IntPtr c, IntPtr v, out ulong u)
    {
        var result = nativeLibrary.GetNumeralUint64(c, v, out u);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Similar to <see cref="GetNumeralString"/> , but only succeeds if the value can fit in a machine <c>int64_t</c> int. Return <c>true</c> if the call succeeded.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="int64_t*">int64_t parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
    /// </remarks>
    /// <seealso cref="GetNumeralString"/>
    public bool GetNumeralInt64(IntPtr c, IntPtr v, out long i)
    {
        var result = nativeLibrary.GetNumeralInt64(c, v, out i);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Similar to <see cref="GetNumeralString"/> , but only succeeds if the value can fit as a rational number as machine <c>int64_t</c> int. Return <c>true</c> if the call succeeded.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="num" ctype="int64_t*">int64_t parameter</param>
    /// <param name="den" ctype="int64_t*">int64_t parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
    /// </remarks>
    /// <seealso cref="GetNumeralString"/>
    public bool GetNumeralRationalInt64(IntPtr c, IntPtr v, out long num, out long den)
    {
        var result = nativeLibrary.GetNumeralRationalInt64(c, v, out num, out den);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return a lower bound for the given real algebraic number. The interval isolating the number is smaller than 1/10^precision. The result is a numeral AST of sort Real.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="precision" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_is_algebraic_number(c, a)
    /// </remarks>
    public IntPtr GetAlgebraicNumberLower(IntPtr c, IntPtr a, uint precision)
    {
        var result = nativeLibrary.GetAlgebraicNumberLower(c, a, precision);
        CheckError(c);
        return CheckHandle(result, nameof(GetAlgebraicNumberLower));
    }

    /// <summary>
    ///  Return a upper bound for the given real algebraic number. The interval isolating the number is smaller than 1/10^precision. The result is a numeral AST of sort Real.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="precision" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_is_algebraic_number(c, a)
    /// </remarks>
    public IntPtr GetAlgebraicNumberUpper(IntPtr c, IntPtr a, uint precision)
    {
        var result = nativeLibrary.GetAlgebraicNumberUpper(c, a, precision);
        CheckError(c);
        return CheckHandle(result, nameof(GetAlgebraicNumberUpper));
    }

    /// <summary>
    ///  Convert a Z3_pattern into Z3_ast. This is just type casting.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="p" ctype="Z3_pattern">pattern parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr PatternToAst(IntPtr c, IntPtr p)
    {
        var result = nativeLibrary.PatternToAst(c, p);
        CheckError(c);
        return CheckHandle(result, nameof(PatternToAst));
    }

    /// <summary>
    ///  Return number of terms in pattern.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="p" ctype="Z3_pattern">pattern parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    public uint GetPatternNumTerms(IntPtr c, IntPtr p)
    {
        var result = nativeLibrary.GetPatternNumTerms(c, p);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return i'th ast in pattern.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="p" ctype="Z3_pattern">pattern parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr GetPattern(IntPtr c, IntPtr p, uint idx)
    {
        var result = nativeLibrary.GetPattern(c, p, idx);
        CheckError(c);
        return CheckHandle(result, nameof(GetPattern));
    }

    /// <summary>
    ///  Return index of de-Bruijn bound variable.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_VAR_AST
    /// </remarks>
    public uint GetIndexValue(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetIndexValue(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Determine if an ast is a universal quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsQuantifierForall(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsQuantifierForall(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Determine if ast is an existential quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsQuantifierExists(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsQuantifierExists(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Determine if ast is a lambda expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public bool IsLambda(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsLambda(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Obtain weight of quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public uint GetQuantifierWeight(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetQuantifierWeight(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Obtain skolem id of quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_symbol">symbol value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public IntPtr GetQuantifierSkolemId(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetQuantifierSkolemId(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetQuantifierSkolemId));
    }

    /// <summary>
    ///  Obtain id of quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_symbol">symbol value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public IntPtr GetQuantifierId(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetQuantifierId(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetQuantifierId));
    }

    /// <summary>
    ///  Return number of patterns used in quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public uint GetQuantifierNumPatterns(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetQuantifierNumPatterns(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return i'th pattern.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_pattern">pattern value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public IntPtr GetQuantifierPatternAst(IntPtr c, IntPtr a, uint i)
    {
        var result = nativeLibrary.GetQuantifierPatternAst(c, a, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetQuantifierPatternAst));
    }

    /// <summary>
    ///  Return number of no_patterns used in quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public uint GetQuantifierNumNoPatterns(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetQuantifierNumNoPatterns(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return i'th no_pattern.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public IntPtr GetQuantifierNoPatternAst(IntPtr c, IntPtr a, uint i)
    {
        var result = nativeLibrary.GetQuantifierNoPatternAst(c, a, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetQuantifierNoPatternAst));
    }

    /// <summary>
    ///  Return number of bound variables of quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public uint GetQuantifierNumBound(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetQuantifierNumBound(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return symbol of the i'th bound variable.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_symbol">symbol value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public IntPtr GetQuantifierBoundName(IntPtr c, IntPtr a, uint i)
    {
        var result = nativeLibrary.GetQuantifierBoundName(c, a, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetQuantifierBoundName));
    }

    /// <summary>
    ///  Return sort of the i'th bound variable.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public IntPtr GetQuantifierBoundSort(IntPtr c, IntPtr a, uint i)
    {
        var result = nativeLibrary.GetQuantifierBoundSort(c, a, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetQuantifierBoundSort));
    }

    /// <summary>
    ///  Return body of quantifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
    /// </remarks>
    public IntPtr GetQuantifierBody(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetQuantifierBody(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetQuantifierBody));
    }

    /// <summary>
    ///  Interface to simplifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Provides an interface to the AST simplifier used by Z3. It returns an AST object which is equal to the argument. The returned AST is simplified using algebraic simplification rules, such as constant propagation (propagating true/false over logical connectives).
    /// </remarks>
    /// <seealso cref="SimplifyEx"/>
    public IntPtr Simplify(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.Simplify(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(Simplify));
    }

    /// <summary>
    ///  Interface to simplifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="p" ctype="Z3_params">params parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Provides an interface to the AST simplifier used by Z3. This procedure is similar to <see cref="Simplify"/> , but the behavior of the simplifier can be configured using the given parameter set.
    /// </remarks>
    /// <seealso cref="Simplify"/>
    /// <seealso cref="SimplifyGetHelp"/>
    /// <seealso cref="SimplifyGetParamDescrs"/>
    public IntPtr SimplifyEx(IntPtr c, IntPtr a, IntPtr p)
    {
        var result = nativeLibrary.SimplifyEx(c, a, p);
        CheckError(c);
        return CheckHandle(result, nameof(SimplifyEx));
    }

    /// <summary>
    ///  Return a string describing all available parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <seealso cref="SimplifyEx"/>
    /// <seealso cref="SimplifyGetParamDescrs"/>
    public string SimplifyGetHelp(IntPtr c)
    {
        var result = nativeLibrary.SimplifyGetHelp(c);
        CheckError(c);
        result = CheckHandle(result, nameof(SimplifyGetHelp));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return the parameter description set for the simplify procedure.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_param_descrs">param_descrs value</returns>
    /// <seealso cref="SimplifyEx"/>
    /// <seealso cref="SimplifyGetHelp"/>
    public IntPtr SimplifyGetParamDescrs(IntPtr c)
    {
        var result = nativeLibrary.SimplifyGetParamDescrs(c);
        CheckError(c);
        return CheckHandle(result, nameof(SimplifyGetParamDescrs));
    }

}
