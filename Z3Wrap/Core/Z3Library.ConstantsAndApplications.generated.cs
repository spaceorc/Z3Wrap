// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.ConstantsAndApplications.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

#nullable enable

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Declare a constant or function.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="s"> name of the constant or function. </param>
    /// <param name="domainSize" ctype="unsigned"> number of arguments. It is 0 when declaring a constant. </param>
    /// <param name="domain" ctype="Z3_sort const[]"> array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant. </param>
    /// <param name="range" ctype="Z3_sort"> sort of the constant or the return sort of the function. </param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// After declaring a constant or function, the function <see cref="MkApp"/> can be used to create a constant or function application.
    /// </remarks>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    public IntPtr MkFuncDecl(IntPtr c, string s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkFuncDecl(c, sSymbol, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkFuncDecl));
    }

    /// <summary>
    ///  Declare a constant or function.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="s" ctype="Z3_symbol"> name of the constant or function. </param>
    /// <param name="domainSize" ctype="unsigned"> number of arguments. It is 0 when declaring a constant. </param>
    /// <param name="domain" ctype="Z3_sort const[]"> array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant. </param>
    /// <param name="range" ctype="Z3_sort"> sort of the constant or the return sort of the function. </param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// After declaring a constant or function, the function <see cref="MkApp"/> can be used to create a constant or function application.
    /// </remarks>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    public IntPtr MkFuncDeclOriginal(IntPtr c, IntPtr s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        var result = nativeLibrary.MkFuncDecl(c, s, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkFuncDecl));
    }

    /// <summary>
    ///  Create a constant or function application.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    public IntPtr MkApp(IntPtr c, IntPtr d, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkApp(c, d, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkApp));
    }

    /// <summary>
    ///  Declare and create a constant.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s">symbol parameter</param>
    /// <param name="ty" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This function is a shorthand for: <code>
    /// Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
    /// Z3_ast n            = Z3_mk_app(c, d, 0, 0);
    /// </code>
    /// </remarks>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshConst"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkConst(IntPtr c, string s, IntPtr ty)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkConst(c, sSymbol, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkConst));
    }

    /// <summary>
    ///  Declare and create a constant.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_symbol">symbol parameter</param>
    /// <param name="ty" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This function is a shorthand for: <code>
    /// Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
    /// Z3_ast n            = Z3_mk_app(c, d, 0, 0);
    /// </code>
    /// </remarks>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshConst"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkConstOriginal(IntPtr c, IntPtr s, IntPtr ty)
    {
        var result = nativeLibrary.MkConst(c, s, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkConst));
    }

    /// <summary>
    ///  Declare a fresh constant or function.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="prefix" ctype="Z3_string">string parameter</param>
    /// <param name="domainSize" ctype="unsigned">unsigned parameter</param>
    /// <param name="domain" ctype="Z3_sort const[]">sort parameter</param>
    /// <param name="range" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Z3 will generate an unique name for this function declaration. If prefix is different from <c>NULL</c> , then the name generate by Z3 will start with <c>prefix</c> .
    /// If <c>prefix</c> is <c>NULL</c> , then it is assumed to be the empty string.
    /// </remarks>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkFreshFuncDecl(IntPtr c, string prefix, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        using var prefixAnsi = new AnsiStringPtr(prefix);
        var result = nativeLibrary.MkFreshFuncDecl(c, prefixAnsi, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkFreshFuncDecl));
    }

    /// <summary>
    ///  Declare and create a fresh constant.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="prefix" ctype="Z3_string">string parameter</param>
    /// <param name="ty" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This function is a shorthand for: <code>
    /// Z3_func_decl d = Z3_mk_fresh_func_decl(c, prefix, 0, 0, ty); Z3_ast n = Z3_mk_app(c, d, 0, 0);
    /// </code>
    /// If <c>prefix</c> is <c>NULL</c> , then it is assumed to be the empty string.
    /// </remarks>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkConst"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkFreshConst(IntPtr c, string prefix, IntPtr ty)
    {
        using var prefixAnsi = new AnsiStringPtr(prefix);
        var result = nativeLibrary.MkFreshConst(c, prefixAnsi, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFreshConst));
    }

    /// <summary>
    ///  Declare a recursive function.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="s"> name of the function. </param>
    /// <param name="domainSize" ctype="unsigned"> number of arguments. It should be greater than 0. </param>
    /// <param name="domain" ctype="Z3_sort const[]"> array containing the sort of each argument. The array must contain domain_size elements. </param>
    /// <param name="range" ctype="Z3_sort"> sort of the constant or the return sort of the function. </param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// After declaring recursive function, it should be associated with a recursive definition <see cref="AddRecDef"/> . The function <see cref="MkApp"/> can be used to create a constant or function application.
    /// </remarks>
    /// <seealso cref="AddRecDef"/>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkRecFuncDecl(IntPtr c, string s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkRecFuncDecl(c, sSymbol, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkRecFuncDecl));
    }

    /// <summary>
    ///  Declare a recursive function.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="s" ctype="Z3_symbol"> name of the function. </param>
    /// <param name="domainSize" ctype="unsigned"> number of arguments. It should be greater than 0. </param>
    /// <param name="domain" ctype="Z3_sort const[]"> array containing the sort of each argument. The array must contain domain_size elements. </param>
    /// <param name="range" ctype="Z3_sort"> sort of the constant or the return sort of the function. </param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// After declaring recursive function, it should be associated with a recursive definition <see cref="AddRecDef"/> . The function <see cref="MkApp"/> can be used to create a constant or function application.
    /// </remarks>
    /// <seealso cref="AddRecDef"/>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkRecFuncDeclOriginal(IntPtr c, IntPtr s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        var result = nativeLibrary.MkRecFuncDecl(c, s, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkRecFuncDecl));
    }

    /// <summary>
    ///  Define the body of a recursive function.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="f" ctype="Z3_func_decl"> function declaration. </param>
    /// <param name="n" ctype="unsigned"> number of arguments to the function </param>
    /// <param name="args" ctype="Z3_ast[]"> constants that are used as arguments to the recursive function in the definition. </param>
    /// <param name="body" ctype="Z3_ast"> body of the recursive function </param>
    /// <remarks>
    /// After declaring a recursive function or a collection of mutually recursive functions, use this function to provide the definition for the recursive function.
    /// </remarks>
    /// <seealso cref="MkRecFuncDecl"/>
    public void AddRecDef(IntPtr c, IntPtr f, uint n, IntPtr[] args, IntPtr body)
    {
        nativeLibrary.AddRecDef(c, f, n, args, body);
        CheckError(c);
    }

}
