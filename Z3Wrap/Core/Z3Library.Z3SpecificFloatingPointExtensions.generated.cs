// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Z3SpecificFloatingPointExtensions.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

#nullable enable

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Retrieves the number of bits reserved for the exponent in a FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="s" ctype="Z3_sort"> FloatingPoint sort </param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="FpaGetSbits"/>
    public uint FpaGetEbits(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.FpaGetEbits(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Retrieves the number of bits reserved for the significand in a FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="s" ctype="Z3_sort"> FloatingPoint sort </param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="FpaGetEbits"/>
    public uint FpaGetSbits(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.FpaGetSbits(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Checks whether a given floating-point numeral is a NaN.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="bool">bool value</returns>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralNan(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralNan(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Checks whether a given floating-point numeral is a +oo or -oo.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="bool">bool value</returns>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralInf(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralInf(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Checks whether a given floating-point numeral is +zero or -zero.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="bool">bool value</returns>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    public bool FpaIsNumeralZero(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralZero(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Checks whether a given floating-point numeral is normal.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="bool">bool value</returns>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralNormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralNormal(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Checks whether a given floating-point numeral is subnormal.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="bool">bool value</returns>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralSubnormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralSubnormal(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Checks whether a given floating-point numeral is positive.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="bool">bool value</returns>
    /// <seealso cref="FpaIsNumeralNegative"/>
    public bool FpaIsNumeralPositive(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralPositive(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Checks whether a given floating-point numeral is negative.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="bool">bool value</returns>
    /// <seealso cref="FpaIsNumeralPositive"/>
    public bool FpaIsNumeralNegative(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralNegative(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Retrieves the sign of a floating-point literal as a bit-vector expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Remarks: NaN is an invalid argument.
    /// </remarks>
    public IntPtr FpaGetNumeralSignBv(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaGetNumeralSignBv(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralSignBv));
    }

    /// <summary>
    ///  Retrieves the significand of a floating-point literal as a bit-vector expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Remarks: NaN is an invalid argument.
    /// </remarks>
    public IntPtr FpaGetNumeralSignificandBv(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaGetNumeralSignificandBv(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralSignificandBv));
    }

    /// <summary>
    ///  Retrieves the sign of a floating-point literal.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <param name="sgn" ctype="int *"> the retrieved sign </param>
    /// <returns ctype="bool">true if <c>t</c> corresponds to a floating point numeral, otherwise invokes exception handler or returns false </returns>
    public bool FpaGetNumeralSign(IntPtr c, IntPtr t, out int sgn)
    {
        var result = nativeLibrary.FpaGetNumeralSign(c, t, out sgn);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Return the significand value of a floating-point numeral as a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <returns ctype="Z3_string">true if <c>t</c> corresponds to a floating point numeral, otherwise invokes exception handler or returns false </returns>
    public string FpaGetNumeralSignificandString(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaGetNumeralSignificandString(c, t);
        CheckError(c);
        result = CheckHandle(result, nameof(FpaGetNumeralSignificandString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return the significand value of a floating-point numeral as a uint64.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <param name="n" ctype="uint64_t *"> pointer to output uint64 </param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Remarks: This function extracts the significand bits in <c>t</c> , without the hidden bit or normalization. Sets the <c>Z3_INVALID_ARG</c> error code if the significand does not fit into a <c>uint64</c> . NaN is an invalid argument.
    /// </remarks>
    public bool FpaGetNumeralSignificandUint64(IntPtr c, IntPtr t, out ulong n)
    {
        var result = nativeLibrary.FpaGetNumeralSignificandUint64(c, t, out n);
        CheckError(c);
        return result;
    }

    /// <summary>FpaGetNumeralExponentString</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <param name="biased" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// <code>
    /// \brief Return the exponent value of a floating-point numeral as a string.
    /// 
    /// \param c logical context
    /// \param t a floating-point numeral
    /// \param biased flag to indicate whether the result is in biased representation
    /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
    /// 
    /// Remarks: This function extracts the exponent in `t`, without normalization.
    /// NaN is an invalid argument.
    /// 
    /// </code>
    /// </remarks>
    public string FpaGetNumeralExponentString(IntPtr c, IntPtr t, bool biased)
    {
        var result = nativeLibrary.FpaGetNumeralExponentString(c, t, biased);
        CheckError(c);
        result = CheckHandle(result, nameof(FpaGetNumeralExponentString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return the exponent value of a floating-point numeral as a signed 64-bit integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <param name="n" ctype="int64_t *"> exponent </param>
    /// <param name="biased" ctype="bool"> flag to indicate whether the result is in biased representation </param>
    /// <returns ctype="bool">true if <c>t</c> corresponds to a floating point numeral, otherwise invokes exception handler or returns false </returns>
    public bool FpaGetNumeralExponentInt64(IntPtr c, IntPtr t, out long n, bool biased)
    {
        var result = nativeLibrary.FpaGetNumeralExponentInt64(c, t, out n, biased);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Retrieves the exponent of a floating-point literal as a bit-vector expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> a floating-point numeral </param>
    /// <param name="biased" ctype="bool"> flag to indicate whether the result is in biased representation </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Remarks: This function extracts the exponent in <c>t</c> , without normalization. NaN is an invalid arguments.
    /// </remarks>
    public IntPtr FpaGetNumeralExponentBv(IntPtr c, IntPtr t, bool biased)
    {
        var result = nativeLibrary.FpaGetNumeralExponentBv(c, t, biased);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralExponentBv));
    }

    /// <summary>
    ///  Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort. The size of the resulting bit-vector is automatically determined. Note that IEEE 754-2008 allows multiple different representations of NaN. This conversion knows only one NaN and it will always produce the same bit-vector representation of that NaN.
    /// </remarks>
    public IntPtr MkFpaToIeeeBv(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaToIeeeBv(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToIeeeBv));
    }

    /// <summary>
    ///  Conversion of a real-sorted significand and an integer-sorted exponent into a term of FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="exp" ctype="Z3_ast"> exponent term of Int sort </param>
    /// <param name="sig" ctype="Z3_ast"> significand term of Real sort </param>
    /// <param name="s" ctype="Z3_sort"> FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of <c>sig * 2^exp</c> into a floating-point term of sort <c>s</c> . If necessary, the result will be rounded according to rounding mode <c>rm</c> . <c>s</c> must be a FloatingPoint sort, <c>rm</c> must be of RoundingMode sort, <c>exp</c> must be of int sort, <c>sig</c> must be of real sort.
    /// </remarks>
    public IntPtr MkFpaToFpIntReal(IntPtr c, IntPtr rm, IntPtr exp, IntPtr sig, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpIntReal(c, rm, exp, sig, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpIntReal));
    }

}
