// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Constants and Applications
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop2;

internal sealed partial class NativeLibrary2
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkFuncDeclDelegate(IntPtr c, IntPtr s, uint domain_size, IntPtr domain, IntPtr range);

    /// <summary>
    /// Declare a constant or function.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="s">name of the constant or function.</param>
    /// <param name="domain_size">number of arguments. It is 0 when declaring a constant.</param>
    /// <param name="domain">array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant.</param>
    /// <param name="range">sort of the constant or the return sort of the function. After declaring a constant or function, the function Z3_mk_app can be used to create a constant or function application.</param>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    [Z3Function("Z3_mk_func_decl")]
    internal IntPtr MkFuncDecl(IntPtr c, IntPtr s, uint domain_size, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_func_decl");
        var func = Marshal.GetDelegateForFunctionPointer<MkFuncDeclDelegate>(funcPtr);
        return func(c, s, domain_size, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkAppDelegate(IntPtr c, IntPtr d, uint num_args, IntPtr args);

    /// <summary>
    /// Create a constant or function application.
    /// </summary>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    [Z3Function("Z3_mk_app")]
    internal IntPtr MkApp(IntPtr c, IntPtr d, uint num_args, IntPtr args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_app");
        var func = Marshal.GetDelegateForFunctionPointer<MkAppDelegate>(funcPtr);
        return func(c, d, num_args, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConstDelegate(IntPtr c, IntPtr s, IntPtr ty);

    /// <summary>
    /// Declare and create a constant. This function is a shorthand for: \code Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty); Z3_ast n = Z3_mk_app(c, d, 0, 0); \endcode
    /// </summary>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshConst"/>
    /// <seealso cref="MkFuncDecl"/>
    [Z3Function("Z3_mk_const")]
    internal IntPtr MkConst(IntPtr c, IntPtr s, IntPtr ty)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkConstDelegate>(funcPtr);
        return func(c, s, ty);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkFreshFuncDeclDelegate(IntPtr c, IntPtr prefix, uint domain_size, IntPtr domain, IntPtr range);

    /// <summary>
    /// Declare a fresh constant or function. Z3 will generate an unique name for this function declaration. If prefix is different from NULL, then the name generate by Z3 will start with prefix.
    /// </summary>
    /// <remarks>
    /// If prefix is NULL, then it is assumed to be the empty string.
    /// </remarks>
    /// <seealso cref="MkFuncDecl"/>
    [Z3Function("Z3_mk_fresh_func_decl")]
    internal IntPtr MkFreshFuncDecl(IntPtr c, IntPtr prefix, uint domain_size, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_fresh_func_decl");
        var func = Marshal.GetDelegateForFunctionPointer<MkFreshFuncDeclDelegate>(funcPtr);
        return func(c, prefix, domain_size, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkFreshConstDelegate(IntPtr c, IntPtr prefix, IntPtr ty);

    /// <summary>
    /// Declare and create a fresh constant. This function is a shorthand for: \code Z3_func_decl d = Z3_mk_fresh_func_decl(c, prefix, 0, 0, ty); Z3_ast n = Z3_mk_app(c, d, 0, 0); \endcode
    /// </summary>
    /// <remarks>
    /// If prefix is NULL, then it is assumed to be the empty string.
    /// </remarks>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkConst"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkFuncDecl"/>
    [Z3Function("Z3_mk_fresh_const")]
    internal IntPtr MkFreshConst(IntPtr c, IntPtr prefix, IntPtr ty)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_fresh_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkFreshConstDelegate>(funcPtr);
        return func(c, prefix, ty);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRecFuncDeclDelegate(IntPtr c, IntPtr s, uint domain_size, IntPtr domain, IntPtr range);

    /// <summary>
    /// Declare a recursive function
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="s">name of the function.</param>
    /// <param name="domain_size">number of arguments. It should be greater than 0.</param>
    /// <param name="domain">array containing the sort of each argument. The array must contain domain_size elements.</param>
    /// <param name="range">sort of the constant or the return sort of the function. After declaring recursive function, it should be associated with a recursive definition Z3_add_rec_def. The function Z3_mk_app can be used to create a constant or function application.</param>
    /// <seealso cref="AddRecDef"/>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFuncDecl"/>
    [Z3Function("Z3_mk_rec_func_decl")]
    internal IntPtr MkRecFuncDecl(IntPtr c, IntPtr s, uint domain_size, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_rec_func_decl");
        var func = Marshal.GetDelegateForFunctionPointer<MkRecFuncDeclDelegate>(funcPtr);
        return func(c, s, domain_size, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void AddRecDefDelegate(IntPtr c, IntPtr f, uint n, IntPtr args, IntPtr body);

    /// <summary>
    /// Define the body of a recursive function.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="f">function declaration.</param>
    /// <param name="n">number of arguments to the function</param>
    /// <param name="args">constants that are used as arguments to the recursive function in the definition.</param>
    /// <param name="body">body of the recursive function After declaring a recursive function or a collection of mutually recursive functions, use this function to provide the definition for the recursive function.</param>
    /// <seealso cref="MkRecFuncDecl"/>
    [Z3Function("Z3_add_rec_def")]
    internal void AddRecDef(IntPtr c, IntPtr f, uint n, IntPtr args, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_add_rec_def");
        var func = Marshal.GetDelegateForFunctionPointer<AddRecDefDelegate>(funcPtr);
        func(c, f, n, args, body);
    }

}
