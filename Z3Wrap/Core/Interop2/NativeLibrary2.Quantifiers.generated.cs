// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Quantifiers
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop2;

internal sealed partial class NativeLibrary2
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkPatternDelegate(IntPtr c, uint num_patterns, IntPtr terms);

    /// <summary>
    /// Create a pattern for quantifier instantiation.
    /// </summary>
    [Z3Function("Z3_mk_pattern")]
    internal IntPtr MkPattern(IntPtr c, uint num_patterns, IntPtr terms)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_pattern");
        var func = Marshal.GetDelegateForFunctionPointer<MkPatternDelegate>(funcPtr);
        return func(c, num_patterns, terms);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBoundDelegate(IntPtr c, uint index, IntPtr ty);

    /// <summary>
    /// Create a variable.
    /// </summary>
    [Z3Function("Z3_mk_bound")]
    internal IntPtr MkBound(IntPtr c, uint index, IntPtr ty)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bound");
        var func = Marshal.GetDelegateForFunctionPointer<MkBoundDelegate>(funcPtr);
        return func(c, index, ty);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkForallDelegate(IntPtr c, uint weight, uint num_patterns, IntPtr patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body);

    /// <summary>
    /// Create a forall formula. It takes an expression
    /// </summary>
    [Z3Function("Z3_mk_forall")]
    internal IntPtr MkForall(IntPtr c, uint weight, uint num_patterns, IntPtr patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_forall");
        var func = Marshal.GetDelegateForFunctionPointer<MkForallDelegate>(funcPtr);
        return func(c, weight, num_patterns, patterns, num_decls, sorts, decl_names, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExistsDelegate(IntPtr c, uint weight, uint num_patterns, IntPtr patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body);

    /// <summary>
    /// Create an exists formula. Similar to #Z3_mk_forall.
    /// </summary>
    [Z3Function("Z3_mk_exists")]
    internal IntPtr MkExists(IntPtr c, uint weight, uint num_patterns, IntPtr patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_exists");
        var func = Marshal.GetDelegateForFunctionPointer<MkExistsDelegate>(funcPtr);
        return func(c, weight, num_patterns, patterns, num_decls, sorts, decl_names, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierDelegate(IntPtr c, bool is_forall, uint weight, uint num_patterns, IntPtr patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body);

    /// <summary>
    /// Create a quantifier - universal or existential, with pattern hints. See the documentation for #Z3_mk_forall for an explanation of the parameters.
    /// </summary>
    [Z3Function("Z3_mk_quantifier")]
    internal IntPtr MkQuantifier(IntPtr c, bool is_forall, uint weight, uint num_patterns, IntPtr patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierDelegate>(funcPtr);
        return func(c, is_forall, weight, num_patterns, patterns, num_decls, sorts, decl_names, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierExDelegate(IntPtr c, bool is_forall, uint weight, IntPtr quantifier_id, IntPtr skolem_id, uint num_patterns, IntPtr patterns, uint num_no_patterns, IntPtr no_patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body);

    /// <summary>
    /// Create a quantifier - universal or existential, with pattern hints, no patterns, and attributes
    /// </summary>
    [Z3Function("Z3_mk_quantifier_ex")]
    internal IntPtr MkQuantifierEx(IntPtr c, bool is_forall, uint weight, IntPtr quantifier_id, IntPtr skolem_id, uint num_patterns, IntPtr patterns, uint num_no_patterns, IntPtr no_patterns, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier_ex");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierExDelegate>(funcPtr);
        return func(c, is_forall, weight, quantifier_id, skolem_id, num_patterns, patterns, num_no_patterns, no_patterns, num_decls, sorts, decl_names, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkForallConstDelegate(IntPtr c, uint weight, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, IntPtr body);

    /// <summary>
    /// Create a universal quantifier using a list of constants that will form the set of bound variables.
    /// </summary>
    [Z3Function("Z3_mk_forall_const")]
    internal IntPtr MkForallConst(IntPtr c, uint weight, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_forall_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkForallConstDelegate>(funcPtr);
        return func(c, weight, num_bound, bound, num_patterns, patterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExistsConstDelegate(IntPtr c, uint weight, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, IntPtr body);

    /// <summary>
    /// Similar to #Z3_mk_forall_const.
    /// </summary>
    [Z3Function("Z3_mk_exists_const")]
    internal IntPtr MkExistsConst(IntPtr c, uint weight, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_exists_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkExistsConstDelegate>(funcPtr);
        return func(c, weight, num_bound, bound, num_patterns, patterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierConstDelegate(IntPtr c, bool is_forall, uint weight, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, IntPtr body);

    /// <summary>
    /// Create a universal or existential quantifier using a list of constants that will form the set of bound variables.
    /// </summary>
    [Z3Function("Z3_mk_quantifier_const")]
    internal IntPtr MkQuantifierConst(IntPtr c, bool is_forall, uint weight, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierConstDelegate>(funcPtr);
        return func(c, is_forall, weight, num_bound, bound, num_patterns, patterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierConstExDelegate(IntPtr c, bool is_forall, uint weight, IntPtr quantifier_id, IntPtr skolem_id, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, uint num_no_patterns, IntPtr no_patterns, IntPtr body);

    /// <summary>
    /// Create a universal or existential quantifier using a list of constants that will form the set of bound variables.
    /// </summary>
    [Z3Function("Z3_mk_quantifier_const_ex")]
    internal IntPtr MkQuantifierConstEx(IntPtr c, bool is_forall, uint weight, IntPtr quantifier_id, IntPtr skolem_id, uint num_bound, IntPtr bound, uint num_patterns, IntPtr patterns, uint num_no_patterns, IntPtr no_patterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier_const_ex");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierConstExDelegate>(funcPtr);
        return func(c, is_forall, weight, quantifier_id, skolem_id, num_bound, bound, num_patterns, patterns, num_no_patterns, no_patterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkLambdaDelegate(IntPtr c, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body);

    /// <summary>
    /// Create a lambda expression. It takes an expression
    /// </summary>
    [Z3Function("Z3_mk_lambda")]
    internal IntPtr MkLambda(IntPtr c, uint num_decls, IntPtr sorts, IntPtr decl_names, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_lambda");
        var func = Marshal.GetDelegateForFunctionPointer<MkLambdaDelegate>(funcPtr);
        return func(c, num_decls, sorts, decl_names, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkLambdaConstDelegate(IntPtr c, uint num_bound, IntPtr bound, IntPtr body);

    /// <summary>
    /// Create a lambda expression using a list of constants that form the set of bound variables
    /// </summary>
    [Z3Function("Z3_mk_lambda_const")]
    internal IntPtr MkLambdaConst(IntPtr c, uint num_bound, IntPtr bound, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_lambda_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkLambdaConstDelegate>(funcPtr);
        return func(c, num_bound, bound, body);
    }

}
