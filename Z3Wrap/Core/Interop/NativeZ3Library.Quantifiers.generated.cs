// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Quantifiers
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkPatternDelegate(IntPtr c, uint numPatterns, IntPtr[] terms);

    /// <summary>
    /// Create a pattern for quantifier instantiation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numPatterns" ctype="unsigned">unsigned parameter</param>
    /// <param name="terms" ctype="Z3_ast const[]">ast parameter</param>
    /// <seealso cref="MkForall"/>
    /// <seealso cref="MkExists"/>
    [Z3Function("Z3_mk_pattern")]
    internal IntPtr MkPattern(IntPtr c, uint numPatterns, IntPtr[] terms)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_pattern");
        var func = Marshal.GetDelegateForFunctionPointer<MkPatternDelegate>(funcPtr);
        return func(c, numPatterns, terms);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBoundDelegate(IntPtr c, uint index, IntPtr ty);

    /// <summary>
    /// Create a variable.
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context</param>
    /// <param name="index" ctype="unsigned">de-Bruijn index</param>
    /// <param name="ty" ctype="Z3_sort">sort of the bound variable</param>
    /// <seealso cref="MkForall"/>
    /// <seealso cref="MkExists"/>
    [Z3Function("Z3_mk_bound")]
    internal IntPtr MkBound(IntPtr c, uint index, IntPtr ty)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bound");
        var func = Marshal.GetDelegateForFunctionPointer<MkBoundDelegate>(funcPtr);
        return func(c, index, ty);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkForallDelegate(IntPtr c, uint weight, uint numPatterns, IntPtr[] patterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body);

    /// <summary>
    /// Create a forall formula. It takes an expression \c body that contains bound variables of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers to the variable with index 1, etc.
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context.</param>
    /// <param name="weight" ctype="unsigned">quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.</param>
    /// <param name="numPatterns" ctype="unsigned">number of patterns.</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">array containing the patterns created using #Z3_mk_pattern.</param>
    /// <param name="numDecls" ctype="unsigned">number of variables to be bound.</param>
    /// <param name="sorts" ctype="Z3_sort const[]">the sorts of the bound variables.</param>
    /// <param name="declNames" ctype="Z3_symbol const[]">names of the bound variables</param>
    /// <param name="body" ctype="Z3_ast">the body of the quantifier.</param>
    /// <seealso cref="MkPattern"/>
    /// <seealso cref="MkBound"/>
    /// <seealso cref="MkExists"/>
    [Z3Function("Z3_mk_forall")]
    internal IntPtr MkForall(IntPtr c, uint weight, uint numPatterns, IntPtr[] patterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_forall");
        var func = Marshal.GetDelegateForFunctionPointer<MkForallDelegate>(funcPtr);
        return func(c, weight, numPatterns, patterns, numDecls, sorts, declNames, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExistsDelegate(IntPtr c, uint weight, uint numPatterns, IntPtr[] patterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body);

    /// <summary>
    /// Create an exists formula. Similar to #Z3_mk_forall.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="weight" ctype="unsigned">unsigned parameter</param>
    /// <param name="numPatterns" ctype="unsigned">unsigned parameter</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">pattern parameter</param>
    /// <param name="numDecls" ctype="unsigned">unsigned parameter</param>
    /// <param name="sorts" ctype="Z3_sort const[]">sort parameter</param>
    /// <param name="declNames" ctype="Z3_symbol const[]">symbol parameter</param>
    /// <param name="body" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="MkPattern"/>
    /// <seealso cref="MkBound"/>
    /// <seealso cref="MkForall"/>
    /// <seealso cref="MkQuantifier"/>
    [Z3Function("Z3_mk_exists")]
    internal IntPtr MkExists(IntPtr c, uint weight, uint numPatterns, IntPtr[] patterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_exists");
        var func = Marshal.GetDelegateForFunctionPointer<MkExistsDelegate>(funcPtr);
        return func(c, weight, numPatterns, patterns, numDecls, sorts, declNames, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierDelegate(IntPtr c, bool isForall, uint weight, uint numPatterns, IntPtr[] patterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body);

    /// <summary>
    /// Create a quantifier - universal or existential, with pattern hints. See the documentation for #Z3_mk_forall for an explanation of the parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context.</param>
    /// <param name="isForall" ctype="bool">flag to indicate if this is a universal or existential quantifier.</param>
    /// <param name="weight" ctype="unsigned">quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.</param>
    /// <param name="numPatterns" ctype="unsigned">number of patterns.</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">array containing the patterns created using #Z3_mk_pattern.</param>
    /// <param name="numDecls" ctype="unsigned">number of variables to be bound.</param>
    /// <param name="sorts" ctype="Z3_sort const[]">array of sorts of the bound variables.</param>
    /// <param name="declNames" ctype="Z3_symbol const[]">names of the bound variables.</param>
    /// <param name="body" ctype="Z3_ast">the body of the quantifier.</param>
    /// <seealso cref="MkPattern"/>
    /// <seealso cref="MkBound"/>
    /// <seealso cref="MkForall"/>
    /// <seealso cref="MkExists"/>
    [Z3Function("Z3_mk_quantifier")]
    internal IntPtr MkQuantifier(IntPtr c, bool isForall, uint weight, uint numPatterns, IntPtr[] patterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierDelegate>(funcPtr);
        return func(c, isForall, weight, numPatterns, patterns, numDecls, sorts, declNames, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierExDelegate(IntPtr c, bool isForall, uint weight, IntPtr quantifierId, IntPtr skolemId, uint numPatterns, IntPtr[] patterns, uint numNoPatterns, IntPtr[] noPatterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body);

    /// <summary>
    /// Create a quantifier - universal or existential, with pattern hints, no patterns, and attributes
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context.</param>
    /// <param name="isForall" ctype="bool">flag to indicate if this is a universal or existential quantifier.</param>
    /// <param name="weight" ctype="unsigned">quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.</param>
    /// <param name="quantifierId" ctype="Z3_symbol">identifier to identify quantifier</param>
    /// <param name="skolemId" ctype="Z3_symbol">identifier to identify skolem constants introduced by quantifier.</param>
    /// <param name="numPatterns" ctype="unsigned">number of patterns.</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">array containing the patterns created using #Z3_mk_pattern.</param>
    /// <param name="numNoPatterns" ctype="unsigned">number of no_patterns.</param>
    /// <param name="noPatterns" ctype="Z3_ast const[]">array containing subexpressions to be excluded from inferred patterns.</param>
    /// <param name="numDecls" ctype="unsigned">number of variables to be bound.</param>
    /// <param name="sorts" ctype="Z3_sort const[]">array of sorts of the bound variables.</param>
    /// <param name="declNames" ctype="Z3_symbol const[]">names of the bound variables.</param>
    /// <param name="body" ctype="Z3_ast">the body of the quantifier.</param>
    /// <seealso cref="MkPattern"/>
    /// <seealso cref="MkBound"/>
    /// <seealso cref="MkForall"/>
    /// <seealso cref="MkExists"/>
    [Z3Function("Z3_mk_quantifier_ex")]
    internal IntPtr MkQuantifierEx(IntPtr c, bool isForall, uint weight, IntPtr quantifierId, IntPtr skolemId, uint numPatterns, IntPtr[] patterns, uint numNoPatterns, IntPtr[] noPatterns, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier_ex");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierExDelegate>(funcPtr);
        return func(c, isForall, weight, quantifierId, skolemId, numPatterns, patterns, numNoPatterns, noPatterns, numDecls, sorts, declNames, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkForallConstDelegate(IntPtr c, uint weight, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, IntPtr body);

    /// <summary>
    /// Create a universal quantifier using a list of constants that will form the set of bound variables.
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context.</param>
    /// <param name="weight" ctype="unsigned">quantifiers are associated with weights indicating the importance of using</param>
    /// <param name="numBound" ctype="unsigned">number of constants to be abstracted into bound variables.</param>
    /// <param name="bound" ctype="Z3_app const[]">array of constants to be abstracted into bound variables.</param>
    /// <param name="numPatterns" ctype="unsigned">number of patterns.</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">array containing the patterns created using #Z3_mk_pattern.</param>
    /// <param name="body" ctype="Z3_ast">the body of the quantifier.</param>
    /// <remarks>
    /// the quantifier during instantiation. By default, pass the weight 0.
    /// </remarks>
    /// <seealso cref="MkPattern"/>
    /// <seealso cref="MkExistsConst"/>
    [Z3Function("Z3_mk_forall_const")]
    internal IntPtr MkForallConst(IntPtr c, uint weight, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_forall_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkForallConstDelegate>(funcPtr);
        return func(c, weight, numBound, bound, numPatterns, patterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExistsConstDelegate(IntPtr c, uint weight, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, IntPtr body);

    /// <summary>
    /// Create an existential quantifier using a list of constants that will form the set of bound variables.
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context.</param>
    /// <param name="weight" ctype="unsigned">quantifiers are associated with weights indicating the importance of using</param>
    /// <param name="numBound" ctype="unsigned">number of constants to be abstracted into bound variables.</param>
    /// <param name="bound" ctype="Z3_app const[]">array of constants to be abstracted into bound variables.</param>
    /// <param name="numPatterns" ctype="unsigned">number of patterns.</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">array containing the patterns created using #Z3_mk_pattern.</param>
    /// <param name="body" ctype="Z3_ast">the body of the quantifier.</param>
    /// <remarks>
    /// the quantifier during instantiation. By default, pass the weight 0.
    /// </remarks>
    /// <seealso cref="MkPattern"/>
    /// <seealso cref="MkForallConst"/>
    [Z3Function("Z3_mk_exists_const")]
    internal IntPtr MkExistsConst(IntPtr c, uint weight, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_exists_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkExistsConstDelegate>(funcPtr);
        return func(c, weight, numBound, bound, numPatterns, patterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierConstDelegate(IntPtr c, bool isForall, uint weight, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, IntPtr body);

    /// <summary>
    /// Create a universal or existential quantifier using a list of constants that will form the set of bound variables.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="isForall" ctype="bool">bool parameter</param>
    /// <param name="weight" ctype="unsigned">unsigned parameter</param>
    /// <param name="numBound" ctype="unsigned">unsigned parameter</param>
    /// <param name="bound" ctype="Z3_app const[]">app parameter</param>
    /// <param name="numPatterns" ctype="unsigned">unsigned parameter</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">pattern parameter</param>
    /// <param name="body" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_quantifier_const")]
    internal IntPtr MkQuantifierConst(IntPtr c, bool isForall, uint weight, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierConstDelegate>(funcPtr);
        return func(c, isForall, weight, numBound, bound, numPatterns, patterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkQuantifierConstExDelegate(IntPtr c, bool isForall, uint weight, IntPtr quantifierId, IntPtr skolemId, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, uint numNoPatterns, IntPtr[] noPatterns, IntPtr body);

    /// <summary>
    /// Create a universal or existential quantifier using a list of constants that will form the set of bound variables.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="isForall" ctype="bool">bool parameter</param>
    /// <param name="weight" ctype="unsigned">unsigned parameter</param>
    /// <param name="quantifierId" ctype="Z3_symbol">symbol parameter</param>
    /// <param name="skolemId" ctype="Z3_symbol">symbol parameter</param>
    /// <param name="numBound" ctype="unsigned">unsigned parameter</param>
    /// <param name="bound" ctype="Z3_app const[]">app parameter</param>
    /// <param name="numPatterns" ctype="unsigned">unsigned parameter</param>
    /// <param name="patterns" ctype="Z3_pattern const[]">pattern parameter</param>
    /// <param name="numNoPatterns" ctype="unsigned">unsigned parameter</param>
    /// <param name="noPatterns" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="body" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_quantifier_const_ex")]
    internal IntPtr MkQuantifierConstEx(IntPtr c, bool isForall, uint weight, IntPtr quantifierId, IntPtr skolemId, uint numBound, IntPtr[] bound, uint numPatterns, IntPtr[] patterns, uint numNoPatterns, IntPtr[] noPatterns, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_quantifier_const_ex");
        var func = Marshal.GetDelegateForFunctionPointer<MkQuantifierConstExDelegate>(funcPtr);
        return func(c, isForall, weight, quantifierId, skolemId, numBound, bound, numPatterns, patterns, numNoPatterns, noPatterns, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkLambdaDelegate(IntPtr c, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body);

    /// <summary>
    /// Create a lambda expression. It takes an expression \c body that contains bound variables of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers to the variable with index 1, etc. The sort of the resulting expression is \c (Array sorts range) where \c range is the sort of \c body. For example, if the lambda binds two variables of sort \c Int and \c Bool, and the \c body has sort \c Real, the sort of the expression is \c (Array Int Bool Real).
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context</param>
    /// <param name="numDecls" ctype="unsigned">number of variables to be bound.</param>
    /// <param name="sorts" ctype="Z3_sort const[]">the sorts of the bound variables.</param>
    /// <param name="declNames" ctype="Z3_symbol const[]">names of the bound variables</param>
    /// <param name="body" ctype="Z3_ast">the body of the lambda expression.</param>
    /// <seealso cref="MkBound"/>
    /// <seealso cref="MkForall"/>
    /// <seealso cref="MkLambdaConst"/>
    [Z3Function("Z3_mk_lambda")]
    internal IntPtr MkLambda(IntPtr c, uint numDecls, IntPtr[] sorts, IntPtr[] declNames, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_lambda");
        var func = Marshal.GetDelegateForFunctionPointer<MkLambdaDelegate>(funcPtr);
        return func(c, numDecls, sorts, declNames, body);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkLambdaConstDelegate(IntPtr c, uint numBound, IntPtr[] bound, IntPtr body);

    /// <summary>
    /// Create a lambda expression using a list of constants that form the set of bound variables
    /// </summary>
    /// <param name="c" ctype="Z3_context">logical context.</param>
    /// <param name="numBound" ctype="unsigned">number of constants to be abstracted into bound variables.</param>
    /// <param name="bound" ctype="Z3_app const[]">array of constants to be abstracted into bound variables.</param>
    /// <param name="body" ctype="Z3_ast">the body of the lambda expression.</param>
    /// <seealso cref="MkBound"/>
    /// <seealso cref="MkForall"/>
    /// <seealso cref="MkLambda"/>
    [Z3Function("Z3_mk_lambda_const")]
    internal IntPtr MkLambdaConst(IntPtr c, uint numBound, IntPtr[] bound, IntPtr body)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_lambda_const");
        var func = Marshal.GetDelegateForFunctionPointer<MkLambdaConstDelegate>(funcPtr);
        return func(c, numBound, bound, body);
    }

}
