// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Context and AST Reference Counting
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkContextDelegate(IntPtr c);

    /// <summary>
    ///  Create a context using the given configuration. 
    /// </summary>
    /// <param name="c" ctype="Z3_config">config parameter</param>
    /// <remarks>
    /// After a context is created, the configuration cannot be changed, although some parameters can be changed using <see cref="UpdateParamValue"/> . All main interaction with Z3 happens in the context of a <c>Z3_context</c> . In contrast to <c>Z3_mk_context_rc</c> the life time of <c>Z3_ast</c> objects persists with the life time of the context. Note that all other reference counted objects, including <c>Z3_model</c> , <c>Z3_solver</c> , <c>Z3_func_interp</c> have to be managed by the caller. Their reference counts are not handled by the context.
    /// Thread safety: objects created using a given context should not be accessed from different threads without synchronization. In other words, operations on a context are not thread safe. To use Z3 from different threads create separate context objects. The <c>Z3_translate</c> , <c>Z3_solver_translate</c> , <c>Z3_model_translate</c> , <c>Z3_goal_translate</c> methods are exposed to allow copying state from one context to another. 
    ///  <c>Z3_sort</c> , <c>Z3_func_decl</c> , <c>Z3_app</c> , <c>Z3_pattern</c> are <c>Z3_ast's</c> .  Z3 uses hash-consing, i.e., when the same <c>Z3_ast</c> is created twice, Z3 will return the same pointer twice.   
    /// </remarks>
    /// <seealso cref="DelContext"/>
    [Z3Function("Z3_mk_context")]
    internal IntPtr MkContext(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_context");
        var func = Marshal.GetDelegateForFunctionPointer<MkContextDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkContextRcDelegate(IntPtr c);

    /// <summary>
    ///  Create a context using the given configuration. This function is similar to <see cref="MkContext"/> . However, in the context returned by this function, the user is responsible for managing <c>Z3_ast</c> reference counters. Managing reference counters is a burden and error-prone, but allows the user to use the memory more efficiently. The user must invoke <see cref="IncRef"/> for any <c>Z3_ast</c> returned by Z3, and <see cref="DecRef"/> whenever the <c>Z3_ast</c> is not needed anymore. This idiom is similar to the one used in BDD (binary decision diagrams) packages such as CUDD. 
    /// </summary>
    /// <param name="c" ctype="Z3_config">config parameter</param>
    /// <remarks>
    /// Remarks:  <c>Z3_sort</c> , <c>Z3_func_decl</c> , <c>Z3_app</c> , <c>Z3_pattern</c> are <c>Z3_ast's</c> .  After a context is created, the configuration cannot be changed.  All main interaction with Z3 happens in the context of a <c>Z3_context</c> .  Z3 uses hash-consing, i.e., when the same <c>Z3_ast</c> is created twice, Z3 will return the same pointer twice.  
    /// </remarks>
    [Z3Function("Z3_mk_context_rc")]
    internal IntPtr MkContextRc(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_context_rc");
        var func = Marshal.GetDelegateForFunctionPointer<MkContextRcDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void DelContextDelegate(IntPtr c);

    /// <summary>
    ///  Delete the given logical context. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <seealso cref="MkContext"/>
    [Z3Function("Z3_del_context")]
    internal void DelContext(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_del_context");
        var func = Marshal.GetDelegateForFunctionPointer<DelContextDelegate>(funcPtr);
        func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void IncRefDelegate(IntPtr c, IntPtr a);

    /// <summary>
    ///  Increment the reference counter of the given AST. The context <c>c</c> should have been created using <see cref="MkContextRc"/> . This function is a NOOP if <c>c</c> was created using <see cref="MkContext"/> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_inc_ref")]
    internal void IncRef(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<IncRefDelegate>(funcPtr);
        func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void DecRefDelegate(IntPtr c, IntPtr a);

    /// <summary>
    ///  Decrement the reference counter of the given AST. The context <c>c</c> should have been created using <see cref="MkContextRc"/> . This function is a NOOP if <c>c</c> was created using <see cref="MkContext"/> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_dec_ref")]
    internal void DecRef(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<DecRefDelegate>(funcPtr);
        func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void UpdateParamValueDelegate(IntPtr c, IntPtr paramId, IntPtr paramValue);

    /// <summary>
    ///  Set a value of a context parameter. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="paramId" ctype="Z3_string">string parameter</param>
    /// <param name="paramValue" ctype="Z3_string">string parameter</param>
    /// <seealso cref="GlobalParamSet"/>
    [Z3Function("Z3_update_param_value")]
    internal void UpdateParamValue(IntPtr c, IntPtr paramId, IntPtr paramValue)
    {
        var funcPtr = GetFunctionPointer("Z3_update_param_value");
        var func = Marshal.GetDelegateForFunctionPointer<UpdateParamValueDelegate>(funcPtr);
        func(c, paramId, paramValue);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GetGlobalParamDescrsDelegate(IntPtr c);

    /// <summary>
    ///  Retrieve description of global parameters. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    [Z3Function("Z3_get_global_param_descrs")]
    internal IntPtr GetGlobalParamDescrs(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_get_global_param_descrs");
        var func = Marshal.GetDelegateForFunctionPointer<GetGlobalParamDescrsDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void InterruptDelegate(IntPtr c);

    /// <summary>
    ///  Interrupt the execution of a Z3 procedure. This procedure can be used to interrupt: solvers, simplifiers and tactics. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    [Z3Function("Z3_interrupt")]
    internal void Interrupt(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_interrupt");
        var func = Marshal.GetDelegateForFunctionPointer<InterruptDelegate>(funcPtr);
        func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void EnableConcurrentDecRefDelegate(IntPtr c);

    /// <summary>
    ///  use concurrency control for dec-ref. Reference counting decrements are allowed in separate threads from the context. If this setting is not invoked, reference counting decrements are not going to be thread safe. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    [Z3Function("Z3_enable_concurrent_dec_ref")]
    internal void EnableConcurrentDecRef(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_enable_concurrent_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<EnableConcurrentDecRefDelegate>(funcPtr);
        func(c);
    }

}
