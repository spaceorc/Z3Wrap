// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Models
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkModelDelegate(IntPtr c);

    /// <summary>
    ///  Create a fresh model object. It has reference count 0. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_model">model value</returns>
    [Z3Function("Z3_mk_model")]
    internal IntPtr MkModel(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_model");
        var func = Marshal.GetDelegateForFunctionPointer<MkModelDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void ModelIncRefDelegate(IntPtr c, IntPtr m);

    /// <summary>
    ///  Increment the reference counter of the given model. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    [Z3Function("Z3_model_inc_ref")]
    internal void ModelIncRef(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<ModelIncRefDelegate>(funcPtr);
        func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void ModelDecRefDelegate(IntPtr c, IntPtr m);

    /// <summary>
    ///  Decrement the reference counter of the given model. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    [Z3Function("Z3_model_dec_ref")]
    internal void ModelDecRef(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<ModelDecRefDelegate>(funcPtr);
        func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool ModelEvalDelegate(IntPtr c, IntPtr m, IntPtr t, bool modelCompletion, IntPtr v);

    /// <summary>
    ///  Evaluate the AST node <c>t</c> in the given model. Return <c>true</c> if succeeded, and store the result in <c>v</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <param name="modelCompletion" ctype="bool">bool parameter</param>
    /// <param name="v" ctype="Z3_ast *">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// If <c>model_completion</c> is <c>true</c> , then Z3 will assign an interpretation for any constant or function that does not have an interpretation in <c>m</c> . These constants and functions were essentially don't cares. If <c>model_completion</c> is <c>false</c> , then Z3 will not assign interpretations to constants for functions that do not have interpretations in <c>m</c> . Evaluation behaves as the identify function in this case. The evaluation may fail for the following reasons:  <c>t</c> contains a quantifier.  the model <c>m</c> is partial, that is, it doesn't have a complete interpretation for uninterpreted functions. That is, the option <c>MODEL_PARTIAL=true</c> was used.  <c>t</c> is type incorrect.  <c>Z3_interrupt</c> was invoked during evaluation.  
    /// </remarks>
    [Z3Function("Z3_model_eval")]
    internal bool ModelEval(IntPtr c, IntPtr m, IntPtr t, bool modelCompletion, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_model_eval");
        var func = Marshal.GetDelegateForFunctionPointer<ModelEvalDelegate>(funcPtr);
        return func(c, m, t, modelCompletion, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetConstInterpDelegate(IntPtr c, IntPtr m, IntPtr a);

    /// <summary>
    ///  Return the interpretation (i.e., assignment) of constant <c>a</c> in the model <c>m</c> . Return <c>NULL</c> , if the model does not assign an interpretation for <c>a</c> . That should be interpreted as: the value of <c>a</c> does not matter. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="a" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, a) == 0 
    /// </remarks>
    [Z3Function("Z3_model_get_const_interp")]
    internal IntPtr ModelGetConstInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_const_interp");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetConstInterpDelegate>(funcPtr);
        return func(c, m, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool ModelHasInterpDelegate(IntPtr c, IntPtr m, IntPtr a);

    /// <summary>
    ///  Test if there exists an interpretation (i.e., assignment) for <c>a</c> in the model <c>m</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="a" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="bool">bool value</returns>
    [Z3Function("Z3_model_has_interp")]
    internal bool ModelHasInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_model_has_interp");
        var func = Marshal.GetDelegateForFunctionPointer<ModelHasInterpDelegate>(funcPtr);
        return func(c, m, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetFuncInterpDelegate(IntPtr c, IntPtr m, IntPtr f);

    /// <summary>
    ///  Return the interpretation of the function <c>f</c> in the model <c>m</c> . Return <c>NULL</c> , if the model does not assign an interpretation for <c>f</c> . That should be interpreted as: the <c>f</c> does not matter. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_func_interp">func_interp value</returns>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, f) &gt; 0 
    /// Reference counting must be used to manage Z3_func_interp objects, even when the Z3_context was created using <see cref="MkContext"/> instead of <see cref="MkContextRc"/> . 
    /// </remarks>
    [Z3Function("Z3_model_get_func_interp")]
    internal IntPtr ModelGetFuncInterp(IntPtr c, IntPtr m, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_func_interp");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetFuncInterpDelegate>(funcPtr);
        return func(c, m, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ModelGetNumConstsDelegate(IntPtr c, IntPtr m);

    /// <summary>
    ///  Return the number of constants assigned by the given model. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="ModelGetConstDecl"/>
    [Z3Function("Z3_model_get_num_consts")]
    internal uint ModelGetNumConsts(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_num_consts");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetNumConstsDelegate>(funcPtr);
        return func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetConstDeclDelegate(IntPtr c, IntPtr m, uint i);

    /// <summary>
    ///  Return the i-th constant in the given model. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_consts(c, m) 
    /// </remarks>
    /// <seealso cref="ModelEval"/>
    /// <seealso cref="ModelGetNumConsts"/>
    [Z3Function("Z3_model_get_const_decl")]
    internal IntPtr ModelGetConstDecl(IntPtr c, IntPtr m, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_const_decl");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetConstDeclDelegate>(funcPtr);
        return func(c, m, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ModelGetNumFuncsDelegate(IntPtr c, IntPtr m);

    /// <summary>
    ///  Return the number of function interpretations in the given model. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. Each entry in the finite map represents the value of a function given a set of arguments.
    /// </remarks>
    /// <seealso cref="ModelGetFuncDecl"/>
    [Z3Function("Z3_model_get_num_funcs")]
    internal uint ModelGetNumFuncs(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_num_funcs");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetNumFuncsDelegate>(funcPtr);
        return func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetFuncDeclDelegate(IntPtr c, IntPtr m, uint i);

    /// <summary>
    ///  Return the declaration of the i-th function in the given model. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_funcs(c, m) 
    /// </remarks>
    /// <seealso cref="ModelGetNumFuncs"/>
    [Z3Function("Z3_model_get_func_decl")]
    internal IntPtr ModelGetFuncDecl(IntPtr c, IntPtr m, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_func_decl");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetFuncDeclDelegate>(funcPtr);
        return func(c, m, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ModelGetNumSortsDelegate(IntPtr c, IntPtr m);

    /// <summary>
    ///  Return the number of uninterpreted sorts that <c>m</c> assigns an interpretation to. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Z3 also provides an interpretation for uninterpreted sorts used in a formula. The interpretation for a sort <c>s</c> is a finite set of distinct values. We say this finite set is the "universe" of <c>s</c> .
    /// </remarks>
    /// <seealso cref="ModelGetSort"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    [Z3Function("Z3_model_get_num_sorts")]
    internal uint ModelGetNumSorts(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_num_sorts");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetNumSortsDelegate>(funcPtr);
        return func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetSortDelegate(IntPtr c, IntPtr m, uint i);

    /// <summary>
    ///  Return a uninterpreted sort that <c>m</c> assigns an interpretation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_sorts(c, m) 
    /// </remarks>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    [Z3Function("Z3_model_get_sort")]
    internal IntPtr ModelGetSort(IntPtr c, IntPtr m, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_sort");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetSortDelegate>(funcPtr);
        return func(c, m, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetSortUniverseDelegate(IntPtr c, IntPtr m, IntPtr s);

    /// <summary>
    ///  Return the finite set of distinct values that represent the interpretation for sort <c>s</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSort"/>
    [Z3Function("Z3_model_get_sort_universe")]
    internal IntPtr ModelGetSortUniverse(IntPtr c, IntPtr m, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_sort_universe");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetSortUniverseDelegate>(funcPtr);
        return func(c, m, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelTranslateDelegate(IntPtr c, IntPtr m, IntPtr dst);

    /// <summary>
    ///  translate model from context <c>c</c> to context <c>dst</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="dst" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_model">model value</returns>
    /// <remarks>
    /// Use this method for cloning state between contexts. Note that operations on contexts are not thread safe and therefore all operations that related to a given context have to be synchronized (or run in the same thread). 
    /// </remarks>
    [Z3Function("Z3_model_translate")]
    internal IntPtr ModelTranslate(IntPtr c, IntPtr m, IntPtr dst)
    {
        var funcPtr = GetFunctionPointer("Z3_model_translate");
        var func = Marshal.GetDelegateForFunctionPointer<ModelTranslateDelegate>(funcPtr);
        return func(c, m, dst);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool IsAsArrayDelegate(IntPtr c, IntPtr a);

    /// <summary>
    ///  The <c>(_ as-array f)</c> AST node is a construct for assigning interpretations for arrays in Z3. It is the array such that forall indices <c>i</c> we have that <c>(select (_ as-array f) i)</c> is equal to <c>(f i)</c> . This procedure returns <c>true</c> if the <c>a</c> is an <c>as-array</c> AST node. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Z3 current solvers have minimal support for <c>as_array</c> nodes.
    /// </remarks>
    /// <seealso cref="GetAsArrayFuncDecl"/>
    [Z3Function("Z3_is_as_array")]
    internal bool IsAsArray(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_is_as_array");
        var func = Marshal.GetDelegateForFunctionPointer<IsAsArrayDelegate>(funcPtr);
        return func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GetAsArrayFuncDeclDelegate(IntPtr c, IntPtr a);

    /// <summary>
    ///  Return the function declaration <c>f</c> associated with a <c>(_ as_array f)</c> node. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <seealso cref="IsAsArray"/>
    [Z3Function("Z3_get_as_array_func_decl")]
    internal IntPtr GetAsArrayFuncDecl(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_get_as_array_func_decl");
        var func = Marshal.GetDelegateForFunctionPointer<GetAsArrayFuncDeclDelegate>(funcPtr);
        return func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr AddFuncInterpDelegate(IntPtr c, IntPtr m, IntPtr f, IntPtr defaultValue);

    /// <summary>
    ///  Create a fresh func_interp object, add it to a model for a specified function. It has reference count 0. 
    /// </summary>
    /// <param name="c" ctype="Z3_context"> context </param>
    /// <param name="m" ctype="Z3_model"> model </param>
    /// <param name="f" ctype="Z3_func_decl"> function declaration </param>
    /// <param name="defaultValue" ctype="Z3_ast"> default value for function interpretation </param>
    /// <returns ctype="Z3_func_interp">func_interp value</returns>
    [Z3Function("Z3_add_func_interp")]
    internal IntPtr AddFuncInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr defaultValue)
    {
        var funcPtr = GetFunctionPointer("Z3_add_func_interp");
        var func = Marshal.GetDelegateForFunctionPointer<AddFuncInterpDelegate>(funcPtr);
        return func(c, m, f, defaultValue);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void AddConstInterpDelegate(IntPtr c, IntPtr m, IntPtr f, IntPtr a);

    /// <summary>
    ///  Add a constant interpretation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_add_const_interp")]
    internal void AddConstInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_add_const_interp");
        var func = Marshal.GetDelegateForFunctionPointer<AddConstInterpDelegate>(funcPtr);
        func(c, m, f, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpIncRefDelegate(IntPtr c, IntPtr f);

    /// <summary>
    ///  Increment the reference counter of the given <c>Z3_func_interp</c> object. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_interp">func_interp parameter</param>
    [Z3Function("Z3_func_interp_inc_ref")]
    internal void FuncInterpIncRef(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpIncRefDelegate>(funcPtr);
        func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpDecRefDelegate(IntPtr c, IntPtr f);

    /// <summary>
    ///  Decrement the reference counter of the given <c>Z3_func_interp</c> object. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_interp">func_interp parameter</param>
    [Z3Function("Z3_func_interp_dec_ref")]
    internal void FuncInterpDecRef(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpDecRefDelegate>(funcPtr);
        func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint FuncInterpGetNumEntriesDelegate(IntPtr c, IntPtr f);

    /// <summary>
    ///  Return the number of entries in the given function interpretation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_interp">func_interp parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. Each entry in the finite map represents the value of a function given a set of arguments. This procedure return the number of element in the finite map of <c>f</c> .
    /// </remarks>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_interp_get_num_entries")]
    internal uint FuncInterpGetNumEntries(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_num_entries");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetNumEntriesDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncInterpGetEntryDelegate(IntPtr c, IntPtr f, uint i);

    /// <summary>
    ///  Return a "point" of the given function interpretation. It represents the value of <c>f</c> in a particular point. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_interp">func_interp parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_func_entry">func_entry value</returns>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_interp_get_num_entries(c, f) 
    /// </remarks>
    /// <seealso cref="FuncInterpGetNumEntries"/>
    [Z3Function("Z3_func_interp_get_entry")]
    internal IntPtr FuncInterpGetEntry(IntPtr c, IntPtr f, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_entry");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetEntryDelegate>(funcPtr);
        return func(c, f, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncInterpGetElseDelegate(IntPtr c, IntPtr f);

    /// <summary>
    ///  Return the 'else' value of the given function interpretation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_interp">func_interp parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. This procedure returns the 'else' value.
    /// </remarks>
    [Z3Function("Z3_func_interp_get_else")]
    internal IntPtr FuncInterpGetElse(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_else");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetElseDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpSetElseDelegate(IntPtr c, IntPtr f, IntPtr elseValue);

    /// <summary>
    ///  Return the 'else' value of the given function interpretation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_interp">func_interp parameter</param>
    /// <param name="elseValue" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. This procedure can be used to update the 'else' value.
    /// </remarks>
    [Z3Function("Z3_func_interp_set_else")]
    internal void FuncInterpSetElse(IntPtr c, IntPtr f, IntPtr elseValue)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_set_else");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpSetElseDelegate>(funcPtr);
        func(c, f, elseValue);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint FuncInterpGetArityDelegate(IntPtr c, IntPtr f);

    /// <summary>
    ///  Return the arity (number of arguments) of the given function interpretation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_interp">func_interp parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    [Z3Function("Z3_func_interp_get_arity")]
    internal uint FuncInterpGetArity(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_arity");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetArityDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpAddEntryDelegate(IntPtr c, IntPtr fi, IntPtr args, IntPtr value);

    /// <summary>
    ///  add a function entry to a function interpretation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="fi" ctype="Z3_func_interp"> a function interpretation to be updated. </param>
    /// <param name="args" ctype="Z3_ast_vector"> list of arguments. They should be constant values (such as integers) and be of the same types as the domain of the function. </param>
    /// <param name="value" ctype="Z3_ast"> value of the function when the parameters match args. </param>
    /// <remarks>
    /// It is assumed that entries added to a function cover disjoint arguments. If an two entries are added with the same arguments, only the second insertion survives and the first inserted entry is removed.
    /// </remarks>
    [Z3Function("Z3_func_interp_add_entry")]
    internal void FuncInterpAddEntry(IntPtr c, IntPtr fi, IntPtr args, IntPtr value)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_add_entry");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpAddEntryDelegate>(funcPtr);
        func(c, fi, args, value);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncEntryIncRefDelegate(IntPtr c, IntPtr e);

    /// <summary>
    ///  Increment the reference counter of the given <c>Z3_func_entry</c> object. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="e" ctype="Z3_func_entry">func_entry parameter</param>
    [Z3Function("Z3_func_entry_inc_ref")]
    internal void FuncEntryIncRef(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryIncRefDelegate>(funcPtr);
        func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncEntryDecRefDelegate(IntPtr c, IntPtr e);

    /// <summary>
    ///  Decrement the reference counter of the given <c>Z3_func_entry</c> object. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="e" ctype="Z3_func_entry">func_entry parameter</param>
    [Z3Function("Z3_func_entry_dec_ref")]
    internal void FuncEntryDecRef(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryDecRefDelegate>(funcPtr);
        func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncEntryGetValueDelegate(IntPtr c, IntPtr e);

    /// <summary>
    ///  Return the value of this point. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="e" ctype="Z3_func_entry">func_entry parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// A <c>Z3_func_entry</c> object represents an element in the finite map used to encode a function interpretation.
    /// </remarks>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_entry_get_value")]
    internal IntPtr FuncEntryGetValue(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_get_value");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryGetValueDelegate>(funcPtr);
        return func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint FuncEntryGetNumArgsDelegate(IntPtr c, IntPtr e);

    /// <summary>
    ///  Return the number of arguments in a <c>Z3_func_entry</c> object. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="e" ctype="Z3_func_entry">func_entry parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="FuncEntryGetArg"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_entry_get_num_args")]
    internal uint FuncEntryGetNumArgs(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_get_num_args");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryGetNumArgsDelegate>(funcPtr);
        return func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncEntryGetArgDelegate(IntPtr c, IntPtr e, uint i);

    /// <summary>
    ///  Return an argument of a <c>Z3_func_entry</c> object. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="e" ctype="Z3_func_entry">func_entry parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_entry_get_num_args(c, e) 
    /// </remarks>
    /// <seealso cref="FuncEntryGetNumArgs"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_entry_get_arg")]
    internal IntPtr FuncEntryGetArg(IntPtr c, IntPtr e, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_get_arg");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryGetArgDelegate>(funcPtr);
        return func(c, e, i);
    }

}
