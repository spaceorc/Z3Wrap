// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Models
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkModelDelegate(IntPtr c);

    /// <summary>
    /// Create a fresh model object. It has reference count 0.
    /// </summary>
    [Z3Function("Z3_mk_model")]
    internal IntPtr MkModel(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_model");
        var func = Marshal.GetDelegateForFunctionPointer<MkModelDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void ModelIncRefDelegate(IntPtr c, IntPtr m);

    /// <summary>
    /// Increment the reference counter of the given model.
    /// </summary>
    [Z3Function("Z3_model_inc_ref")]
    internal void ModelIncRef(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<ModelIncRefDelegate>(funcPtr);
        func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void ModelDecRefDelegate(IntPtr c, IntPtr m);

    /// <summary>
    /// Decrement the reference counter of the given model.
    /// </summary>
    [Z3Function("Z3_model_dec_ref")]
    internal void ModelDecRef(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<ModelDecRefDelegate>(funcPtr);
        func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool ModelEvalDelegate(IntPtr c, IntPtr m, IntPtr t, bool modelCompletion, IntPtr v);

    /// <summary>
    /// Evaluate the AST node t in the given model. Return true if succeeded, and store the result in v. If model_completion is true, then Z3 will assign an interpretation for any constant or function that does not have an interpretation in m. These constants and functions were essentially don't cares. If model_completion is false, then Z3 will not assign interpretations to constants for functions that do not have interpretations in m. Evaluation behaves as the identify function in this case. The evaluation may fail for the following reasons: - t contains a quantifier. - the model m is partial, that is, it doesn't have a complete interpretation for uninterpreted functions. That is, the option MODEL_PARTIAL=true was used. - t is type incorrect. - Z3_interrupt was invoked during evaluation.
    /// </summary>
    [Z3Function("Z3_model_eval")]
    internal bool ModelEval(IntPtr c, IntPtr m, IntPtr t, bool modelCompletion, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_model_eval");
        var func = Marshal.GetDelegateForFunctionPointer<ModelEvalDelegate>(funcPtr);
        return func(c, m, t, modelCompletion, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetConstInterpDelegate(IntPtr c, IntPtr m, IntPtr a);

    /// <summary>
    /// Return the interpretation (i.e., assignment) of constant a in the model m. Return NULL, if the model does not assign an interpretation for a. That should be interpreted as: the value of a does not matter.
    /// </summary>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, a) == 0
    /// </remarks>
    [Z3Function("Z3_model_get_const_interp")]
    internal IntPtr ModelGetConstInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_const_interp");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetConstInterpDelegate>(funcPtr);
        return func(c, m, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool ModelHasInterpDelegate(IntPtr c, IntPtr m, IntPtr a);

    /// <summary>
    /// Test if there exists an interpretation (i.e., assignment) for a in the model m.
    /// </summary>
    [Z3Function("Z3_model_has_interp")]
    internal bool ModelHasInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_model_has_interp");
        var func = Marshal.GetDelegateForFunctionPointer<ModelHasInterpDelegate>(funcPtr);
        return func(c, m, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetFuncInterpDelegate(IntPtr c, IntPtr m, IntPtr f);

    /// <summary>
    /// Return the interpretation of the function f in the model m. Return NULL, if the model does not assign an interpretation for f. That should be interpreted as: the f does not matter.
    /// </summary>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, f) &gt; 0
    /// Reference counting must be used to manage Z3_func_interp objects, even when the Z3_context was created using Z3_mk_context instead of Z3_mk_context_rc.
    /// </remarks>
    [Z3Function("Z3_model_get_func_interp")]
    internal IntPtr ModelGetFuncInterp(IntPtr c, IntPtr m, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_func_interp");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetFuncInterpDelegate>(funcPtr);
        return func(c, m, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ModelGetNumConstsDelegate(IntPtr c, IntPtr m);

    /// <summary>
    /// Return the number of constants assigned by the given model.
    /// </summary>
    /// <seealso cref="ModelGetConstDecl"/>
    [Z3Function("Z3_model_get_num_consts")]
    internal uint ModelGetNumConsts(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_num_consts");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetNumConstsDelegate>(funcPtr);
        return func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetConstDeclDelegate(IntPtr c, IntPtr m, uint i);

    /// <summary>
    /// Return the i-th constant in the given model.
    /// </summary>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_consts(c, m)
    /// </remarks>
    /// <seealso cref="ModelEval"/>
    /// <seealso cref="ModelGetNumConsts"/>
    [Z3Function("Z3_model_get_const_decl")]
    internal IntPtr ModelGetConstDecl(IntPtr c, IntPtr m, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_const_decl");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetConstDeclDelegate>(funcPtr);
        return func(c, m, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ModelGetNumFuncsDelegate(IntPtr c, IntPtr m);

    /// <summary>
    /// Return the number of function interpretations in the given model. A function interpretation is represented as a finite map and an 'else' value. Each entry in the finite map represents the value of a function given a set of arguments.
    /// </summary>
    /// <seealso cref="ModelGetFuncDecl"/>
    [Z3Function("Z3_model_get_num_funcs")]
    internal uint ModelGetNumFuncs(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_num_funcs");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetNumFuncsDelegate>(funcPtr);
        return func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetFuncDeclDelegate(IntPtr c, IntPtr m, uint i);

    /// <summary>
    /// Return the declaration of the i-th function in the given model.
    /// </summary>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_funcs(c, m)
    /// </remarks>
    /// <seealso cref="ModelGetNumFuncs"/>
    [Z3Function("Z3_model_get_func_decl")]
    internal IntPtr ModelGetFuncDecl(IntPtr c, IntPtr m, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_func_decl");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetFuncDeclDelegate>(funcPtr);
        return func(c, m, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ModelGetNumSortsDelegate(IntPtr c, IntPtr m);

    /// <summary>
    /// Return the number of uninterpreted sorts that m assigns an interpretation to. Z3 also provides an interpretation for uninterpreted sorts used in a formula. The interpretation for a sort s is a finite set of distinct values. We say this finite set is the "universe" of s.
    /// </summary>
    /// <seealso cref="ModelGetSort"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    [Z3Function("Z3_model_get_num_sorts")]
    internal uint ModelGetNumSorts(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_num_sorts");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetNumSortsDelegate>(funcPtr);
        return func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetSortDelegate(IntPtr c, IntPtr m, uint i);

    /// <summary>
    /// Return a uninterpreted sort that m assigns an interpretation.
    /// </summary>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_sorts(c, m)
    /// </remarks>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    [Z3Function("Z3_model_get_sort")]
    internal IntPtr ModelGetSort(IntPtr c, IntPtr m, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_sort");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetSortDelegate>(funcPtr);
        return func(c, m, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelGetSortUniverseDelegate(IntPtr c, IntPtr m, IntPtr s);

    /// <summary>
    /// Return the finite set of distinct values that represent the interpretation for sort s.
    /// </summary>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSort"/>
    [Z3Function("Z3_model_get_sort_universe")]
    internal IntPtr ModelGetSortUniverse(IntPtr c, IntPtr m, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_model_get_sort_universe");
        var func = Marshal.GetDelegateForFunctionPointer<ModelGetSortUniverseDelegate>(funcPtr);
        return func(c, m, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelTranslateDelegate(IntPtr c, IntPtr m, IntPtr dst);

    /// <summary>
    /// translate model from context c to context dst.
    /// </summary>
    /// <remarks>
    /// Use this method for cloning state between contexts. Note that operations on contexts are not thread safe and therefore all operations that related to a given context have to be synchronized (or run in the same thread).
    /// </remarks>
    [Z3Function("Z3_model_translate")]
    internal IntPtr ModelTranslate(IntPtr c, IntPtr m, IntPtr dst)
    {
        var funcPtr = GetFunctionPointer("Z3_model_translate");
        var func = Marshal.GetDelegateForFunctionPointer<ModelTranslateDelegate>(funcPtr);
        return func(c, m, dst);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool IsAsArrayDelegate(IntPtr c, IntPtr a);

    /// <summary>
    /// The (_ as-array f) AST node is a construct for assigning interpretations for arrays in Z3. It is the array such that forall indices i we have that (select (_ as-array f) i) is equal to (f i). This procedure returns true if the a is an as-array AST node. Z3 current solvers have minimal support for as_array nodes.
    /// </summary>
    /// <seealso cref="GetAsArrayFuncDecl"/>
    [Z3Function("Z3_is_as_array")]
    internal bool IsAsArray(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_is_as_array");
        var func = Marshal.GetDelegateForFunctionPointer<IsAsArrayDelegate>(funcPtr);
        return func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GetAsArrayFuncDeclDelegate(IntPtr c, IntPtr a);

    /// <summary>
    /// Return the function declaration f associated with a (_ as_array f) node.
    /// </summary>
    /// <seealso cref="IsAsArray"/>
    [Z3Function("Z3_get_as_array_func_decl")]
    internal IntPtr GetAsArrayFuncDecl(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_get_as_array_func_decl");
        var func = Marshal.GetDelegateForFunctionPointer<GetAsArrayFuncDeclDelegate>(funcPtr);
        return func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr AddFuncInterpDelegate(IntPtr c, IntPtr m, IntPtr f, IntPtr defaultValue);

    /// <summary>
    /// Create a fresh func_interp object, add it to a model for a specified function. It has reference count 0.
    /// </summary>
    /// <param name="c">context</param>
    /// <param name="m">model</param>
    /// <param name="f">function declaration</param>
    /// <param name="defaultValue">default value for function interpretation</param>
    [Z3Function("Z3_add_func_interp")]
    internal IntPtr AddFuncInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr defaultValue)
    {
        var funcPtr = GetFunctionPointer("Z3_add_func_interp");
        var func = Marshal.GetDelegateForFunctionPointer<AddFuncInterpDelegate>(funcPtr);
        return func(c, m, f, defaultValue);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void AddConstInterpDelegate(IntPtr c, IntPtr m, IntPtr f, IntPtr a);

    /// <summary>
    /// Add a constant interpretation.
    /// </summary>
    [Z3Function("Z3_add_const_interp")]
    internal void AddConstInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_add_const_interp");
        var func = Marshal.GetDelegateForFunctionPointer<AddConstInterpDelegate>(funcPtr);
        func(c, m, f, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpIncRefDelegate(IntPtr c, IntPtr f);

    /// <summary>
    /// Increment the reference counter of the given Z3_func_interp object.
    /// </summary>
    [Z3Function("Z3_func_interp_inc_ref")]
    internal void FuncInterpIncRef(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpIncRefDelegate>(funcPtr);
        func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpDecRefDelegate(IntPtr c, IntPtr f);

    /// <summary>
    /// Decrement the reference counter of the given Z3_func_interp object.
    /// </summary>
    [Z3Function("Z3_func_interp_dec_ref")]
    internal void FuncInterpDecRef(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpDecRefDelegate>(funcPtr);
        func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint FuncInterpGetNumEntriesDelegate(IntPtr c, IntPtr f);

    /// <summary>
    /// Return the number of entries in the given function interpretation. A function interpretation is represented as a finite map and an 'else' value. Each entry in the finite map represents the value of a function given a set of arguments. This procedure return the number of element in the finite map of f.
    /// </summary>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_interp_get_num_entries")]
    internal uint FuncInterpGetNumEntries(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_num_entries");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetNumEntriesDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncInterpGetEntryDelegate(IntPtr c, IntPtr f, uint i);

    /// <summary>
    /// Return a "point" of the given function interpretation. It represents the value of f in a particular point.
    /// </summary>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_interp_get_num_entries(c, f)
    /// </remarks>
    /// <seealso cref="FuncInterpGetNumEntries"/>
    [Z3Function("Z3_func_interp_get_entry")]
    internal IntPtr FuncInterpGetEntry(IntPtr c, IntPtr f, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_entry");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetEntryDelegate>(funcPtr);
        return func(c, f, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncInterpGetElseDelegate(IntPtr c, IntPtr f);

    /// <summary>
    /// Return the 'else' value of the given function interpretation. A function interpretation is represented as a finite map and an 'else' value. This procedure returns the 'else' value.
    /// </summary>
    [Z3Function("Z3_func_interp_get_else")]
    internal IntPtr FuncInterpGetElse(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_else");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetElseDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpSetElseDelegate(IntPtr c, IntPtr f, IntPtr elseValue);

    /// <summary>
    /// Return the 'else' value of the given function interpretation. A function interpretation is represented as a finite map and an 'else' value. This procedure can be used to update the 'else' value.
    /// </summary>
    [Z3Function("Z3_func_interp_set_else")]
    internal void FuncInterpSetElse(IntPtr c, IntPtr f, IntPtr elseValue)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_set_else");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpSetElseDelegate>(funcPtr);
        func(c, f, elseValue);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint FuncInterpGetArityDelegate(IntPtr c, IntPtr f);

    /// <summary>
    /// Return the arity (number of arguments) of the given function interpretation.
    /// </summary>
    [Z3Function("Z3_func_interp_get_arity")]
    internal uint FuncInterpGetArity(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_get_arity");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpGetArityDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncInterpAddEntryDelegate(IntPtr c, IntPtr fi, IntPtr args, IntPtr value);

    /// <summary>
    /// add a function entry to a function interpretation.
    /// </summary>
    /// <param name="c">logical context</param>
    /// <param name="fi">a function interpretation to be updated.</param>
    /// <param name="args">list of arguments. They should be constant values (such as integers) and be of the same types as the domain of the function.</param>
    /// <param name="value">value of the function when the parameters match args. It is assumed that entries added to a function cover disjoint arguments. If an two entries are added with the same arguments, only the second insertion survives and the first inserted entry is removed.</param>
    [Z3Function("Z3_func_interp_add_entry")]
    internal void FuncInterpAddEntry(IntPtr c, IntPtr fi, IntPtr args, IntPtr value)
    {
        var funcPtr = GetFunctionPointer("Z3_func_interp_add_entry");
        var func = Marshal.GetDelegateForFunctionPointer<FuncInterpAddEntryDelegate>(funcPtr);
        func(c, fi, args, value);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncEntryIncRefDelegate(IntPtr c, IntPtr e);

    /// <summary>
    /// Increment the reference counter of the given Z3_func_entry object.
    /// </summary>
    [Z3Function("Z3_func_entry_inc_ref")]
    internal void FuncEntryIncRef(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryIncRefDelegate>(funcPtr);
        func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void FuncEntryDecRefDelegate(IntPtr c, IntPtr e);

    /// <summary>
    /// Decrement the reference counter of the given Z3_func_entry object.
    /// </summary>
    [Z3Function("Z3_func_entry_dec_ref")]
    internal void FuncEntryDecRef(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryDecRefDelegate>(funcPtr);
        func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncEntryGetValueDelegate(IntPtr c, IntPtr e);

    /// <summary>
    /// Return the value of this point. A Z3_func_entry object represents an element in the finite map used to encode a function interpretation.
    /// </summary>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_entry_get_value")]
    internal IntPtr FuncEntryGetValue(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_get_value");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryGetValueDelegate>(funcPtr);
        return func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint FuncEntryGetNumArgsDelegate(IntPtr c, IntPtr e);

    /// <summary>
    /// Return the number of arguments in a Z3_func_entry object.
    /// </summary>
    /// <seealso cref="FuncEntryGetArg"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_entry_get_num_args")]
    internal uint FuncEntryGetNumArgs(IntPtr c, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_get_num_args");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryGetNumArgsDelegate>(funcPtr);
        return func(c, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncEntryGetArgDelegate(IntPtr c, IntPtr e, uint i);

    /// <summary>
    /// Return an argument of a Z3_func_entry object.
    /// </summary>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_entry_get_num_args(c, e)
    /// </remarks>
    /// <seealso cref="FuncEntryGetNumArgs"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    [Z3Function("Z3_func_entry_get_arg")]
    internal IntPtr FuncEntryGetArg(IntPtr c, IntPtr e, uint i)
    {
        var funcPtr = GetFunctionPointer("Z3_func_entry_get_arg");
        var func = Marshal.GetDelegateForFunctionPointer<FuncEntryGetArgDelegate>(funcPtr);
        return func(c, e, i);
    }

}
