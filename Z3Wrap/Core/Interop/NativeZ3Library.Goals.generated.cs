// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Goals
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

#nullable enable

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkGoalDelegate(IntPtr c, bool models, bool unsatCores, bool proofs);

    /// <summary>
    ///  Create a goal (aka problem). A goal is essentially a set of formulas, that can be solved and/or transformed using tactics and solvers. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="models" ctype="bool">bool parameter</param>
    /// <param name="unsatCores" ctype="bool">bool parameter</param>
    /// <param name="proofs" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_goal">goal value</returns>
    /// <remarks>
    /// If <c>models</c> is <c>true</c> , then model generation is enabled for the new goal. If <c>unsat_cores</c> is <c>true</c> , then unsat core generation is enabled for the new goal. If <c>proofs</c> is <c>true</c> , then proof generation is enabled for the new goal. Remark, the Z3 context <c>c</c> must have been created with proof generation support.
    /// Reference counting must be used to manage goals, even when the <c>Z3_context</c> was created using <see cref="MkContext"/> instead of <see cref="MkContextRc"/> . 
    /// </remarks>
    [Z3Function("Z3_mk_goal")]
    internal IntPtr MkGoal(IntPtr c, bool models, bool unsatCores, bool proofs)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_goal");
        var func = Marshal.GetDelegateForFunctionPointer<MkGoalDelegate>(funcPtr);
        return func(c, models, unsatCores, proofs);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalIncRefDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Increment the reference counter of the given goal. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_inc_ref")]
    internal void GoalIncRef(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<GoalIncRefDelegate>(funcPtr);
        func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalDecRefDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Decrement the reference counter of the given goal. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_dec_ref")]
    internal void GoalDecRef(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<GoalDecRefDelegate>(funcPtr);
        func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GoalPrec GoalPrecisionDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Return the "precision" of the given goal. Goals can be transformed using over and under approximations. A under approximation is applied when the objective is to find a model for a given goal. An over approximation is applied when the objective is to find a proof for a given goal. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="Z3_goal_prec">goal_prec value</returns>
    [Z3Function("Z3_goal_precision")]
    internal GoalPrec GoalPrecision(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_precision");
        var func = Marshal.GetDelegateForFunctionPointer<GoalPrecisionDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalAssertDelegate(IntPtr c, IntPtr g, IntPtr a);

    /// <summary>
    ///  Add a new formula <c>a</c> to the given goal. The formula is split according to the following procedure that is applied until a fixed-point: Conjunctions are split into separate formulas. Negations are distributed over disjunctions, resulting in separate formulas. If the goal is <c>false</c> , adding new formulas is a no-op. If the formula <c>a</c> is <c>true</c> , then nothing is added. If the formula <c>a</c> is <c>false</c> , then the entire goal is replaced by the formula <c>false</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_goal_assert")]
    internal void GoalAssert(IntPtr c, IntPtr g, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_assert");
        var func = Marshal.GetDelegateForFunctionPointer<GoalAssertDelegate>(funcPtr);
        func(c, g, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool GoalInconsistentDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Return <c>true</c> if the given goal contains the formula <c>false</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="bool">bool value</returns>
    [Z3Function("Z3_goal_inconsistent")]
    internal bool GoalInconsistent(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_inconsistent");
        var func = Marshal.GetDelegateForFunctionPointer<GoalInconsistentDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint GoalDepthDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Return the depth of the given goal. It tracks how many transformations were applied to it. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    [Z3Function("Z3_goal_depth")]
    internal uint GoalDepth(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_depth");
        var func = Marshal.GetDelegateForFunctionPointer<GoalDepthDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalResetDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Erase all formulas from the given goal. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_reset")]
    internal void GoalReset(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_reset");
        var func = Marshal.GetDelegateForFunctionPointer<GoalResetDelegate>(funcPtr);
        func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint GoalSizeDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Return the number of formulas in the given goal. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    [Z3Function("Z3_goal_size")]
    internal uint GoalSize(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_size");
        var func = Marshal.GetDelegateForFunctionPointer<GoalSizeDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalFormulaDelegate(IntPtr c, IntPtr g, uint idx);

    /// <summary>
    ///  Return a formula from the given goal. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: idx &lt; Z3_goal_size(c, g) 
    /// </remarks>
    [Z3Function("Z3_goal_formula")]
    internal IntPtr GoalFormula(IntPtr c, IntPtr g, uint idx)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_formula");
        var func = Marshal.GetDelegateForFunctionPointer<GoalFormulaDelegate>(funcPtr);
        return func(c, g, idx);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint GoalNumExprsDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Return the number of formulas, subformulas and terms in the given goal. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    [Z3Function("Z3_goal_num_exprs")]
    internal uint GoalNumExprs(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_num_exprs");
        var func = Marshal.GetDelegateForFunctionPointer<GoalNumExprsDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool GoalIsDecidedSatDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Return <c>true</c> if the goal is empty, and it is precise or the product of a under approximation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="bool">bool value</returns>
    [Z3Function("Z3_goal_is_decided_sat")]
    internal bool GoalIsDecidedSat(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_is_decided_sat");
        var func = Marshal.GetDelegateForFunctionPointer<GoalIsDecidedSatDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool GoalIsDecidedUnsatDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Return <c>true</c> if the goal contains false, and it is precise or the product of an over approximation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="bool">bool value</returns>
    [Z3Function("Z3_goal_is_decided_unsat")]
    internal bool GoalIsDecidedUnsat(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_is_decided_unsat");
        var func = Marshal.GetDelegateForFunctionPointer<GoalIsDecidedUnsatDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalTranslateDelegate(IntPtr source, IntPtr g, IntPtr target);

    /// <summary>
    ///  Copy a goal <c>g</c> from the context <c>source</c> to the context <c>target</c> . 
    /// </summary>
    /// <param name="source" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="target" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_goal">goal value</returns>
    [Z3Function("Z3_goal_translate")]
    internal IntPtr GoalTranslate(IntPtr source, IntPtr g, IntPtr target)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_translate");
        var func = Marshal.GetDelegateForFunctionPointer<GoalTranslateDelegate>(funcPtr);
        return func(source, g, target);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalConvertModelDelegate(IntPtr c, IntPtr g, IntPtr m);

    /// <summary>
    ///  Convert a model of the formulas of a goal to a model of an original goal. The model may be null, in which case the returned model is valid if the goal was established satisfiable. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <returns ctype="Z3_model">model value</returns>
    /// <remarks>
    /// When using this feature it is advisable to set the parameter <c>model.compact</c> to <c>false</c> . It is by default true, which erases variables created by the solver from models. Without access to model values for intermediary variables, values of other variables may end up having the wrong values.
    /// </remarks>
    [Z3Function("Z3_goal_convert_model")]
    internal IntPtr GoalConvertModel(IntPtr c, IntPtr g, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_convert_model");
        var func = Marshal.GetDelegateForFunctionPointer<GoalConvertModelDelegate>(funcPtr);
        return func(c, g, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalToStringDelegate(IntPtr c, IntPtr g);

    /// <summary>
    ///  Convert a goal into a string. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    [Z3Function("Z3_goal_to_string")]
    internal IntPtr GoalToString(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<GoalToStringDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalToDimacsStringDelegate(IntPtr c, IntPtr g, bool includeNames);

    /// <summary>
    ///  Convert a goal into a DIMACS formatted string. The goal must be in CNF. You can convert a goal to CNF by applying the tseitin-cnf tactic. Bit-vectors are not automatically converted to Booleans either, so if the caller intends to preserve satisfiability, it should apply bit-blasting tactics. Quantifiers and theory atoms will not be encoded. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="includeNames" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    [Z3Function("Z3_goal_to_dimacs_string")]
    internal IntPtr GoalToDimacsString(IntPtr c, IntPtr g, bool includeNames)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_to_dimacs_string");
        var func = Marshal.GetDelegateForFunctionPointer<GoalToDimacsStringDelegate>(funcPtr);
        return func(c, g, includeNames);
    }

}
