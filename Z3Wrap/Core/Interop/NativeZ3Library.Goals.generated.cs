// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Goals
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkGoalDelegate(IntPtr c, bool models, bool unsatCores, bool proofs);

    /// <summary>
    /// <para>
    /// Create a goal (aka problem). A goal is essentially a set
    /// of formulas, that can be solved and/or transformed using
    /// tactics and solvers.
    /// </para>
    /// <para>
    /// If models is true, then model generation is enabled for the new goal.
    /// </para>
    /// <para>
    /// If unsat_cores is true, then unsat core generation is enabled for the new goal.
    /// </para>
    /// <para>
    /// If proofs is true, then proof generation is enabled for the new goal. Remark, the
    /// Z3 context c must have been created with proof generation support.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="models" ctype="bool">bool parameter</param>
    /// <param name="unsatCores" ctype="bool">bool parameter</param>
    /// <param name="proofs" ctype="bool">bool parameter</param>
    /// <remarks>
    /// Reference counting must be used to manage goals, even when the Z3_context was
    /// created using <see cref="MkContext"/> instead of <see cref="MkContextRc"/>.
    /// </remarks>
    [Z3Function("Z3_mk_goal")]
    internal IntPtr MkGoal(IntPtr c, bool models, bool unsatCores, bool proofs)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_goal");
        var func = Marshal.GetDelegateForFunctionPointer<MkGoalDelegate>(funcPtr);
        return func(c, models, unsatCores, proofs);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalIncRefDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Increment the reference counter of the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_inc_ref")]
    internal void GoalIncRef(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<GoalIncRefDelegate>(funcPtr);
        func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalDecRefDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Decrement the reference counter of the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_dec_ref")]
    internal void GoalDecRef(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<GoalDecRefDelegate>(funcPtr);
        func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GoalPrec GoalPrecisionDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Return the "precision" of the given goal. Goals can be transformed using over and under approximations.
    /// A under approximation is applied when the objective is to find a model for a given goal.
    /// An over approximation is applied when the objective is to find a proof for a given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_precision")]
    internal GoalPrec GoalPrecision(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_precision");
        var func = Marshal.GetDelegateForFunctionPointer<GoalPrecisionDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalAssertDelegate(IntPtr c, IntPtr g, IntPtr a);

    /// <summary>
    /// Add a new formula a to the given goal.
    /// The formula is split according to the following procedure that is applied
    /// until a fixed-point:
    /// Conjunctions are split into separate formulas.
    /// Negations are distributed over disjunctions, resulting in separate formulas.
    /// If the goal is false, adding new formulas is a no-op.
    /// If the formula a is true, then nothing is added.
    /// If the formula a is false, then the entire goal is replaced by the formula false.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_goal_assert")]
    internal void GoalAssert(IntPtr c, IntPtr g, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_assert");
        var func = Marshal.GetDelegateForFunctionPointer<GoalAssertDelegate>(funcPtr);
        func(c, g, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool GoalInconsistentDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Return true if the given goal contains the formula false.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_inconsistent")]
    internal bool GoalInconsistent(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_inconsistent");
        var func = Marshal.GetDelegateForFunctionPointer<GoalInconsistentDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint GoalDepthDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Return the depth of the given goal. It tracks how many transformations were applied to it.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_depth")]
    internal uint GoalDepth(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_depth");
        var func = Marshal.GetDelegateForFunctionPointer<GoalDepthDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void GoalResetDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Erase all formulas from the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_reset")]
    internal void GoalReset(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_reset");
        var func = Marshal.GetDelegateForFunctionPointer<GoalResetDelegate>(funcPtr);
        func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint GoalSizeDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Return the number of formulas in the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_size")]
    internal uint GoalSize(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_size");
        var func = Marshal.GetDelegateForFunctionPointer<GoalSizeDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalFormulaDelegate(IntPtr c, IntPtr g, uint idx);

    /// <summary>
    /// Return a formula from the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <remarks>
    /// Precondition: idx &lt; Z3_goal_size(c, g)
    /// </remarks>
    [Z3Function("Z3_goal_formula")]
    internal IntPtr GoalFormula(IntPtr c, IntPtr g, uint idx)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_formula");
        var func = Marshal.GetDelegateForFunctionPointer<GoalFormulaDelegate>(funcPtr);
        return func(c, g, idx);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint GoalNumExprsDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Return the number of formulas, subformulas and terms in the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_num_exprs")]
    internal uint GoalNumExprs(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_num_exprs");
        var func = Marshal.GetDelegateForFunctionPointer<GoalNumExprsDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool GoalIsDecidedSatDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Return true if the goal is empty, and it is precise or the product of a under approximation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_is_decided_sat")]
    internal bool GoalIsDecidedSat(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_is_decided_sat");
        var func = Marshal.GetDelegateForFunctionPointer<GoalIsDecidedSatDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool GoalIsDecidedUnsatDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Return true if the goal contains false, and it is precise or the product of an over approximation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_is_decided_unsat")]
    internal bool GoalIsDecidedUnsat(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_is_decided_unsat");
        var func = Marshal.GetDelegateForFunctionPointer<GoalIsDecidedUnsatDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalTranslateDelegate(IntPtr source, IntPtr g, IntPtr target);

    /// <summary>
    /// Copy a goal g from the context source to the context target.
    /// </summary>
    /// <param name="source" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="target" ctype="Z3_context">context parameter</param>
    [Z3Function("Z3_goal_translate")]
    internal IntPtr GoalTranslate(IntPtr source, IntPtr g, IntPtr target)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_translate");
        var func = Marshal.GetDelegateForFunctionPointer<GoalTranslateDelegate>(funcPtr);
        return func(source, g, target);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalConvertModelDelegate(IntPtr c, IntPtr g, IntPtr m);

    /// <summary>
    /// <para>
    /// Convert a model of the formulas of a goal to a model of an original goal.
    /// The model may be null, in which case the returned model is valid if the goal was
    /// established satisfiable.
    /// </para>
    /// <para>
    /// When using this feature it is advisable to set the parameter model.compact to false.
    /// It is by default true, which erases variables created by the solver from models.
    /// Without access to model values for intermediary variables, values of other variables
    /// may end up having the wrong values.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    [Z3Function("Z3_goal_convert_model")]
    internal IntPtr GoalConvertModel(IntPtr c, IntPtr g, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_convert_model");
        var func = Marshal.GetDelegateForFunctionPointer<GoalConvertModelDelegate>(funcPtr);
        return func(c, g, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalToStringDelegate(IntPtr c, IntPtr g);

    /// <summary>
    /// Convert a goal into a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    [Z3Function("Z3_goal_to_string")]
    internal IntPtr GoalToString(IntPtr c, IntPtr g)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<GoalToStringDelegate>(funcPtr);
        return func(c, g);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr GoalToDimacsStringDelegate(IntPtr c, IntPtr g, bool includeNames);

    /// <summary>
    /// Convert a goal into a DIMACS formatted string.
    /// The goal must be in CNF. You can convert a goal to CNF
    /// by applying the tseitin-cnf tactic. Bit-vectors are not automatically
    /// converted to Booleans either, so if the caller intends to
    /// preserve satisfiability, it should apply bit-blasting tactics.
    /// Quantifiers and theory atoms will not be encoded.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="g" ctype="Z3_goal">goal parameter</param>
    /// <param name="includeNames" ctype="bool">bool parameter</param>
    [Z3Function("Z3_goal_to_dimacs_string")]
    internal IntPtr GoalToDimacsString(IntPtr c, IntPtr g, bool includeNames)
    {
        var funcPtr = GetFunctionPointer("Z3_goal_to_dimacs_string");
        var func = Marshal.GetDelegateForFunctionPointer<GoalToDimacsStringDelegate>(funcPtr);
        return func(c, g, includeNames);
    }

}
