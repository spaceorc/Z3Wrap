// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Bit-vectors
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnotDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    ///  Bitwise negation. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvnot")]
    internal IntPtr MkBvnot(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvnot");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnotDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvredandDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    ///  Take conjunction of bits in vector, return vector of length 1. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvredand")]
    internal IntPtr MkBvredand(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvredand");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvredandDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvredorDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    ///  Take disjunction of bits in vector, return vector of length 1. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvredor")]
    internal IntPtr MkBvredor(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvredor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvredorDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvandDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Bitwise and. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvand")]
    internal IntPtr MkBvand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvand");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvandDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Bitwise or. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvor")]
    internal IntPtr MkBvor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvxorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Bitwise exclusive-or. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvxor")]
    internal IntPtr MkBvxor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvxor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvxorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnandDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Bitwise nand. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvnand")]
    internal IntPtr MkBvnand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvnand");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnandDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Bitwise nor. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvnor")]
    internal IntPtr MkBvnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvnor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvxnorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Bitwise xnor. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvxnor")]
    internal IntPtr MkBvxnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvxnor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvxnorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnegDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    ///  Standard two's complement unary minus. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvneg")]
    internal IntPtr MkBvneg(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvneg");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnegDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvaddDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Standard two's complement addition. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvadd")]
    internal IntPtr MkBvadd(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvadd");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvaddDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsubDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Standard two's complement subtraction. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvsub")]
    internal IntPtr MkBvsub(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsub");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsubDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvmulDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Standard two's complement multiplication. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvmul")]
    internal IntPtr MkBvmul(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvmul");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvmulDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvudivDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Unsigned division. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It is defined as the <c>floor</c> of <c>t1/t2</c> if <c>t2</c> is different from zero. If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvudiv")]
    internal IntPtr MkBvudiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvudiv");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvudivDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsdivDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Two's complement signed division. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It is defined in the following way:  The <c>floor</c> of <c>t1/t2</c> if <c>t2</c> is different from zero, and <c>t1*t2 &gt;= 0</c> .  The <c>ceiling</c> of <c>t1/t2</c> if <c>t2</c> is different from zero, and <c>t1*t2 &lt; 0</c> .   If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvsdiv")]
    internal IntPtr MkBvsdiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsdiv");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsdivDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvuremDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Unsigned remainder. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It is defined as <c>t1 - (t1 /u t2) * t2</c> , where <c>/u</c> represents unsigned division. If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvurem")]
    internal IntPtr MkBvurem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvurem");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvuremDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsremDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Two's complement signed remainder (sign follows dividend). 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It is defined as <c>t1 - (t1 /s t2) * t2</c> , where <c>/s</c> represents signed division. The most significant bit (sign) of the result is equal to the most significant bit of <c>t1</c> . If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    /// <seealso cref="MkBvsmod"/>
    [Z3Function("Z3_mk_bvsrem")]
    internal IntPtr MkBvsrem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsrem");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsremDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsmodDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Two's complement signed remainder (sign follows divisor). 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    /// <seealso cref="MkBvsrem"/>
    [Z3Function("Z3_mk_bvsmod")]
    internal IntPtr MkBvsmod(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsmod");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsmodDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvultDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Unsigned less than. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvult")]
    internal IntPtr MkBvult(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvult");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvultDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsltDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Two's complement signed less than. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It abbreviates: <code>
    /// (or (and (= (extract[|m-1|:|m-1|] t1) bit1)
    /// (= (extract[|m-1|:|m-1|] t2) bit0))
    /// (and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
    /// (bvult t1 t2)))
    /// </code> The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvslt")]
    internal IntPtr MkBvslt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvslt");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsltDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvuleDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Unsigned less than or equal to. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvule")]
    internal IntPtr MkBvule(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvule");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvuleDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsleDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Two's complement signed less than or equal to. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvsle")]
    internal IntPtr MkBvsle(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsle");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsleDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvugeDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Unsigned greater than or equal to. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvuge")]
    internal IntPtr MkBvuge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvuge");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvugeDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsgeDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Two's complement signed greater than or equal to. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvsge")]
    internal IntPtr MkBvsge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsge");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsgeDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvugtDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Unsigned greater than. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvugt")]
    internal IntPtr MkBvugt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvugt");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvugtDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsgtDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Two's complement signed greater than. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvsgt")]
    internal IntPtr MkBvsgt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsgt");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsgtDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConcatDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Concatenate the given bit-vectors. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have (possibly different) bit-vector sorts The result is a bit-vector of size <c>n1+n2</c> , where <c>n1</c> ( <c>n2</c> ) is the size of <c>t1</c> ( <c>t2</c> ).
    /// </remarks>
    [Z3Function("Z3_mk_concat")]
    internal IntPtr MkConcat(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_concat");
        var func = Marshal.GetDelegateForFunctionPointer<MkConcatDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExtractDelegate(IntPtr c, uint high, uint low, IntPtr t1);

    /// <summary>
    ///  Extract the bits <c>high</c> down to <c>low</c> from a bit-vector of size <c>m</c> to yield a new bit-vector of size <c>n</c> , where <c>n = high - low + 1</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="high" ctype="unsigned">unsigned parameter</param>
    /// <param name="low" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_extract")]
    internal IntPtr MkExtract(IntPtr c, uint high, uint low, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_extract");
        var func = Marshal.GetDelegateForFunctionPointer<MkExtractDelegate>(funcPtr);
        return func(c, high, low, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSignExtDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    ///  Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of size <c>m+i</c> , where <c>m</c> is the size of the given bit-vector. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_sign_ext")]
    internal IntPtr MkSignExt(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_sign_ext");
        var func = Marshal.GetDelegateForFunctionPointer<MkSignExtDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkZeroExtDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    ///  Extend the given bit-vector with zeros to the (unsigned) equivalent bit-vector of size <c>m+i</c> , where <c>m</c> is the size of the given bit-vector. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_zero_ext")]
    internal IntPtr MkZeroExt(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_zero_ext");
        var func = Marshal.GetDelegateForFunctionPointer<MkZeroExtDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRepeatDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    ///  Repeat the given bit-vector up length <c>i</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_repeat")]
    internal IntPtr MkRepeat(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_repeat");
        var func = Marshal.GetDelegateForFunctionPointer<MkRepeatDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBit2boolDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    ///  Extracts the bit at position <c>i</c> of a bit-vector and yields a boolean. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bit2bool")]
    internal IntPtr MkBit2bool(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bit2bool");
        var func = Marshal.GetDelegateForFunctionPointer<MkBit2boolDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvshlDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Shift left. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It is equivalent to multiplication by <c>2^x</c> where <c>x</c> is the value of the third argument. NB. The semantics of shift operations varies between environments. This definition does not necessarily capture directly the semantics of the programming language or assembly architecture you are modeling. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvshl")]
    internal IntPtr MkBvshl(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvshl");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvshlDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvlshrDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Logical shift right. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It is equivalent to unsigned division by <c>2^x</c> where <c>x</c> is the value of the third argument. NB. The semantics of shift operations varies between environments. This definition does not necessarily capture directly the semantics of the programming language or assembly architecture you are modeling. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvlshr")]
    internal IntPtr MkBvlshr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvlshr");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvlshrDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvashrDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Arithmetic shift right. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// It is like logical shift right except that the most significant bits of the result always copy the most significant bit of the second argument. The semantics of shift operations varies between environments. This definition does not necessarily capture directly the semantics of the programming language or assembly architecture you are modeling. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bvashr")]
    internal IntPtr MkBvashr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvashr");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvashrDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRotateLeftDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the left <c>i</c> times. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_rotate_left")]
    internal IntPtr MkRotateLeft(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_rotate_left");
        var func = Marshal.GetDelegateForFunctionPointer<MkRotateLeftDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRotateRightDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the right <c>i</c> times. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_rotate_right")]
    internal IntPtr MkRotateRight(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_rotate_right");
        var func = Marshal.GetDelegateForFunctionPointer<MkRotateRightDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExtRotateLeftDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the left <c>t2</c> times. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_ext_rotate_left")]
    internal IntPtr MkExtRotateLeft(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_ext_rotate_left");
        var func = Marshal.GetDelegateForFunctionPointer<MkExtRotateLeftDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExtRotateRightDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the right <c>t2</c> times. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_ext_rotate_right")]
    internal IntPtr MkExtRotateRight(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_ext_rotate_right");
        var func = Marshal.GetDelegateForFunctionPointer<MkExtRotateRightDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkInt2bvDelegate(IntPtr c, uint n, IntPtr t1);

    /// <summary>
    ///  Create an <c>n</c> bit bit-vector from the integer argument <c>t1</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The resulting bit-vector has <c>n</c> bits, where the i'th bit (counting from 0 to <c>n-1</c> ) is 1 if (t1 div 2^i) mod 2 is 1.  The node <c>t1</c> must have integer sort.
    /// </remarks>
    [Z3Function("Z3_mk_int2bv")]
    internal IntPtr MkInt2bv(IntPtr c, uint n, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_int2bv");
        var func = Marshal.GetDelegateForFunctionPointer<MkInt2bvDelegate>(funcPtr);
        return func(c, n, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBv2intDelegate(IntPtr c, IntPtr t1, bool isSigned);

    /// <summary>
    ///  Create an integer from the bit-vector argument <c>t1</c> . If <c>is_signed</c> is false, then the bit-vector <c>t1</c> is treated as unsigned. So the result is non-negative and in the range <c>[0..2^N-1]</c> , where N are the number of bits in <c>t1</c> . If <c>is_signed</c> is true, <c>t1</c> is treated as a signed bit-vector. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    [Z3Function("Z3_mk_bv2int")]
    internal IntPtr MkBv2int(IntPtr c, IntPtr t1, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bv2int");
        var func = Marshal.GetDelegateForFunctionPointer<MkBv2intDelegate>(funcPtr);
        return func(c, t1, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvaddNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned);

    /// <summary>
    ///  Create a predicate that checks that the bit-wise addition of <c>t1</c> and <c>t2</c> does not overflow. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvadd_no_overflow")]
    internal IntPtr MkBvaddNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvadd_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvaddNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvaddNoUnderflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed addition of <c>t1</c> and <c>t2</c> does not underflow. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvadd_no_underflow")]
    internal IntPtr MkBvaddNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvadd_no_underflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvaddNoUnderflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsubNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed subtraction of <c>t1</c> and <c>t2</c> does not overflow. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvsub_no_overflow")]
    internal IntPtr MkBvsubNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsub_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsubNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsubNoUnderflowDelegate(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned);

    /// <summary>
    ///  Create a predicate that checks that the bit-wise subtraction of <c>t1</c> and <c>t2</c> does not underflow. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvsub_no_underflow")]
    internal IntPtr MkBvsubNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsub_no_underflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsubNoUnderflowDelegate>(funcPtr);
        return func(c, t1, t2, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsdivNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed division of <c>t1</c> and <c>t2</c> does not overflow. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvsdiv_no_overflow")]
    internal IntPtr MkBvsdivNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsdiv_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsdivNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnegNoOverflowDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    ///  Check that bit-wise negation does not overflow when <c>t1</c> is interpreted as a signed bit-vector. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvneg_no_overflow")]
    internal IntPtr MkBvnegNoOverflow(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvneg_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnegNoOverflowDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvmulNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned);

    /// <summary>
    ///  Create a predicate that checks that the bit-wise multiplication of <c>t1</c> and <c>t2</c> does not overflow. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvmul_no_overflow")]
    internal IntPtr MkBvmulNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvmul_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvmulNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvmulNoUnderflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed multiplication of <c>t1</c> and <c>t2</c> does not underflow. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    [Z3Function("Z3_mk_bvmul_no_underflow")]
    internal IntPtr MkBvmulNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvmul_no_underflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvmulNoUnderflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

}
