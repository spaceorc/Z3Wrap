// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Bit-vectors
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnotDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// <para>
    /// Bitwise negation.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvnot")]
    internal IntPtr MkBvnot(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvnot");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnotDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvredandDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// <para>
    /// Take conjunction of bits in vector, return vector of length 1.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvredand")]
    internal IntPtr MkBvredand(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvredand");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvredandDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvredorDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// <para>
    /// Take disjunction of bits in vector, return vector of length 1.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvredor")]
    internal IntPtr MkBvredor(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvredor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvredorDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvandDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Bitwise and.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvand")]
    internal IntPtr MkBvand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvand");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvandDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Bitwise or.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvor")]
    internal IntPtr MkBvor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvxorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Bitwise exclusive-or.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvxor")]
    internal IntPtr MkBvxor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvxor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvxorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnandDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Bitwise nand.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvnand")]
    internal IntPtr MkBvnand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvnand");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnandDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Bitwise nor.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvnor")]
    internal IntPtr MkBvnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvnor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvxnorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Bitwise xnor.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvxnor")]
    internal IntPtr MkBvxnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvxnor");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvxnorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnegDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// <para>
    /// Standard two's complement unary minus.
    /// </para>
    /// <para>
    /// The node t1 must have bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvneg")]
    internal IntPtr MkBvneg(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvneg");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnegDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvaddDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Standard two's complement addition.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvadd")]
    internal IntPtr MkBvadd(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvadd");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvaddDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsubDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Standard two's complement subtraction.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsub")]
    internal IntPtr MkBvsub(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsub");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsubDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvmulDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Standard two's complement multiplication.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvmul")]
    internal IntPtr MkBvmul(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvmul");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvmulDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvudivDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Unsigned division.
    /// </para>
    /// <para>
    /// It is defined as the floor of <code>t1/t2</code> if t2 is
    /// different from zero. If <code>t2</code> is zero, then the result
    /// is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvudiv")]
    internal IntPtr MkBvudiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvudiv");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvudivDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsdivDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Two's complement signed division.
    /// </para>
    /// <para>
    /// It is defined in the following way:
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item><description>The floor of <code>t1/t2</code> if t2 is different from zero, and <code>t1*t2 &gt;= 0</code>.</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item><description>The ceiling of <code>t1/t2</code> if t2 is different from zero, and <code>t1*t2 &lt; 0</code>.</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// If <code>t2</code> is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsdiv")]
    internal IntPtr MkBvsdiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsdiv");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsdivDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvuremDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Unsigned remainder.
    /// </para>
    /// <para>
    /// It is defined as <code>t1 - (t1 /u t2) * t2</code>, where <code>/u</code> represents unsigned division.
    /// </para>
    /// <para>
    /// If <code>t2</code> is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvurem")]
    internal IntPtr MkBvurem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvurem");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvuremDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsremDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Two's complement signed remainder (sign follows dividend).
    /// </para>
    /// <para>
    /// It is defined as <code>t1 - (t1 /s t2) * t2</code>, where <code>/s</code> represents signed division.
    /// The most significant bit (sign) of the result is equal to the most significant bit of t1.
    /// </para>
    /// <para>
    /// If <code>t2</code> is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <seealso cref="MkBvsmod"/>
    [Z3Function("Z3_mk_bvsrem")]
    internal IntPtr MkBvsrem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsrem");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsremDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsmodDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Two's complement signed remainder (sign follows divisor).
    /// </para>
    /// <para>
    /// If <code>t2</code> is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <seealso cref="MkBvsrem"/>
    [Z3Function("Z3_mk_bvsmod")]
    internal IntPtr MkBvsmod(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsmod");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsmodDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvultDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Unsigned less than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvult")]
    internal IntPtr MkBvult(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvult");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvultDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsltDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Two's complement signed less than.
    /// </para>
    /// <para>
    /// It abbreviates:
    /// <code>
    /// (or (and (= (extract[|m-1|:|m-1|] t1) bit1)
    /// (= (extract[|m-1|:|m-1|] t2) bit0))
    /// (and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
    /// (bvult t1 t2)))
    /// </code>
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvslt")]
    internal IntPtr MkBvslt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvslt");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsltDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvuleDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Unsigned less than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvule")]
    internal IntPtr MkBvule(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvule");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvuleDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsleDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Two's complement signed less than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsle")]
    internal IntPtr MkBvsle(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsle");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsleDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvugeDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Unsigned greater than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvuge")]
    internal IntPtr MkBvuge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvuge");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvugeDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsgeDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Two's complement signed greater than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsge")]
    internal IntPtr MkBvsge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsge");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsgeDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvugtDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Unsigned greater than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvugt")]
    internal IntPtr MkBvugt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvugt");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvugtDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsgtDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Two's complement signed greater than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsgt")]
    internal IntPtr MkBvsgt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsgt");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsgtDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConcatDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Concatenate the given bit-vectors.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have (possibly different) bit-vector sorts
    /// </para>
    /// <para>
    /// The result is a bit-vector of size <code>n1+n2</code>, where n1 (n2) is the size
    /// of t1 (t2).
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_concat")]
    internal IntPtr MkConcat(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_concat");
        var func = Marshal.GetDelegateForFunctionPointer<MkConcatDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExtractDelegate(IntPtr c, uint high, uint low, IntPtr t1);

    /// <summary>
    /// <para>
    /// Extract the bits high down to low from a bit-vector of
    /// size m to yield a new bit-vector of size n, where <code>n = high - low + 1</code>.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_extract")]
    internal IntPtr MkExtract(IntPtr c, uint high, uint low, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_extract");
        var func = Marshal.GetDelegateForFunctionPointer<MkExtractDelegate>(funcPtr);
        return func(c, high, low, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSignExtDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    /// <para>
    /// Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of
    /// size <code>m+i</code>, where m is the size of the given
    /// bit-vector.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_sign_ext")]
    internal IntPtr MkSignExt(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_sign_ext");
        var func = Marshal.GetDelegateForFunctionPointer<MkSignExtDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkZeroExtDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    /// <para>
    /// Extend the given bit-vector with zeros to the (unsigned) equivalent
    /// bit-vector of size <code>m+i</code>, where m is the size of the
    /// given bit-vector.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_zero_ext")]
    internal IntPtr MkZeroExt(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_zero_ext");
        var func = Marshal.GetDelegateForFunctionPointer<MkZeroExtDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRepeatDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    /// <para>
    /// Repeat the given bit-vector up length <code>i</code>.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_repeat")]
    internal IntPtr MkRepeat(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_repeat");
        var func = Marshal.GetDelegateForFunctionPointer<MkRepeatDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBit2boolDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    /// <para>
    /// Extracts the bit at position <code>i</code> of a bit-vector and
    /// yields a boolean.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bit2bool")]
    internal IntPtr MkBit2bool(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bit2bool");
        var func = Marshal.GetDelegateForFunctionPointer<MkBit2boolDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvshlDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Shift left.
    /// </para>
    /// <para>
    /// It is equivalent to multiplication by <code>2^x</code> where x is the value of the
    /// third argument.
    /// </para>
    /// <para>
    /// NB. The semantics of shift operations varies between environments. This
    /// definition does not necessarily capture directly the semantics of the
    /// programming language or assembly architecture you are modeling.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvshl")]
    internal IntPtr MkBvshl(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvshl");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvshlDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvlshrDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Logical shift right.
    /// </para>
    /// <para>
    /// It is equivalent to unsigned division by <code>2^x</code> where x is the
    /// value of the third argument.
    /// </para>
    /// <para>
    /// NB. The semantics of shift operations varies between environments. This
    /// definition does not necessarily capture directly the semantics of the
    /// programming language or assembly architecture you are modeling.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvlshr")]
    internal IntPtr MkBvlshr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvlshr");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvlshrDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvashrDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Arithmetic shift right.
    /// </para>
    /// <para>
    /// It is like logical shift right except that the most significant
    /// bits of the result always copy the most significant bit of the
    /// second argument.
    /// </para>
    /// <para>
    /// The semantics of shift operations varies between environments. This
    /// definition does not necessarily capture directly the semantics of the
    /// programming language or assembly architecture you are modeling.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvashr")]
    internal IntPtr MkBvashr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvashr");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvashrDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRotateLeftDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the left i times.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_rotate_left")]
    internal IntPtr MkRotateLeft(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_rotate_left");
        var func = Marshal.GetDelegateForFunctionPointer<MkRotateLeftDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRotateRightDelegate(IntPtr c, uint i, IntPtr t1);

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the right i times.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_rotate_right")]
    internal IntPtr MkRotateRight(IntPtr c, uint i, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_rotate_right");
        var func = Marshal.GetDelegateForFunctionPointer<MkRotateRightDelegate>(funcPtr);
        return func(c, i, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExtRotateLeftDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the left t2 times.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_ext_rotate_left")]
    internal IntPtr MkExtRotateLeft(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_ext_rotate_left");
        var func = Marshal.GetDelegateForFunctionPointer<MkExtRotateLeftDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkExtRotateRightDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the right t2 times.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_ext_rotate_right")]
    internal IntPtr MkExtRotateRight(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_ext_rotate_right");
        var func = Marshal.GetDelegateForFunctionPointer<MkExtRotateRightDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkInt2bvDelegate(IntPtr c, uint n, IntPtr t1);

    /// <summary>
    /// <para>
    /// Create an n bit bit-vector from the integer argument t1.
    /// </para>
    /// <para>
    /// The resulting bit-vector has n bits, where the i'th bit (counting
    /// from 0 to n-1) is 1 if \c (t1 div 2^i) mod 2 is 1.
    /// </para>
    /// <para>
    /// The node t1 must have integer sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_int2bv")]
    internal IntPtr MkInt2bv(IntPtr c, uint n, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_int2bv");
        var func = Marshal.GetDelegateForFunctionPointer<MkInt2bvDelegate>(funcPtr);
        return func(c, n, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBv2intDelegate(IntPtr c, IntPtr t1, bool isSigned);

    /// <summary>
    /// <para>
    /// Create an integer from the bit-vector argument t1.
    /// If is_signed is false, then the bit-vector t1 is treated as unsigned.
    /// So the result is non-negative
    /// and in the range <code>[0..2^N-1]</code>, where N are the number of bits in t1.
    /// If is_signed is true, t1 is treated as a signed bit-vector.
    /// </para>
    /// <para>
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bv2int")]
    internal IntPtr MkBv2int(IntPtr c, IntPtr t1, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bv2int");
        var func = Marshal.GetDelegateForFunctionPointer<MkBv2intDelegate>(funcPtr);
        return func(c, t1, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvaddNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned);

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise addition
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvadd_no_overflow")]
    internal IntPtr MkBvaddNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvadd_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvaddNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvaddNoUnderflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed addition
    /// of t1 and t2 does not underflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvadd_no_underflow")]
    internal IntPtr MkBvaddNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvadd_no_underflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvaddNoUnderflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsubNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed subtraction
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsub_no_overflow")]
    internal IntPtr MkBvsubNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsub_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsubNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsubNoUnderflowDelegate(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned);

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise subtraction
    /// of t1 and t2 does not underflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsub_no_underflow")]
    internal IntPtr MkBvsubNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsub_no_underflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsubNoUnderflowDelegate>(funcPtr);
        return func(c, t1, t2, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvsdivNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed division
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvsdiv_no_overflow")]
    internal IntPtr MkBvsdivNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvsdiv_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvsdivNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvnegNoOverflowDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// <para>
    /// Check that bit-wise negation does not overflow when
    /// t1 is interpreted as a signed bit-vector.
    /// </para>
    /// <para>
    /// The node t1 must have bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvneg_no_overflow")]
    internal IntPtr MkBvnegNoOverflow(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvneg_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvnegNoOverflowDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvmulNoOverflowDelegate(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned);

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise multiplication
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvmul_no_overflow")]
    internal IntPtr MkBvmulNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvmul_no_overflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvmulNoOverflowDelegate>(funcPtr);
        return func(c, t1, t2, isSigned);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvmulNoUnderflowDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed multiplication
    /// of t1 and t2 does not underflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    [Z3Function("Z3_mk_bvmul_no_underflow")]
    internal IntPtr MkBvmulNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bvmul_no_underflow");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvmulNoUnderflowDelegate>(funcPtr);
        return func(c, t1, t2);
    }

}
