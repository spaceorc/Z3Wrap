// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Arrays
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSelectDelegate(IntPtr c, IntPtr a, IntPtr i);

    /// <summary>
    /// Array read. The argument a is the array and i is the index of the array that gets read. The node a must have an array sort [domain -&gt; range], and i must have the sort domain. The sort of the result is range.
    /// </summary>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkStore"/>
    [Z3Function("Z3_mk_select")]
    internal IntPtr MkSelect(IntPtr c, IntPtr a, IntPtr i)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_select");
        var func = Marshal.GetDelegateForFunctionPointer<MkSelectDelegate>(funcPtr);
        return func(c, a, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSelectNDelegate(IntPtr c, IntPtr a, uint n, IntPtr idxs);

    /// <summary>
    /// n-ary Array read. The argument a is the array and idxs are the indices of the array that gets read.
    /// </summary>
    [Z3Function("Z3_mk_select_n")]
    internal IntPtr MkSelectN(IntPtr c, IntPtr a, uint n, IntPtr idxs)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_select_n");
        var func = Marshal.GetDelegateForFunctionPointer<MkSelectNDelegate>(funcPtr);
        return func(c, a, n, idxs);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkStoreDelegate(IntPtr c, IntPtr a, IntPtr i, IntPtr v);

    /// <summary>
    /// Array update. The node a must have an array sort [domain -&gt; range], i must have sort domain, v must have sort range. The sort of the result is [domain -&gt; range]. The semantics of this function is given by the theory of arrays described in the SMT-LIB standard. See http://smtlib.org for more details. The result of this function is an array that is equal to a (with respect to select) on all indices except for i, where it maps to v (and the select of a with respect to i may be a different value).
    /// </summary>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkSelect"/>
    [Z3Function("Z3_mk_store")]
    internal IntPtr MkStore(IntPtr c, IntPtr a, IntPtr i, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_store");
        var func = Marshal.GetDelegateForFunctionPointer<MkStoreDelegate>(funcPtr);
        return func(c, a, i, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkStoreNDelegate(IntPtr c, IntPtr a, uint n, IntPtr idxs, IntPtr v);

    /// <summary>
    /// n-ary Array update.
    /// </summary>
    [Z3Function("Z3_mk_store_n")]
    internal IntPtr MkStoreN(IntPtr c, IntPtr a, uint n, IntPtr idxs, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_store_n");
        var func = Marshal.GetDelegateForFunctionPointer<MkStoreNDelegate>(funcPtr);
        return func(c, a, n, idxs, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConstArrayDelegate(IntPtr c, IntPtr domain, IntPtr v);

    /// <summary>
    /// Create the constant array. The resulting term is an array, such that a select on an arbitrary index produces the value v.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="domain">domain sort for the array.</param>
    /// <param name="v">value that the array maps to.</param>
    [Z3Function("Z3_mk_const_array")]
    internal IntPtr MkConstArray(IntPtr c, IntPtr domain, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_const_array");
        var func = Marshal.GetDelegateForFunctionPointer<MkConstArrayDelegate>(funcPtr);
        return func(c, domain, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkMapDelegate(IntPtr c, IntPtr f, uint n, IntPtr args);

    /// <summary>
    /// Map f on the argument arrays. The n nodes args must be of array sorts [domain_i -&gt; range_i]. The function declaration f must have type  range_1 .. range_n -&gt; range. v must have sort range. The sort of the result is [domain_i -&gt; range].
    /// </summary>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkStore"/>
    /// <seealso cref="MkSelect"/>
    [Z3Function("Z3_mk_map")]
    internal IntPtr MkMap(IntPtr c, IntPtr f, uint n, IntPtr args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_map");
        var func = Marshal.GetDelegateForFunctionPointer<MkMapDelegate>(funcPtr);
        return func(c, f, n, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkArrayDefaultDelegate(IntPtr c, IntPtr array);

    /// <summary>
    /// Access the array default value. Produces the default range value, for arrays that can be represented as finite maps with a default range value.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="array">array value whose default range value is accessed.</param>
    [Z3Function("Z3_mk_array_default")]
    internal IntPtr MkArrayDefault(IntPtr c, IntPtr array)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_array_default");
        var func = Marshal.GetDelegateForFunctionPointer<MkArrayDefaultDelegate>(funcPtr);
        return func(c, array);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkAsArrayDelegate(IntPtr c, IntPtr f);

    /// <summary>
    /// Create array with the same interpretation as a function. The array satisfies the property (f x) = (select (_ as-array f) x) for every argument x.
    /// </summary>
    [Z3Function("Z3_mk_as_array")]
    internal IntPtr MkAsArray(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_as_array");
        var func = Marshal.GetDelegateForFunctionPointer<MkAsArrayDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSetHasSizeDelegate(IntPtr c, IntPtr set, IntPtr k);

    /// <summary>
    /// Create predicate that holds if Boolean array set has k elements set to true.
    /// </summary>
    [Z3Function("Z3_mk_set_has_size")]
    internal IntPtr MkSetHasSize(IntPtr c, IntPtr set, IntPtr k)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_set_has_size");
        var func = Marshal.GetDelegateForFunctionPointer<MkSetHasSizeDelegate>(funcPtr);
        return func(c, set, k);
    }

}
