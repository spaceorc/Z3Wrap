// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Arrays
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSelectDelegate(IntPtr c, IntPtr a, IntPtr i);

    /// <summary>
    ///  Array read. The argument <c>a</c> is the array and <c>i</c> is the index of the array that gets read. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>a</c> must have an array sort <c>[domain -&gt; range]</c> , and <c>i</c> must have the sort <c>domain</c> . The sort of the result is <c>range</c> .
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkStore"/>
    [Z3Function("Z3_mk_select")]
    internal IntPtr MkSelect(IntPtr c, IntPtr a, IntPtr i)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_select");
        var func = Marshal.GetDelegateForFunctionPointer<MkSelectDelegate>(funcPtr);
        return func(c, a, i);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSelectNDelegate(IntPtr c, IntPtr a, uint n, out IntPtr idxs);

    /// <summary>
    ///  n-ary Array read. The argument <c>a</c> is the array and <c>idxs</c> are the indices of the array that gets read. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="idxs" ctype="Z3_ast const*">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    [Z3Function("Z3_mk_select_n")]
    internal IntPtr MkSelectN(IntPtr c, IntPtr a, uint n, out IntPtr idxs)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_select_n");
        var func = Marshal.GetDelegateForFunctionPointer<MkSelectNDelegate>(funcPtr);
        return func(c, a, n, out idxs);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkStoreDelegate(IntPtr c, IntPtr a, IntPtr i, IntPtr v);

    /// <summary>
    ///  Array update. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="Z3_ast">ast parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>a</c> must have an array sort <c>[domain -&gt; range]</c> , <c>i</c> must have sort <c>domain</c> , <c>v</c> must have sort range. The sort of the result is <c>[domain -&gt; range]</c> . The semantics of this function is given by the theory of arrays described in the SMT-LIB standard. See http://smtlib.org for more details. The result of this function is an array that is equal to <c>a</c> (with respect to <c>select</c> ) on all indices except for <c>i</c> , where it maps to <c>v</c> (and the <c>select</c> of <c>a</c> with respect to <c>i</c> may be a different value).
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkSelect"/>
    [Z3Function("Z3_mk_store")]
    internal IntPtr MkStore(IntPtr c, IntPtr a, IntPtr i, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_store");
        var func = Marshal.GetDelegateForFunctionPointer<MkStoreDelegate>(funcPtr);
        return func(c, a, i, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkStoreNDelegate(IntPtr c, IntPtr a, uint n, out IntPtr idxs, IntPtr v);

    /// <summary>
    ///  n-ary Array update. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="idxs" ctype="Z3_ast const*">ast parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    [Z3Function("Z3_mk_store_n")]
    internal IntPtr MkStoreN(IntPtr c, IntPtr a, uint n, out IntPtr idxs, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_store_n");
        var func = Marshal.GetDelegateForFunctionPointer<MkStoreNDelegate>(funcPtr);
        return func(c, a, n, out idxs, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConstArrayDelegate(IntPtr c, IntPtr domain, IntPtr v);

    /// <summary>
    ///  Create the constant array. 
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="domain" ctype="Z3_sort"> domain sort for the array. </param>
    /// <param name="v" ctype="Z3_ast"> value that the array maps to. </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The resulting term is an array, such that a <c>select</c> on an arbitrary index produces the value <c>v</c> .
    /// </remarks>
    [Z3Function("Z3_mk_const_array")]
    internal IntPtr MkConstArray(IntPtr c, IntPtr domain, IntPtr v)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_const_array");
        var func = Marshal.GetDelegateForFunctionPointer<MkConstArrayDelegate>(funcPtr);
        return func(c, domain, v);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkMapDelegate(IntPtr c, IntPtr f, uint n, out IntPtr args);

    /// <summary>
    ///  Map f on the argument arrays. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const*">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The <c>n</c> nodes <c>args</c> must be of array sorts <c>[domain_i -&gt; range_i]</c> . The function declaration <c>f</c> must have type <c> range_1 .. range_n -&gt; range</c> . <c>v</c> must have sort range. The sort of the result is <c>[domain_i -&gt; range]</c> .
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkStore"/>
    /// <seealso cref="MkSelect"/>
    [Z3Function("Z3_mk_map")]
    internal IntPtr MkMap(IntPtr c, IntPtr f, uint n, out IntPtr args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_map");
        var func = Marshal.GetDelegateForFunctionPointer<MkMapDelegate>(funcPtr);
        return func(c, f, n, out args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkArrayDefaultDelegate(IntPtr c, IntPtr array);

    /// <summary>
    ///  Access the array default value. Produces the default range value, for arrays that can be represented as finite maps with a default range value. 
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="array" ctype="Z3_ast"> array value whose default range value is accessed. </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    [Z3Function("Z3_mk_array_default")]
    internal IntPtr MkArrayDefault(IntPtr c, IntPtr array)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_array_default");
        var func = Marshal.GetDelegateForFunctionPointer<MkArrayDefaultDelegate>(funcPtr);
        return func(c, array);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkAsArrayDelegate(IntPtr c, IntPtr f);

    /// <summary>
    ///  Create array with the same interpretation as a function. The array satisfies the property (f x) = (select (_ as-array f) x) for every argument x. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    [Z3Function("Z3_mk_as_array")]
    internal IntPtr MkAsArray(IntPtr c, IntPtr f)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_as_array");
        var func = Marshal.GetDelegateForFunctionPointer<MkAsArrayDelegate>(funcPtr);
        return func(c, f);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSetHasSizeDelegate(IntPtr c, IntPtr set, IntPtr k);

    /// <summary>
    ///  Create predicate that holds if Boolean array <c>set</c> has <c>k</c> elements set to true. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="set" ctype="Z3_ast">ast parameter</param>
    /// <param name="k" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    [Z3Function("Z3_mk_set_has_size")]
    internal IntPtr MkSetHasSize(IntPtr c, IntPtr set, IntPtr k)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_set_has_size");
        var func = Marshal.GetDelegateForFunctionPointer<MkSetHasSizeDelegate>(funcPtr);
        return func(c, set, k);
    }

}
