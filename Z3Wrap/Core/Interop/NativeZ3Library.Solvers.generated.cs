// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Solvers
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSolverDelegate(IntPtr c);

    /// <summary>
    /// Create a new solver. This solver is a "combined solver" (see combined_solver module) that internally uses a non-incremental (solver1) and an incremental solver (solver2). This combined solver changes its behaviour based on how it is used and how its parameters are set.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <remarks>
    /// User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects. Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
    /// </remarks>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    /// <seealso cref="MkSolverFromTactic"/>
    [Z3Function("Z3_mk_solver")]
    internal IntPtr MkSolver(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_solver");
        var func = Marshal.GetDelegateForFunctionPointer<MkSolverDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSimpleSolverDelegate(IntPtr c);

    /// <summary>
    /// Create a new incremental solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <remarks>
    /// User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects. Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    /// <seealso cref="MkSolverFromTactic"/>
    [Z3Function("Z3_mk_simple_solver")]
    internal IntPtr MkSimpleSolver(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_simple_solver");
        var func = Marshal.GetDelegateForFunctionPointer<MkSimpleSolverDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSolverForLogicDelegate(IntPtr c, IntPtr logic);

    /// <summary>
    /// Create a new solver customized for the given logic. It behaves like #Z3_mk_solver if the logic is unknown or unsupported.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="logic" ctype="Z3_symbol">symbol parameter</param>
    /// <remarks>
    /// User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects. Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverFromTactic"/>
    [Z3Function("Z3_mk_solver_for_logic")]
    internal IntPtr MkSolverForLogic(IntPtr c, IntPtr logic)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_solver_for_logic");
        var func = Marshal.GetDelegateForFunctionPointer<MkSolverForLogicDelegate>(funcPtr);
        return func(c, logic);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSolverFromTacticDelegate(IntPtr c, IntPtr t);

    /// <summary>
    /// Create a new solver that is implemented using the given tactic. The solver supports the commands #Z3_solver_push and #Z3_solver_pop, but it will always solve each #Z3_solver_check from scratch.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_tactic">tactic parameter</param>
    /// <remarks>
    /// User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects. Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    [Z3Function("Z3_mk_solver_from_tactic")]
    internal IntPtr MkSolverFromTactic(IntPtr c, IntPtr t)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_solver_from_tactic");
        var func = Marshal.GetDelegateForFunctionPointer<MkSolverFromTacticDelegate>(funcPtr);
        return func(c, t);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverTranslateDelegate(IntPtr source, IntPtr s, IntPtr target);

    /// <summary>
    /// Copy a solver \c s from the context \c source to the context \c target.
    /// </summary>
    /// <param name="source" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="target" ctype="Z3_context">context parameter</param>
    [Z3Function("Z3_solver_translate")]
    internal IntPtr SolverTranslate(IntPtr source, IntPtr s, IntPtr target)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_translate");
        var func = Marshal.GetDelegateForFunctionPointer<SolverTranslateDelegate>(funcPtr);
        return func(source, s, target);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverImportModelConverterDelegate(IntPtr ctx, IntPtr src, IntPtr dst);

    /// <summary>
    /// Ad-hoc method for importing model conversion from solver.
    /// </summary>
    /// <param name="ctx" ctype="Z3_context">context parameter</param>
    /// <param name="src" ctype="Z3_solver">solver parameter</param>
    /// <param name="dst" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_import_model_converter")]
    internal void SolverImportModelConverter(IntPtr ctx, IntPtr src, IntPtr dst)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_import_model_converter");
        var func = Marshal.GetDelegateForFunctionPointer<SolverImportModelConverterDelegate>(funcPtr);
        func(ctx, src, dst);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetHelpDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return a string describing all solver available parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverGetParamDescrs"/>
    /// <seealso cref="SolverSetParams"/>
    [Z3Function("Z3_solver_get_help")]
    internal IntPtr SolverGetHelp(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_help");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetHelpDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetParamDescrsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the parameter description set for the given solver object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverGetHelp"/>
    /// <seealso cref="SolverSetParams"/>
    [Z3Function("Z3_solver_get_param_descrs")]
    internal IntPtr SolverGetParamDescrs(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_param_descrs");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetParamDescrsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverSetParamsDelegate(IntPtr c, IntPtr s, IntPtr p);

    /// <summary>
    /// Set the given solver using the given parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="p" ctype="Z3_params">params parameter</param>
    /// <seealso cref="SolverGetHelp"/>
    /// <seealso cref="SolverGetParamDescrs"/>
    [Z3Function("Z3_solver_set_params")]
    internal void SolverSetParams(IntPtr c, IntPtr s, IntPtr p)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_set_params");
        var func = Marshal.GetDelegateForFunctionPointer<SolverSetParamsDelegate>(funcPtr);
        func(c, s, p);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverIncRefDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Increment the reference counter of the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_inc_ref")]
    internal void SolverIncRef(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<SolverIncRefDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverDecRefDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Decrement the reference counter of the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_dec_ref")]
    internal void SolverDecRef(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<SolverDecRefDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverInterruptDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Solver local interrupt. Normally you should use Z3_interrupt to cancel solvers because only one solver is enabled concurrently per context. However, per GitHub issue #1006, there are use cases where it is more convenient to cancel a specific solver. Solvers that are not selected for interrupts are left alone.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_interrupt")]
    internal void SolverInterrupt(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_interrupt");
        var func = Marshal.GetDelegateForFunctionPointer<SolverInterruptDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPushDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Create a backtracking point.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverGetNumScopes"/>
    /// <seealso cref="SolverPop"/>
    [Z3Function("Z3_solver_push")]
    internal void SolverPush(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_push");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPushDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPopDelegate(IntPtr c, IntPtr s, uint n);

    /// <summary>
    /// Backtrack \c n backtracking points.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <remarks>
    /// Precondition: n <= Z3_solver_get_num_scopes(c, s)
    /// </remarks>
    /// <seealso cref="SolverGetNumScopes"/>
    /// <seealso cref="SolverPush"/>
    [Z3Function("Z3_solver_pop")]
    internal void SolverPop(IntPtr c, IntPtr s, uint n)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_pop");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPopDelegate>(funcPtr);
        func(c, s, n);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverResetDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Remove all assertions from the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverAssert"/>
    /// <seealso cref="SolverAssertAndTrack"/>
    [Z3Function("Z3_solver_reset")]
    internal void SolverReset(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_reset");
        var func = Marshal.GetDelegateForFunctionPointer<SolverResetDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint SolverGetNumScopesDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the number of backtracking points.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverPush"/>
    /// <seealso cref="SolverPop"/>
    [Z3Function("Z3_solver_get_num_scopes")]
    internal uint SolverGetNumScopes(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_num_scopes");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetNumScopesDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverAssertDelegate(IntPtr c, IntPtr s, IntPtr a);

    /// <summary>
    /// Assert a constraint into the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="SolverAssertAndTrack"/>
    /// <seealso cref="SolverReset"/>
    [Z3Function("Z3_solver_assert")]
    internal void SolverAssert(IntPtr c, IntPtr s, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_assert");
        var func = Marshal.GetDelegateForFunctionPointer<SolverAssertDelegate>(funcPtr);
        func(c, s, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverAssertAndTrackDelegate(IntPtr c, IntPtr s, IntPtr a, IntPtr p);

    /// <summary>
    /// Assert a constraint \c a into the solver, and track it (in the unsat) core using the Boolean constant \c p.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="p" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// Precondition: \c a must be a Boolean expression
    /// Precondition: \c p must be a Boolean constant (aka variable).
    /// </remarks>
    /// <seealso cref="SolverAssert"/>
    /// <seealso cref="SolverReset"/>
    [Z3Function("Z3_solver_assert_and_track")]
    internal void SolverAssertAndTrack(IntPtr c, IntPtr s, IntPtr a, IntPtr p)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_assert_and_track");
        var func = Marshal.GetDelegateForFunctionPointer<SolverAssertAndTrackDelegate>(funcPtr);
        func(c, s, a, p);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverFromFileDelegate(IntPtr c, IntPtr s, IntPtr fileName);

    /// <summary>
    /// load solver assertions from a file.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="fileName" ctype="Z3_string">string parameter</param>
    /// <seealso cref="SolverFromString"/>
    /// <seealso cref="SolverToString"/>
    [Z3Function("Z3_solver_from_file")]
    internal void SolverFromFile(IntPtr c, IntPtr s, IntPtr fileName)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_from_file");
        var func = Marshal.GetDelegateForFunctionPointer<SolverFromFileDelegate>(funcPtr);
        func(c, s, fileName);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverFromStringDelegate(IntPtr c, IntPtr s, IntPtr str);

    /// <summary>
    /// load solver assertions from a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="str" ctype="Z3_string">string parameter</param>
    /// <seealso cref="SolverFromFile"/>
    /// <seealso cref="SolverToString"/>
    [Z3Function("Z3_solver_from_string")]
    internal void SolverFromString(IntPtr c, IntPtr s, IntPtr str)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_from_string");
        var func = Marshal.GetDelegateForFunctionPointer<SolverFromStringDelegate>(funcPtr);
        func(c, s, str);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetAssertionsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the set of asserted formulas on the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_assertions")]
    internal IntPtr SolverGetAssertions(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_assertions");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetAssertionsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetUnitsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the set of units modulo model conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_units")]
    internal IntPtr SolverGetUnits(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_units");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetUnitsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetTrailDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the trail modulo model conversion, in order of decision level The decision level can be retrieved using \c Z3_solver_get_level based on the trail.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_trail")]
    internal IntPtr SolverGetTrail(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_trail");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetTrailDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetNonUnitsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the set of non units in the solver state.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_non_units")]
    internal IntPtr SolverGetNonUnits(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_non_units");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetNonUnitsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverGetLevelsDelegate(IntPtr c, IntPtr s, IntPtr literals, uint sz, uint[] levels);

    /// <summary>
    /// retrieve the decision depth of Boolean literals (variables or their negations). Assumes a check-sat call and no other calls (to extract models) have been invoked.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="literals" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="sz" ctype="unsigned">unsigned parameter</param>
    /// <param name="levels" ctype="unsigned[]">unsigned parameter</param>
    [Z3Function("Z3_solver_get_levels")]
    internal void SolverGetLevels(IntPtr c, IntPtr s, IntPtr literals, uint sz, uint[] levels)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_levels");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetLevelsDelegate>(funcPtr);
        func(c, s, literals, sz, levels);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCongruenceRootDelegate(IntPtr c, IntPtr s, IntPtr a);

    /// <summary>
    /// retrieve the congruence closure root of an expression. The root is retrieved relative to the state where the solver was in when it completed. If it completed during a set of case splits, the congruence roots are relative to these case splits. That is, the congruences are not consequences but they are true under the current state.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_congruence_root")]
    internal IntPtr SolverCongruenceRoot(IntPtr c, IntPtr s, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_congruence_root");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCongruenceRootDelegate>(funcPtr);
        return func(c, s, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCongruenceNextDelegate(IntPtr c, IntPtr s, IntPtr a);

    /// <summary>
    /// retrieve the next expression in the congruence class. The set of congruent siblings form a cyclic list. Repeated calls on the siblings will result in returning to the original expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_congruence_next")]
    internal IntPtr SolverCongruenceNext(IntPtr c, IntPtr s, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_congruence_next");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCongruenceNextDelegate>(funcPtr);
        return func(c, s, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCongruenceExplainDelegate(IntPtr c, IntPtr s, IntPtr a, IntPtr b);

    /// <summary>
    /// retrieve explanation for congruence.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="b" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// Precondition: root(a) = root(b)
    /// </remarks>
    [Z3Function("Z3_solver_congruence_explain")]
    internal IntPtr SolverCongruenceExplain(IntPtr c, IntPtr s, IntPtr a, IntPtr b)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_congruence_explain");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCongruenceExplainDelegate>(funcPtr);
        return func(c, s, a, b);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverSolveForDelegate(IntPtr c, IntPtr s, IntPtr variables, IntPtr terms, IntPtr guards);

    /// <summary>
    /// retrieve a 'solution' for \c variables as defined by equalities in maintained by solvers. At this point, only linear solution are supported. The solution to \c variables may be presented in triangular form, such that variables used in solutions themselves have solutions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="variables" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="terms" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="guards" ctype="Z3_ast_vector">ast_vector parameter</param>
    [Z3Function("Z3_solver_solve_for")]
    internal void SolverSolveFor(IntPtr c, IntPtr s, IntPtr variables, IntPtr terms, IntPtr guards)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_solve_for");
        var func = Marshal.GetDelegateForFunctionPointer<SolverSolveForDelegate>(funcPtr);
        func(c, s, variables, terms, guards);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverRegisterOnClauseDelegate(IntPtr c, IntPtr s, IntPtr userContext, IntPtr onClauseEh);

    /// <summary>
    /// register a callback to that retrieves assumed, inferred and deleted clauses during search.
    /// </summary>
    /// <param name="c" ctype="Z3_context">- context.</param>
    /// <param name="s" ctype="Z3_solver">- solver object.</param>
    /// <param name="userContext" ctype="void*">- a context used to maintain state for callbacks.</param>
    /// <param name="onClauseEh" ctype="Z3_on_clause_eh">- a callback that is invoked by when a clause is</param>
    /// <remarks>
    /// - asserted to the CDCL engine (corresponding to an input clause after pre-processing)
    /// - inferred by CDCL(T) using either a SAT or theory conflict/propagation
    /// - deleted by the CDCL(T) engine
    /// def_API('Z3_solver_register_on_clause', VOID, (_in(CONTEXT), _in(SOLVER), _in(VOID_PTR), _fnptr(Z3_on_clause_eh)))
    /// </remarks>
    [Z3Function("Z3_solver_register_on_clause")]
    internal void SolverRegisterOnClause(IntPtr c, IntPtr s, IntPtr userContext, IntPtr onClauseEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_register_on_clause");
        var func = Marshal.GetDelegateForFunctionPointer<SolverRegisterOnClauseDelegate>(funcPtr);
        func(c, s, userContext, onClauseEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateInitDelegate(IntPtr c, IntPtr s, IntPtr userContext, IntPtr pushEh, IntPtr popEh, IntPtr freshEh);

    /// <summary>
    /// register a user-propagator with the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">- context.</param>
    /// <param name="s" ctype="Z3_solver">- solver object.</param>
    /// <param name="userContext" ctype="void*">- a context used to maintain state for callbacks.</param>
    /// <param name="pushEh" ctype="Z3_push_eh">- a callback invoked when scopes are pushed</param>
    /// <param name="popEh" ctype="Z3_pop_eh">- a callback invoked when scopes are popped</param>
    /// <param name="freshEh" ctype="Z3_fresh_eh">- a solver may spawn new solvers internally. This callback is used to produce a fresh user_context to be associated with fresh solvers.</param>
    [Z3Function("Z3_solver_propagate_init")]
    internal void SolverPropagateInit(IntPtr c, IntPtr s, IntPtr userContext, IntPtr pushEh, IntPtr popEh, IntPtr freshEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_init");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateInitDelegate>(funcPtr);
        func(c, s, userContext, pushEh, popEh, freshEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateFixedDelegate(IntPtr c, IntPtr s, IntPtr fixedEh);

    /// <summary>
    /// register a callback for when an expression is bound to a fixed value. The supported expression types are
    /// - Booleans
    /// - Bit-vectors
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="fixedEh" ctype="Z3_fixed_eh">fixed_eh parameter</param>
    [Z3Function("Z3_solver_propagate_fixed")]
    internal void SolverPropagateFixed(IntPtr c, IntPtr s, IntPtr fixedEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_fixed");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateFixedDelegate>(funcPtr);
        func(c, s, fixedEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateFinalDelegate(IntPtr c, IntPtr s, IntPtr finalEh);

    /// <summary>
    /// register a callback on final check. This provides freedom to the propagator to delay actions or implement a branch-and bound solver. The final check is invoked when all decision variables have been assigned by the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="finalEh" ctype="Z3_final_eh">final_eh parameter</param>
    [Z3Function("Z3_solver_propagate_final")]
    internal void SolverPropagateFinal(IntPtr c, IntPtr s, IntPtr finalEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_final");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateFinalDelegate>(funcPtr);
        func(c, s, finalEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateEqDelegate(IntPtr c, IntPtr s, IntPtr eqEh);

    /// <summary>
    /// register a callback on expression equalities.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="eqEh" ctype="Z3_eq_eh">eq_eh parameter</param>
    [Z3Function("Z3_solver_propagate_eq")]
    internal void SolverPropagateEq(IntPtr c, IntPtr s, IntPtr eqEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_eq");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateEqDelegate>(funcPtr);
        func(c, s, eqEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateDiseqDelegate(IntPtr c, IntPtr s, IntPtr eqEh);

    /// <summary>
    /// register a callback on expression dis-equalities.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="eqEh" ctype="Z3_eq_eh">eq_eh parameter</param>
    [Z3Function("Z3_solver_propagate_diseq")]
    internal void SolverPropagateDiseq(IntPtr c, IntPtr s, IntPtr eqEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_diseq");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateDiseqDelegate>(funcPtr);
        func(c, s, eqEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateCreatedDelegate(IntPtr c, IntPtr s, IntPtr createdEh);

    /// <summary>
    /// register a callback when a new expression with a registered function is used by the solver The registered function appears at the top level and is created using \ref Z3_solver_propagate_declare.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="createdEh" ctype="Z3_created_eh">created_eh parameter</param>
    [Z3Function("Z3_solver_propagate_created")]
    internal void SolverPropagateCreated(IntPtr c, IntPtr s, IntPtr createdEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_created");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateCreatedDelegate>(funcPtr);
        func(c, s, createdEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateDecideDelegate(IntPtr c, IntPtr s, IntPtr decideEh);

    /// <summary>
    /// register a callback when the solver decides to split on a registered expression. The callback may change the arguments by providing other values by calling \ref Z3_solver_next_split
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="decideEh" ctype="Z3_decide_eh">decide_eh parameter</param>
    [Z3Function("Z3_solver_propagate_decide")]
    internal void SolverPropagateDecide(IntPtr c, IntPtr s, IntPtr decideEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_decide");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateDecideDelegate>(funcPtr);
        func(c, s, decideEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateOnBindingDelegate(IntPtr c, IntPtr s, IntPtr onBindingEh);

    /// <summary>
    /// register a callback when the solver instantiates a quantifier. If the callback returns false, the actual instantiation of the quantifier is blocked. This allows the user propagator selectively prioritize instantiations without relying on default or configured weights.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="onBindingEh" ctype="Z3_on_binding_eh">on_binding_eh parameter</param>
    [Z3Function("Z3_solver_propagate_on_binding")]
    internal void SolverPropagateOnBinding(IntPtr c, IntPtr s, IntPtr onBindingEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_on_binding");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateOnBindingDelegate>(funcPtr);
        func(c, s, onBindingEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool SolverNextSplitDelegate(IntPtr c, IntPtr cb, IntPtr t, uint idx, Lbool phase);

    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="cb" ctype="Z3_solver_callback">solver_callback parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <param name="phase" ctype="Z3_lbool">lbool parameter</param>
    [Z3Function("Z3_solver_next_split")]
    internal bool SolverNextSplit(IntPtr c, IntPtr cb, IntPtr t, uint idx, Lbool phase)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_next_split");
        var func = Marshal.GetDelegateForFunctionPointer<SolverNextSplitDelegate>(funcPtr);
        return func(c, cb, t, idx, phase);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverPropagateDeclareDelegate(IntPtr c, IntPtr name, uint n, IntPtr domain, IntPtr range);

    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="name" ctype="Z3_symbol">symbol parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="domain" ctype="Z3_sort*">sort parameter</param>
    /// <param name="range" ctype="Z3_sort">sort parameter</param>
    [Z3Function("Z3_solver_propagate_declare")]
    internal IntPtr SolverPropagateDeclare(IntPtr c, IntPtr name, uint n, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_declare");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateDeclareDelegate>(funcPtr);
        return func(c, name, n, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateRegisterDelegate(IntPtr c, IntPtr s, IntPtr e);

    /// <summary>
    /// register an expression to propagate on with the solver. Only expressions of type Bool and type Bit-Vector can be registered for propagation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="e" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_propagate_register")]
    internal void SolverPropagateRegister(IntPtr c, IntPtr s, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_register");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateRegisterDelegate>(funcPtr);
        func(c, s, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateRegisterCbDelegate(IntPtr c, IntPtr cb, IntPtr e);

    /// <summary>
    /// register an expression to propagate on with the solver. Only expressions of type Bool and type Bit-Vector can be registered for propagation. Unlike \ref Z3_solver_propagate_register, this function takes a solver callback context as argument. It can be invoked during a callback to register new expressions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="cb" ctype="Z3_solver_callback">solver_callback parameter</param>
    /// <param name="e" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_propagate_register_cb")]
    internal void SolverPropagateRegisterCb(IntPtr c, IntPtr cb, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_register_cb");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateRegisterCbDelegate>(funcPtr);
        func(c, cb, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool SolverPropagateConsequenceDelegate(IntPtr c, IntPtr cb, uint numFixed, IntPtr @fixed, uint numEqs, IntPtr eqLhs, IntPtr eqRhs, IntPtr conseq);

    /// <summary>
    /// propagate a consequence based on fixed values and equalities. A client may invoke it during the \c propagate_fixed, \c propagate_eq, \c propagate_diseq, and \c propagate_final callbacks. The callback adds a propagation consequence based on the fixed values passed \c ids and equalities \c eqs based on parameters \c lhs, \c rhs.
    /// </summary>
    /// <param name="c" ctype="Z3_context">- context</param>
    /// <param name="cb" ctype="Z3_solver_callback">- solver callback</param>
    /// <param name="numFixed" ctype="unsigned">- number of fixed terms used as premise to propagation</param>
    /// <param name="fixed" ctype="Z3_ast const*">- array of length \c num_ids containing terms that are fixed in the current scope</param>
    /// <param name="numEqs" ctype="unsigned">- number of equalities used as premise to propagation</param>
    /// <param name="eqLhs" ctype="Z3_ast const*">- left side of equalities</param>
    /// <param name="eqRhs" ctype="Z3_ast const*">- right side of equalities</param>
    /// <param name="conseq" ctype="Z3_ast">- consequence to propagate. It is typically an atomic formula, but it can be an arbitrary formula.</param>
    [Z3Function("Z3_solver_propagate_consequence")]
    internal bool SolverPropagateConsequence(IntPtr c, IntPtr cb, uint numFixed, IntPtr @fixed, uint numEqs, IntPtr eqLhs, IntPtr eqRhs, IntPtr conseq)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_consequence");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateConsequenceDelegate>(funcPtr);
        return func(c, cb, numFixed, @fixed, numEqs, eqLhs, eqRhs, conseq);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverSetInitialValueDelegate(IntPtr c, IntPtr s, IntPtr v, IntPtr val);

    /// <summary>
    /// provide an initialization hint to the solver. The initialization hint is used to calibrate an initial value of the expression that represents a variable. If the variable is Boolean, the initial phase is set according to \c value. If the variable is an integer or real, the initial Simplex tableau is recalibrated to attempt to follow the value assignment.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="val" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_set_initial_value")]
    internal void SolverSetInitialValue(IntPtr c, IntPtr s, IntPtr v, IntPtr val)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_set_initial_value");
        var func = Marshal.GetDelegateForFunctionPointer<SolverSetInitialValueDelegate>(funcPtr);
        func(c, s, v, val);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool SolverCheckDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Check whether the assertions in a given solver are consistent or not.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverCheckAssumptions"/>
    [Z3Function("Z3_solver_check")]
    internal Lbool SolverCheck(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_check");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCheckDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool SolverCheckAssumptionsDelegate(IntPtr c, IntPtr s, uint numAssumptions, IntPtr[] assumptions);

    /// <summary>
    /// Check whether the assertions in the given solver and optional assumptions are consistent or not.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="numAssumptions" ctype="unsigned">unsigned parameter</param>
    /// <param name="assumptions" ctype="Z3_ast const[]">ast parameter</param>
    /// <seealso cref="SolverCheck"/>
    [Z3Function("Z3_solver_check_assumptions")]
    internal Lbool SolverCheckAssumptions(IntPtr c, IntPtr s, uint numAssumptions, IntPtr[] assumptions)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_check_assumptions");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCheckAssumptionsDelegate>(funcPtr);
        return func(c, s, numAssumptions, assumptions);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool GetImpliedEqualitiesDelegate(IntPtr c, IntPtr s, uint numTerms, IntPtr[] terms, uint[] classIds);

    /// <summary>
    /// Retrieve congruence class representatives for terms.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="numTerms" ctype="unsigned">unsigned parameter</param>
    /// <param name="terms" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="classIds" ctype="unsigned[]">unsigned parameter</param>
    [Z3Function("Z3_get_implied_equalities")]
    internal Lbool GetImpliedEqualities(IntPtr c, IntPtr s, uint numTerms, IntPtr[] terms, uint[] classIds)
    {
        var funcPtr = GetFunctionPointer("Z3_get_implied_equalities");
        var func = Marshal.GetDelegateForFunctionPointer<GetImpliedEqualitiesDelegate>(funcPtr);
        return func(c, s, numTerms, terms, classIds);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool SolverGetConsequencesDelegate(IntPtr c, IntPtr s, IntPtr assumptions, IntPtr variables, IntPtr consequences);

    /// <summary>
    /// retrieve consequences from solver that determine values of the supplied function symbols.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="assumptions" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="variables" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="consequences" ctype="Z3_ast_vector">ast_vector parameter</param>
    [Z3Function("Z3_solver_get_consequences")]
    internal Lbool SolverGetConsequences(IntPtr c, IntPtr s, IntPtr assumptions, IntPtr variables, IntPtr consequences)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_consequences");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetConsequencesDelegate>(funcPtr);
        return func(c, s, assumptions, variables, consequences);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCubeDelegate(IntPtr c, IntPtr s, IntPtr vars, uint backtrackLevel);

    /// <summary>
    /// extract a next cube for a solver. The last cube is the constant \c true or \c false. The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="vars" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="backtrackLevel" ctype="unsigned">unsigned parameter</param>
    [Z3Function("Z3_solver_cube")]
    internal IntPtr SolverCube(IntPtr c, IntPtr s, IntPtr vars, uint backtrackLevel)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_cube");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCubeDelegate>(funcPtr);
        return func(c, s, vars, backtrackLevel);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetModelDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Retrieve the model for the last #Z3_solver_check or #Z3_solver_check_assumptions
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_model")]
    internal IntPtr SolverGetModel(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_model");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetModelDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetProofDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Retrieve the proof for the last #Z3_solver_check or #Z3_solver_check_assumptions
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_proof")]
    internal IntPtr SolverGetProof(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_proof");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetProofDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetUnsatCoreDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Retrieve the unsat core for the last #Z3_solver_check_assumptions The unsat core is a subset of the assumptions \c a.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_unsat_core")]
    internal IntPtr SolverGetUnsatCore(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_unsat_core");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetUnsatCoreDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetReasonUnknownDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return a brief justification for an "unknown" result (i.e., \c Z3_L_UNDEF) for the commands #Z3_solver_check and #Z3_solver_check_assumptions
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_reason_unknown")]
    internal IntPtr SolverGetReasonUnknown(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_reason_unknown");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetReasonUnknownDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetStatisticsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return statistics for the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <remarks>
    /// User must use #Z3_stats_inc_ref and #Z3_stats_dec_ref to manage Z3_stats objects.
    /// </remarks>
    [Z3Function("Z3_solver_get_statistics")]
    internal IntPtr SolverGetStatistics(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_statistics");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetStatisticsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverToStringDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Convert a solver into a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverFromFile"/>
    /// <seealso cref="SolverFromString"/>
    [Z3Function("Z3_solver_to_string")]
    internal IntPtr SolverToString(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<SolverToStringDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverToDimacsStringDelegate(IntPtr c, IntPtr s, bool includeNames);

    /// <summary>
    /// Convert a solver into a DIMACS formatted string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="includeNames" ctype="bool">bool parameter</param>
    /// <seealso cref="GoalToDiamcsString for requirements."/>
    [Z3Function("Z3_solver_to_dimacs_string")]
    internal IntPtr SolverToDimacsString(IntPtr c, IntPtr s, bool includeNames)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_to_dimacs_string");
        var func = Marshal.GetDelegateForFunctionPointer<SolverToDimacsStringDelegate>(funcPtr);
        return func(c, s, includeNames);
    }

}
