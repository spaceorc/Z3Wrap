// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Solvers
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSolverDelegate(IntPtr c);

    /// <summary>
    /// <para>
    /// Create a new solver. This solver is a "combined solver" (see
    /// combined_solver module) that internally uses a non-incremental (solver1) and an
    /// incremental solver (solver2). This combined solver changes its behaviour based
    /// on how it is used and how its parameters are set.
    /// </para>
    /// <para>
    /// If the solver is used in a non incremental way (i.e. no calls to
    /// <see cref="SolverPush"/>() or <see cref="SolverPop"/>(), and no calls to
    /// <see cref="SolverAssert"/>() or <see cref="SolverAssertAndTrack"/>() after checking
    /// satisfiability without an intervening <see cref="SolverReset"/>()) then solver1
    /// will be used. This solver will apply Z3's "default" tactic.
    /// </para>
    /// <para>
    /// The "default" tactic will attempt to probe the logic used by the
    /// assertions and will apply a specialized tactic if one is supported.
    /// Otherwise the general `(and-then simplify smt)` tactic will be used.
    /// </para>
    /// <para>
    /// If the solver is used in an incremental way then the combined solver
    /// will switch to using solver2 (which behaves similarly to the general
    /// "smt" tactic).
    /// </para>
    /// <para>
    /// Note however it is possible to set the `solver2_timeout`,
    /// `solver2_unknown`, and `ignore_solver1` parameters of the combined
    /// solver to change its behaviour.
    /// </para>
    /// <para>
    /// The function <see cref="SolverGetModel"/> retrieves a model if the
    /// assertions is satisfiable (i.e., the result is \c
    /// Z3_L_TRUE) and model construction is enabled.
    /// The function <see cref="SolverGetModel"/> can also be used even
    /// if the result is Z3_L_UNDEF, but the returned model
    /// is not guaranteed to satisfy quantified assertions.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <remarks>
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects.
    /// Even if the context was created using <see cref="MkContext"/> instead of <see cref="MkContextRc"/>.
    /// </remarks>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    /// <seealso cref="MkSolverFromTactic"/>
    [Z3Function("Z3_mk_solver")]
    internal IntPtr MkSolver(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_solver");
        var func = Marshal.GetDelegateForFunctionPointer<MkSolverDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSimpleSolverDelegate(IntPtr c);

    /// <summary>
    /// <para>
    /// Create a new incremental solver.
    /// </para>
    /// <para>
    /// This is equivalent to applying the "smt" tactic.
    /// </para>
    /// <para>
    /// Unlike <see cref="MkSolver"/>() this solver
    /// <list type="bullet">
    /// <item><description>Does not attempt to apply any logic specific tactics.</description></item>
    /// <item><description>Does not change its behaviour based on whether it used incrementally/non-incrementally.</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// Note that these differences can result in very different performance
    /// compared to <see cref="MkSolver"/>().
    /// </para>
    /// <para>
    /// The function <see cref="SolverGetModel"/> retrieves a model if the
    /// assertions is satisfiable (i.e., the result is \c
    /// Z3_L_TRUE) and model construction is enabled.
    /// The function <see cref="SolverGetModel"/> can also be used even
    /// if the result is Z3_L_UNDEF, but the returned model
    /// is not guaranteed to satisfy quantified assertions.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <remarks>
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects.
    /// Even if the context was created using <see cref="MkContext"/> instead of <see cref="MkContextRc"/>.
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    /// <seealso cref="MkSolverFromTactic"/>
    [Z3Function("Z3_mk_simple_solver")]
    internal IntPtr MkSimpleSolver(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_simple_solver");
        var func = Marshal.GetDelegateForFunctionPointer<MkSimpleSolverDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSolverForLogicDelegate(IntPtr c, IntPtr logic);

    /// <summary>
    /// Create a new solver customized for the given logic.
    /// It behaves like <see cref="MkSolver"/> if the logic is unknown or unsupported.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="logic" ctype="Z3_symbol">symbol parameter</param>
    /// <remarks>
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects.
    /// Even if the context was created using <see cref="MkContext"/> instead of <see cref="MkContextRc"/>.
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverFromTactic"/>
    [Z3Function("Z3_mk_solver_for_logic")]
    internal IntPtr MkSolverForLogic(IntPtr c, IntPtr logic)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_solver_for_logic");
        var func = Marshal.GetDelegateForFunctionPointer<MkSolverForLogicDelegate>(funcPtr);
        return func(c, logic);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSolverFromTacticDelegate(IntPtr c, IntPtr t);

    /// <summary>
    /// Create a new solver that is implemented using the given tactic.
    /// The solver supports the commands <see cref="SolverPush"/> and <see cref="SolverPop"/>, but it
    /// will always solve each <see cref="SolverCheck"/> from scratch.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_tactic">tactic parameter</param>
    /// <remarks>
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects.
    /// Even if the context was created using <see cref="MkContext"/> instead of <see cref="MkContextRc"/>.
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    [Z3Function("Z3_mk_solver_from_tactic")]
    internal IntPtr MkSolverFromTactic(IntPtr c, IntPtr t)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_solver_from_tactic");
        var func = Marshal.GetDelegateForFunctionPointer<MkSolverFromTacticDelegate>(funcPtr);
        return func(c, t);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverTranslateDelegate(IntPtr source, IntPtr s, IntPtr target);

    /// <summary>
    /// Copy a solver s from the context source to the context target.
    /// </summary>
    /// <param name="source" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="target" ctype="Z3_context">context parameter</param>
    [Z3Function("Z3_solver_translate")]
    internal IntPtr SolverTranslate(IntPtr source, IntPtr s, IntPtr target)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_translate");
        var func = Marshal.GetDelegateForFunctionPointer<SolverTranslateDelegate>(funcPtr);
        return func(source, s, target);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverImportModelConverterDelegate(IntPtr ctx, IntPtr src, IntPtr dst);

    /// <summary>
    /// <para>
    /// Ad-hoc method for importing model conversion from solver.
    /// </para>
    /// <para>
    /// This method is used for scenarios where src has been used to solve a set
    /// of formulas and was interrupted. The dst solver may be a strengthening of src
    /// obtained from cubing (assigning a subset of literals or adding constraints over the
    /// assertions available in src). If dst ends up being satisfiable, the model for dst
    /// may not correspond to a model of the original formula due to inprocessing in src.
    /// This method is used to take the side-effect of inprocessing into account when returning
    /// a model for dst.
    /// </para>
    /// </summary>
    /// <param name="ctx" ctype="Z3_context">context parameter</param>
    /// <param name="src" ctype="Z3_solver">solver parameter</param>
    /// <param name="dst" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_import_model_converter")]
    internal void SolverImportModelConverter(IntPtr ctx, IntPtr src, IntPtr dst)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_import_model_converter");
        var func = Marshal.GetDelegateForFunctionPointer<SolverImportModelConverterDelegate>(funcPtr);
        func(ctx, src, dst);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetHelpDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return a string describing all solver available parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverGetParamDescrs"/>
    /// <seealso cref="SolverSetParams"/>
    [Z3Function("Z3_solver_get_help")]
    internal IntPtr SolverGetHelp(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_help");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetHelpDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetParamDescrsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the parameter description set for the given solver object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverGetHelp"/>
    /// <seealso cref="SolverSetParams"/>
    [Z3Function("Z3_solver_get_param_descrs")]
    internal IntPtr SolverGetParamDescrs(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_param_descrs");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetParamDescrsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverSetParamsDelegate(IntPtr c, IntPtr s, IntPtr p);

    /// <summary>
    /// Set the given solver using the given parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="p" ctype="Z3_params">params parameter</param>
    /// <seealso cref="SolverGetHelp"/>
    /// <seealso cref="SolverGetParamDescrs"/>
    [Z3Function("Z3_solver_set_params")]
    internal void SolverSetParams(IntPtr c, IntPtr s, IntPtr p)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_set_params");
        var func = Marshal.GetDelegateForFunctionPointer<SolverSetParamsDelegate>(funcPtr);
        func(c, s, p);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverIncRefDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Increment the reference counter of the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_inc_ref")]
    internal void SolverIncRef(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_inc_ref");
        var func = Marshal.GetDelegateForFunctionPointer<SolverIncRefDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverDecRefDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Decrement the reference counter of the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_dec_ref")]
    internal void SolverDecRef(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_dec_ref");
        var func = Marshal.GetDelegateForFunctionPointer<SolverDecRefDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverInterruptDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Solver local interrupt.
    /// Normally you should use Z3_interrupt to cancel solvers because only
    /// one solver is enabled concurrently per context.
    /// However, per GitHub issue #1006, there are use cases where
    /// it is more convenient to cancel a specific solver. Solvers
    /// that are not selected for interrupts are left alone.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_interrupt")]
    internal void SolverInterrupt(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_interrupt");
        var func = Marshal.GetDelegateForFunctionPointer<SolverInterruptDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPushDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// <para>
    /// Create a backtracking point.
    /// </para>
    /// <para>
    /// The solver contains a stack of assertions.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverGetNumScopes"/>
    /// <seealso cref="SolverPop"/>
    [Z3Function("Z3_solver_push")]
    internal void SolverPush(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_push");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPushDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPopDelegate(IntPtr c, IntPtr s, uint n);

    /// <summary>
    /// Backtrack n backtracking points.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <remarks>
    /// Precondition: n &lt;= Z3_solver_get_num_scopes(c, s)
    /// </remarks>
    /// <seealso cref="SolverGetNumScopes"/>
    /// <seealso cref="SolverPush"/>
    [Z3Function("Z3_solver_pop")]
    internal void SolverPop(IntPtr c, IntPtr s, uint n)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_pop");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPopDelegate>(funcPtr);
        func(c, s, n);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverResetDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Remove all assertions from the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverAssert"/>
    /// <seealso cref="SolverAssertAndTrack"/>
    [Z3Function("Z3_solver_reset")]
    internal void SolverReset(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_reset");
        var func = Marshal.GetDelegateForFunctionPointer<SolverResetDelegate>(funcPtr);
        func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint SolverGetNumScopesDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the number of backtracking points.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverPush"/>
    /// <seealso cref="SolverPop"/>
    [Z3Function("Z3_solver_get_num_scopes")]
    internal uint SolverGetNumScopes(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_num_scopes");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetNumScopesDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverAssertDelegate(IntPtr c, IntPtr s, IntPtr a);

    /// <summary>
    /// <para>
    /// Assert a constraint into the solver.
    /// </para>
    /// <para>
    /// The functions <see cref="SolverCheck"/> and <see cref="SolverCheckAssumptions"/> should be
    /// used to check whether the logical context is consistent or not.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="SolverAssertAndTrack"/>
    /// <seealso cref="SolverReset"/>
    [Z3Function("Z3_solver_assert")]
    internal void SolverAssert(IntPtr c, IntPtr s, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_assert");
        var func = Marshal.GetDelegateForFunctionPointer<SolverAssertDelegate>(funcPtr);
        func(c, s, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverAssertAndTrackDelegate(IntPtr c, IntPtr s, IntPtr a, IntPtr p);

    /// <summary>
    /// <para>
    /// Assert a constraint a into the solver, and track it (in the unsat) core using
    /// the Boolean constant p.
    /// </para>
    /// <para>
    /// This API is an alternative to <see cref="SolverCheckAssumptions"/> for extracting unsat cores.
    /// Both APIs can be used in the same solver. The unsat core will contain a combination
    /// of the Boolean variables provided using Z3_solver_assert_and_track and the Boolean literals
    /// provided using <see cref="SolverCheckAssumptions"/>.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="p" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// Precondition: a must be a Boolean expression
    /// Precondition: p must be a Boolean constant (aka variable).
    /// </remarks>
    /// <seealso cref="SolverAssert"/>
    /// <seealso cref="SolverReset"/>
    [Z3Function("Z3_solver_assert_and_track")]
    internal void SolverAssertAndTrack(IntPtr c, IntPtr s, IntPtr a, IntPtr p)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_assert_and_track");
        var func = Marshal.GetDelegateForFunctionPointer<SolverAssertAndTrackDelegate>(funcPtr);
        func(c, s, a, p);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverFromFileDelegate(IntPtr c, IntPtr s, IntPtr fileName);

    /// <summary>
    /// load solver assertions from a file.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="fileName" ctype="Z3_string">string parameter</param>
    /// <seealso cref="SolverFromString"/>
    /// <seealso cref="SolverToString"/>
    [Z3Function("Z3_solver_from_file")]
    internal void SolverFromFile(IntPtr c, IntPtr s, IntPtr fileName)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_from_file");
        var func = Marshal.GetDelegateForFunctionPointer<SolverFromFileDelegate>(funcPtr);
        func(c, s, fileName);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverFromStringDelegate(IntPtr c, IntPtr s, IntPtr str);

    /// <summary>
    /// load solver assertions from a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="str" ctype="Z3_string">string parameter</param>
    /// <seealso cref="SolverFromFile"/>
    /// <seealso cref="SolverToString"/>
    [Z3Function("Z3_solver_from_string")]
    internal void SolverFromString(IntPtr c, IntPtr s, IntPtr str)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_from_string");
        var func = Marshal.GetDelegateForFunctionPointer<SolverFromStringDelegate>(funcPtr);
        func(c, s, str);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetAssertionsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the set of asserted formulas on the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_assertions")]
    internal IntPtr SolverGetAssertions(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_assertions");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetAssertionsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetUnitsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the set of units modulo model conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_units")]
    internal IntPtr SolverGetUnits(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_units");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetUnitsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetTrailDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the trail modulo model conversion, in order of decision level
    /// The decision level can be retrieved using Z3_solver_get_level based on the trail.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_trail")]
    internal IntPtr SolverGetTrail(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_trail");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetTrailDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetNonUnitsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return the set of non units in the solver state.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_non_units")]
    internal IntPtr SolverGetNonUnits(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_non_units");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetNonUnitsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverGetLevelsDelegate(IntPtr c, IntPtr s, IntPtr literals, uint sz, uint[] levels);

    /// <summary>
    /// retrieve the decision depth of Boolean literals (variables or their negations).
    /// Assumes a check-sat call and no other calls (to extract models) have been invoked.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="literals" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="sz" ctype="unsigned">unsigned parameter</param>
    /// <param name="levels" ctype="unsigned[]">unsigned parameter</param>
    [Z3Function("Z3_solver_get_levels")]
    internal void SolverGetLevels(IntPtr c, IntPtr s, IntPtr literals, uint sz, uint[] levels)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_levels");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetLevelsDelegate>(funcPtr);
        func(c, s, literals, sz, levels);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCongruenceRootDelegate(IntPtr c, IntPtr s, IntPtr a);

    /// <summary>
    /// retrieve the congruence closure root of an expression.
    /// The root is retrieved relative to the state where the solver was in when it completed.
    /// If it completed during a set of case splits, the congruence roots are relative to these case splits.
    /// That is, the congruences are not consequences but they are true under the current state.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_congruence_root")]
    internal IntPtr SolverCongruenceRoot(IntPtr c, IntPtr s, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_congruence_root");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCongruenceRootDelegate>(funcPtr);
        return func(c, s, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCongruenceNextDelegate(IntPtr c, IntPtr s, IntPtr a);

    /// <summary>
    /// retrieve the next expression in the congruence class. The set of congruent siblings form a cyclic list.
    /// Repeated calls on the siblings will result in returning to the original expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_congruence_next")]
    internal IntPtr SolverCongruenceNext(IntPtr c, IntPtr s, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_congruence_next");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCongruenceNextDelegate>(funcPtr);
        return func(c, s, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCongruenceExplainDelegate(IntPtr c, IntPtr s, IntPtr a, IntPtr b);

    /// <summary>
    /// retrieve explanation for congruence.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="b" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// Precondition: root(a) = root(b)
    /// </remarks>
    [Z3Function("Z3_solver_congruence_explain")]
    internal IntPtr SolverCongruenceExplain(IntPtr c, IntPtr s, IntPtr a, IntPtr b)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_congruence_explain");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCongruenceExplainDelegate>(funcPtr);
        return func(c, s, a, b);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverSolveForDelegate(IntPtr c, IntPtr s, IntPtr variables, IntPtr terms, IntPtr guards);

    /// <summary>
    /// retrieve a 'solution' for variables as defined by equalities in maintained by solvers.
    /// At this point, only linear solution are supported.
    /// The solution to variables may be presented in triangular form, such that
    /// variables used in solutions themselves have solutions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="variables" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="terms" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="guards" ctype="Z3_ast_vector">ast_vector parameter</param>
    [Z3Function("Z3_solver_solve_for")]
    internal void SolverSolveFor(IntPtr c, IntPtr s, IntPtr variables, IntPtr terms, IntPtr guards)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_solve_for");
        var func = Marshal.GetDelegateForFunctionPointer<SolverSolveForDelegate>(funcPtr);
        func(c, s, variables, terms, guards);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverRegisterOnClauseDelegate(IntPtr c, IntPtr s, IntPtr userContext, IntPtr onClauseEh);

    /// <summary>
    /// register a callback to that retrieves assumed, inferred and deleted clauses during search.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context.</param>
    /// <param name="s" ctype="Z3_solver">solver object.</param>
    /// <param name="userContext" ctype="void*">a context used to maintain state for callbacks.</param>
    /// <param name="onClauseEh" ctype="Z3_on_clause_eh">
    /// a callback that is invoked by when a clause is
    /// <list type="bullet">
    /// <item><description>asserted to the CDCL engine (corresponding to an input clause after pre-processing)</description></item>
    /// <item><description>inferred by CDCL(T) using either a SAT or theory conflict/propagation</description></item>
    /// <item><description>deleted by the CDCL(T) engine</description></item>
    /// </list>
    /// </param>
    [Z3Function("Z3_solver_register_on_clause")]
    internal void SolverRegisterOnClause(IntPtr c, IntPtr s, IntPtr userContext, IntPtr onClauseEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_register_on_clause");
        var func = Marshal.GetDelegateForFunctionPointer<SolverRegisterOnClauseDelegate>(funcPtr);
        func(c, s, userContext, onClauseEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateInitDelegate(IntPtr c, IntPtr s, IntPtr userContext, IntPtr pushEh, IntPtr popEh, IntPtr freshEh);

    /// <summary>
    /// register a user-propagator with the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context.</param>
    /// <param name="s" ctype="Z3_solver">solver object.</param>
    /// <param name="userContext" ctype="void*">a context used to maintain state for callbacks.</param>
    /// <param name="pushEh" ctype="Z3_push_eh">a callback invoked when scopes are pushed</param>
    /// <param name="popEh" ctype="Z3_pop_eh">a callback invoked when scopes are popped</param>
    /// <param name="freshEh" ctype="Z3_fresh_eh">a solver may spawn new solvers internally. This callback is used to produce a fresh user_context to be associated with fresh solvers.</param>
    [Z3Function("Z3_solver_propagate_init")]
    internal void SolverPropagateInit(IntPtr c, IntPtr s, IntPtr userContext, IntPtr pushEh, IntPtr popEh, IntPtr freshEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_init");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateInitDelegate>(funcPtr);
        func(c, s, userContext, pushEh, popEh, freshEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateFixedDelegate(IntPtr c, IntPtr s, IntPtr fixedEh);

    /// <summary>
    /// register a callback for when an expression is bound to a fixed value.
    /// The supported expression types are
    /// <list type="bullet">
    /// <item><description>Booleans</description></item>
    /// <item><description>Bit-vectors</description></item>
    /// </list>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="fixedEh" ctype="Z3_fixed_eh">fixed_eh parameter</param>
    [Z3Function("Z3_solver_propagate_fixed")]
    internal void SolverPropagateFixed(IntPtr c, IntPtr s, IntPtr fixedEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_fixed");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateFixedDelegate>(funcPtr);
        func(c, s, fixedEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateFinalDelegate(IntPtr c, IntPtr s, IntPtr finalEh);

    /// <summary>
    /// <para>
    /// register a callback on final check.
    /// This provides freedom to the propagator to delay actions or implement a branch-and bound solver.
    /// The final check is invoked when all decision variables have been assigned by the solver.
    /// </para>
    /// <para>
    /// The final_eh callback takes as argument the original user_context that was used
    /// when calling Z3_solver_propagate_init, and it takes a callback context with the
    /// opaque type Z3_solver_callback.
    /// The callback context is passed as argument to invoke the Z3_solver_propagate_consequence function.
    /// The callback context can only be accessed (for propagation and for dynamically registering expressions) within a callback.
    /// If the callback context gets used for propagation or conflicts, those propagations take effect and
    /// may trigger new decision variables to be set.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="finalEh" ctype="Z3_final_eh">final_eh parameter</param>
    [Z3Function("Z3_solver_propagate_final")]
    internal void SolverPropagateFinal(IntPtr c, IntPtr s, IntPtr finalEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_final");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateFinalDelegate>(funcPtr);
        func(c, s, finalEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateEqDelegate(IntPtr c, IntPtr s, IntPtr eqEh);

    /// <summary>
    /// register a callback on expression equalities.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="eqEh" ctype="Z3_eq_eh">eq_eh parameter</param>
    [Z3Function("Z3_solver_propagate_eq")]
    internal void SolverPropagateEq(IntPtr c, IntPtr s, IntPtr eqEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_eq");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateEqDelegate>(funcPtr);
        func(c, s, eqEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateDiseqDelegate(IntPtr c, IntPtr s, IntPtr eqEh);

    /// <summary>
    /// register a callback on expression dis-equalities.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="eqEh" ctype="Z3_eq_eh">eq_eh parameter</param>
    [Z3Function("Z3_solver_propagate_diseq")]
    internal void SolverPropagateDiseq(IntPtr c, IntPtr s, IntPtr eqEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_diseq");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateDiseqDelegate>(funcPtr);
        func(c, s, eqEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateCreatedDelegate(IntPtr c, IntPtr s, IntPtr createdEh);

    /// <summary>
    /// register a callback when a new expression with a registered function is used by the solver
    /// The registered function appears at the top level and is created using \ref Z3_solver_propagate_declare.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="createdEh" ctype="Z3_created_eh">created_eh parameter</param>
    [Z3Function("Z3_solver_propagate_created")]
    internal void SolverPropagateCreated(IntPtr c, IntPtr s, IntPtr createdEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_created");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateCreatedDelegate>(funcPtr);
        func(c, s, createdEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateDecideDelegate(IntPtr c, IntPtr s, IntPtr decideEh);

    /// <summary>
    /// register a callback when the solver decides to split on a registered expression.
    /// The callback may change the arguments by providing other values by calling \ref Z3_solver_next_split
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="decideEh" ctype="Z3_decide_eh">decide_eh parameter</param>
    [Z3Function("Z3_solver_propagate_decide")]
    internal void SolverPropagateDecide(IntPtr c, IntPtr s, IntPtr decideEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_decide");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateDecideDelegate>(funcPtr);
        func(c, s, decideEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateOnBindingDelegate(IntPtr c, IntPtr s, IntPtr onBindingEh);

    /// <summary>
    /// register a callback when the solver instantiates a quantifier.
    /// If the callback returns false, the actual instantiation of the quantifier is blocked.
    /// This allows the user propagator selectively prioritize instantiations without relying on default
    /// or configured weights.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="onBindingEh" ctype="Z3_on_binding_eh">on_binding_eh parameter</param>
    [Z3Function("Z3_solver_propagate_on_binding")]
    internal void SolverPropagateOnBinding(IntPtr c, IntPtr s, IntPtr onBindingEh)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_on_binding");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateOnBindingDelegate>(funcPtr);
        func(c, s, onBindingEh);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool SolverNextSplitDelegate(IntPtr c, IntPtr cb, IntPtr t, uint idx, Lbool phase);

    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="cb" ctype="Z3_solver_callback">solver_callback parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <param name="phase" ctype="Z3_lbool">lbool parameter</param>
    [Z3Function("Z3_solver_next_split")]
    internal bool SolverNextSplit(IntPtr c, IntPtr cb, IntPtr t, uint idx, Lbool phase)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_next_split");
        var func = Marshal.GetDelegateForFunctionPointer<SolverNextSplitDelegate>(funcPtr);
        return func(c, cb, t, idx, phase);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverPropagateDeclareDelegate(IntPtr c, IntPtr name, uint n, IntPtr domain, IntPtr range);

    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="name" ctype="Z3_symbol">symbol parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="domain" ctype="Z3_sort*">sort parameter</param>
    /// <param name="range" ctype="Z3_sort">sort parameter</param>
    [Z3Function("Z3_solver_propagate_declare")]
    internal IntPtr SolverPropagateDeclare(IntPtr c, IntPtr name, uint n, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_declare");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateDeclareDelegate>(funcPtr);
        return func(c, name, n, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateRegisterDelegate(IntPtr c, IntPtr s, IntPtr e);

    /// <summary>
    /// register an expression to propagate on with the solver.
    /// Only expressions of type Bool and type Bit-Vector can be registered for propagation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="e" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_propagate_register")]
    internal void SolverPropagateRegister(IntPtr c, IntPtr s, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_register");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateRegisterDelegate>(funcPtr);
        func(c, s, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverPropagateRegisterCbDelegate(IntPtr c, IntPtr cb, IntPtr e);

    /// <summary>
    /// register an expression to propagate on with the solver.
    /// Only expressions of type Bool and type Bit-Vector can be registered for propagation.
    /// Unlike \ref Z3_solver_propagate_register, this function takes a solver callback context
    /// as argument. It can be invoked during a callback to register new expressions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="cb" ctype="Z3_solver_callback">solver_callback parameter</param>
    /// <param name="e" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_propagate_register_cb")]
    internal void SolverPropagateRegisterCb(IntPtr c, IntPtr cb, IntPtr e)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_register_cb");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateRegisterCbDelegate>(funcPtr);
        func(c, cb, e);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate bool SolverPropagateConsequenceDelegate(IntPtr c, IntPtr cb, uint numFixed, IntPtr @fixed, uint numEqs, IntPtr eqLhs, IntPtr eqRhs, IntPtr conseq);

    /// <summary>
    /// <para>
    /// propagate a consequence based on fixed values and equalities.
    /// A client may invoke it during the propagate_fixed, propagate_eq, propagate_diseq, and propagate_final callbacks.
    /// The callback adds a propagation consequence based on the fixed values passed ids and equalities eqs based on parameters lhs, rhs.
    /// </para>
    /// <para>
    /// The solver might discard the propagation in case it is true in the current state.
    /// The function returns false in this case; otw. the function returns true.
    /// At least one propagation in the final callback has to return true in order to
    /// prevent the solver from finishing.
    /// </para>
    /// <para>
    /// Assume the callback has the signature: propagate_consequence_eh(context, solver_cb, num_ids, ids, num_eqs, lhs, rhs, consequence).
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context</param>
    /// <param name="cb" ctype="Z3_solver_callback">solver callback</param>
    /// <param name="numFixed" ctype="unsigned">number of fixed terms used as premise to propagation</param>
    /// <param name="fixed" ctype="Z3_ast const*">array of length num_ids containing terms that are fixed in the current scope</param>
    /// <param name="numEqs" ctype="unsigned">number of equalities used as premise to propagation</param>
    /// <param name="eqLhs" ctype="Z3_ast const*">left side of equalities</param>
    /// <param name="eqRhs" ctype="Z3_ast const*">right side of equalities</param>
    /// <param name="conseq" ctype="Z3_ast">consequence to propagate. It is typically an atomic formula, but it can be an arbitrary formula.</param>
    [Z3Function("Z3_solver_propagate_consequence")]
    internal bool SolverPropagateConsequence(IntPtr c, IntPtr cb, uint numFixed, IntPtr @fixed, uint numEqs, IntPtr eqLhs, IntPtr eqRhs, IntPtr conseq)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_propagate_consequence");
        var func = Marshal.GetDelegateForFunctionPointer<SolverPropagateConsequenceDelegate>(funcPtr);
        return func(c, cb, numFixed, @fixed, numEqs, eqLhs, eqRhs, conseq);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SolverSetInitialValueDelegate(IntPtr c, IntPtr s, IntPtr v, IntPtr val);

    /// <summary>
    /// provide an initialization hint to the solver. The initialization hint is used to calibrate an initial value of the expression that
    /// represents a variable. If the variable is Boolean, the initial phase is set according to value. If the variable is an integer or real,
    /// the initial Simplex tableau is recalibrated to attempt to follow the value assignment.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="val" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_solver_set_initial_value")]
    internal void SolverSetInitialValue(IntPtr c, IntPtr s, IntPtr v, IntPtr val)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_set_initial_value");
        var func = Marshal.GetDelegateForFunctionPointer<SolverSetInitialValueDelegate>(funcPtr);
        func(c, s, v, val);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool SolverCheckDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// <para>
    /// Check whether the assertions in a given solver are consistent or not.
    /// </para>
    /// <para>
    /// The function <see cref="SolverGetModel"/> retrieves a model if the
    /// assertions is satisfiable (i.e., the result is \c
    /// Z3_L_TRUE) and model construction is enabled.
    /// Note that if the call returns Z3_L_UNDEF, Z3 does not
    /// ensure that calls to <see cref="SolverGetModel"/> succeed and any models
    /// produced in this case are not guaranteed to satisfy the assertions.
    /// </para>
    /// <para>
    /// The function <see cref="SolverGetProof"/> retrieves a proof if proof
    /// generation was enabled when the context was created, and the
    /// assertions are unsatisfiable (i.e., the result is Z3_L_FALSE).
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverCheckAssumptions"/>
    [Z3Function("Z3_solver_check")]
    internal Lbool SolverCheck(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_check");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCheckDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool SolverCheckAssumptionsDelegate(IntPtr c, IntPtr s, uint numAssumptions, IntPtr[] assumptions);

    /// <summary>
    /// <para>
    /// Check whether the assertions in the given solver and
    /// optional assumptions are consistent or not.
    /// </para>
    /// <para>
    /// The function <see cref="SolverGetUnsatCore"/> retrieves the subset of the
    /// assumptions used in the unsatisfiability proof produced by Z3.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="numAssumptions" ctype="unsigned">unsigned parameter</param>
    /// <param name="assumptions" ctype="Z3_ast const[]">ast parameter</param>
    /// <seealso cref="SolverCheck"/>
    [Z3Function("Z3_solver_check_assumptions")]
    internal Lbool SolverCheckAssumptions(IntPtr c, IntPtr s, uint numAssumptions, IntPtr[] assumptions)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_check_assumptions");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCheckAssumptionsDelegate>(funcPtr);
        return func(c, s, numAssumptions, assumptions);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool GetImpliedEqualitiesDelegate(IntPtr c, IntPtr s, uint numTerms, IntPtr[] terms, uint[] classIds);

    /// <summary>
    /// <para>
    /// Retrieve congruence class representatives for terms.
    /// </para>
    /// <para>
    /// The function can be used for relying on Z3 to identify equal terms under the current
    /// set of assumptions. The array of terms and array of class identifiers should have
    /// the same length. The class identifiers are numerals that are assigned to the same
    /// value for their corresponding terms if the current context forces the terms to be
    /// equal. You cannot deduce that terms corresponding to different numerals must be all different,
    /// (especially when using non-convex theories).
    /// All implied equalities are returned by this call.
    /// This means that two terms map to the same class identifier if and only if
    /// the current context implies that they are equal.
    /// </para>
    /// <para>
    /// A side-effect of the function is a satisfiability check on the assertions on the solver that is passed in.
    /// The function return Z3_L_FALSE if the current assertions are not satisfiable.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="numTerms" ctype="unsigned">unsigned parameter</param>
    /// <param name="terms" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="classIds" ctype="unsigned[]">unsigned parameter</param>
    [Z3Function("Z3_get_implied_equalities")]
    internal Lbool GetImpliedEqualities(IntPtr c, IntPtr s, uint numTerms, IntPtr[] terms, uint[] classIds)
    {
        var funcPtr = GetFunctionPointer("Z3_get_implied_equalities");
        var func = Marshal.GetDelegateForFunctionPointer<GetImpliedEqualitiesDelegate>(funcPtr);
        return func(c, s, numTerms, terms, classIds);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate Lbool SolverGetConsequencesDelegate(IntPtr c, IntPtr s, IntPtr assumptions, IntPtr variables, IntPtr consequences);

    /// <summary>
    /// retrieve consequences from solver that determine values of the supplied function symbols.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="assumptions" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="variables" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="consequences" ctype="Z3_ast_vector">ast_vector parameter</param>
    [Z3Function("Z3_solver_get_consequences")]
    internal Lbool SolverGetConsequences(IntPtr c, IntPtr s, IntPtr assumptions, IntPtr variables, IntPtr consequences)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_consequences");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetConsequencesDelegate>(funcPtr);
        return func(c, s, assumptions, variables, consequences);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverCubeDelegate(IntPtr c, IntPtr s, IntPtr vars, uint backtrackLevel);

    /// <summary>
    /// <para>
    /// extract a next cube for a solver. The last cube is the constant true or false.
    /// The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled
    /// using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction.
    /// </para>
    /// <para>
    /// The third argument is a vector of variables that may be used for cubing.
    /// The contents of the vector is only used in the first call. The initial list of variables
    /// is used in subsequent calls until it returns the unsatisfiable cube.
    /// The vector is modified to contain a set of Autarky variables that occur in clauses that
    /// are affected by the (last literal in the) cube. These variables could be used by a different
    /// cuber (on a different solver object) for further recursive cubing.
    /// </para>
    /// <para>
    /// The last argument is a backtracking level. It instructs the cube process to backtrack below
    /// the indicated level for the next cube.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="vars" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="backtrackLevel" ctype="unsigned">unsigned parameter</param>
    [Z3Function("Z3_solver_cube")]
    internal IntPtr SolverCube(IntPtr c, IntPtr s, IntPtr vars, uint backtrackLevel)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_cube");
        var func = Marshal.GetDelegateForFunctionPointer<SolverCubeDelegate>(funcPtr);
        return func(c, s, vars, backtrackLevel);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetModelDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// <para>
    /// Retrieve the model for the last <see cref="SolverCheck"/> or <see cref="SolverCheckAssumptions"/>
    /// </para>
    /// <para>
    /// The error handler is invoked if a model is not available because
    /// the commands above were not invoked for the given solver, or if the result was Z3_L_FALSE.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_model")]
    internal IntPtr SolverGetModel(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_model");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetModelDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetProofDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// <para>
    /// Retrieve the proof for the last <see cref="SolverCheck"/> or <see cref="SolverCheckAssumptions"/>
    /// </para>
    /// <para>
    /// The error handler is invoked if proof generation is not enabled,
    /// or if the commands above were not invoked for the given solver,
    /// or if the result was different from Z3_L_FALSE.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_proof")]
    internal IntPtr SolverGetProof(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_proof");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetProofDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetUnsatCoreDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// <para>
    /// Retrieve the unsat core for the last <see cref="SolverCheckAssumptions"/>
    /// The unsat core is a subset of the assumptions a.
    /// </para>
    /// <para>
    /// By default, the unsat core will not be minimized. Generation of a minimized
    /// unsat core can be enabled via the `"sat.core.minimize"` and `"smt.core.minimize"`
    /// settings for SAT and SMT cores respectively. Generation of minimized unsat cores
    /// will be more expensive.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_unsat_core")]
    internal IntPtr SolverGetUnsatCore(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_unsat_core");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetUnsatCoreDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetReasonUnknownDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return a brief justification for an "unknown" result (i.e., Z3_L_UNDEF) for
    /// the commands <see cref="SolverCheck"/> and <see cref="SolverCheckAssumptions"/>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    [Z3Function("Z3_solver_get_reason_unknown")]
    internal IntPtr SolverGetReasonUnknown(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_reason_unknown");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetReasonUnknownDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverGetStatisticsDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Return statistics for the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <remarks>
    /// User must use <see cref="StatsIncRef"/> and <see cref="StatsDecRef"/> to manage Z3_stats objects.
    /// </remarks>
    [Z3Function("Z3_solver_get_statistics")]
    internal IntPtr SolverGetStatistics(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_get_statistics");
        var func = Marshal.GetDelegateForFunctionPointer<SolverGetStatisticsDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverToStringDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Convert a solver into a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverFromFile"/>
    /// <seealso cref="SolverFromString"/>
    [Z3Function("Z3_solver_to_string")]
    internal IntPtr SolverToString(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<SolverToStringDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SolverToDimacsStringDelegate(IntPtr c, IntPtr s, bool includeNames);

    /// <summary>
    /// Convert a solver into a DIMACS formatted string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="includeNames" ctype="bool">bool parameter</param>
    /// <seealso cref="GoalToDimacsString"/>
    [Z3Function("Z3_solver_to_dimacs_string")]
    internal IntPtr SolverToDimacsString(IntPtr c, IntPtr s, bool includeNames)
    {
        var funcPtr = GetFunctionPointer("Z3_solver_to_dimacs_string");
        var func = Marshal.GetDelegateForFunctionPointer<SolverToDimacsStringDelegate>(funcPtr);
        return func(c, s, includeNames);
    }

}
