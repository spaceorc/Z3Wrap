// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Integers and Reals
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkAddDelegate(IntPtr c, uint numArgs, IntPtr[] args);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>args[0] + ... + args[num_args-1]</code>.
    /// </para>
    /// <para>
    /// The array args must have num_args elements.
    /// All arguments must have int or real sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <remarks>
    /// The number of arguments must be greater than zero.
    /// </remarks>
    [Z3Function("Z3_mk_add")]
    internal IntPtr MkAdd(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_add");
        var func = Marshal.GetDelegateForFunctionPointer<MkAddDelegate>(funcPtr);
        return func(c, numArgs, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkMulDelegate(IntPtr c, uint numArgs, IntPtr[] args);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>args[0] * ... * args[num_args-1]</code>.
    /// </para>
    /// <para>
    /// The array args must have num_args elements.
    /// All arguments must have int or real sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <remarks>
    /// Z3 has limited support for non-linear arithmetic.
    /// The number of arguments must be greater than zero.
    /// </remarks>
    [Z3Function("Z3_mk_mul")]
    internal IntPtr MkMul(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_mul");
        var func = Marshal.GetDelegateForFunctionPointer<MkMulDelegate>(funcPtr);
        return func(c, numArgs, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkSubDelegate(IntPtr c, uint numArgs, IntPtr[] args);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>args[0] - ... - args[num_args - 1]</code>.
    /// </para>
    /// <para>
    /// The array args must have num_args elements.
    /// All arguments must have int or real sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <remarks>
    /// The number of arguments must be greater than zero.
    /// </remarks>
    [Z3Function("Z3_mk_sub")]
    internal IntPtr MkSub(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_sub");
        var func = Marshal.GetDelegateForFunctionPointer<MkSubDelegate>(funcPtr);
        return func(c, numArgs, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkUnaryMinusDelegate(IntPtr c, IntPtr arg);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>- arg</code>.
    /// </para>
    /// <para>
    /// The arguments must have int or real type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_unary_minus")]
    internal IntPtr MkUnaryMinus(IntPtr c, IntPtr arg)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_unary_minus");
        var func = Marshal.GetDelegateForFunctionPointer<MkUnaryMinusDelegate>(funcPtr);
        return func(c, arg);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkDivDelegate(IntPtr c, IntPtr arg1, IntPtr arg2);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>arg1 div arg2</code>.
    /// </para>
    /// <para>
    /// The arguments must either both have int type or both have real type.
    /// If the arguments have int type, then the result type is an int type, otherwise the
    /// the result type is real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_div")]
    internal IntPtr MkDiv(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_div");
        var func = Marshal.GetDelegateForFunctionPointer<MkDivDelegate>(funcPtr);
        return func(c, arg1, arg2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkModDelegate(IntPtr c, IntPtr arg1, IntPtr arg2);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>arg1 mod arg2</code>.
    /// </para>
    /// <para>
    /// The arguments must have int type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_mod")]
    internal IntPtr MkMod(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_mod");
        var func = Marshal.GetDelegateForFunctionPointer<MkModDelegate>(funcPtr);
        return func(c, arg1, arg2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRemDelegate(IntPtr c, IntPtr arg1, IntPtr arg2);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>arg1 rem arg2</code>.
    /// </para>
    /// <para>
    /// The arguments must have int type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_rem")]
    internal IntPtr MkRem(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_rem");
        var func = Marshal.GetDelegateForFunctionPointer<MkRemDelegate>(funcPtr);
        return func(c, arg1, arg2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkPowerDelegate(IntPtr c, IntPtr arg1, IntPtr arg2);

    /// <summary>
    /// <para>
    /// Create an AST node representing <code>arg1 ^ arg2</code>.
    /// </para>
    /// <para>
    /// The arguments must have int or real type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_power")]
    internal IntPtr MkPower(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_power");
        var func = Marshal.GetDelegateForFunctionPointer<MkPowerDelegate>(funcPtr);
        return func(c, arg1, arg2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkAbsDelegate(IntPtr c, IntPtr arg);

    /// <summary>
    /// Take the absolute value of an integer
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_abs")]
    internal IntPtr MkAbs(IntPtr c, IntPtr arg)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_abs");
        var func = Marshal.GetDelegateForFunctionPointer<MkAbsDelegate>(funcPtr);
        return func(c, arg);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkLtDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create less than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_lt")]
    internal IntPtr MkLt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_lt");
        var func = Marshal.GetDelegateForFunctionPointer<MkLtDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkLeDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create less than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_le")]
    internal IntPtr MkLe(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_le");
        var func = Marshal.GetDelegateForFunctionPointer<MkLeDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkGtDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create greater than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_gt")]
    internal IntPtr MkGt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_gt");
        var func = Marshal.GetDelegateForFunctionPointer<MkGtDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkGeDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create greater than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_ge")]
    internal IntPtr MkGe(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_ge");
        var func = Marshal.GetDelegateForFunctionPointer<MkGeDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkDividesDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    /// <para>
    /// Create division predicate.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must be of integer sort.
    /// The predicate is true when t1 divides t2. For the predicate to be part of
    /// linear integer arithmetic, the first argument t1 must be a non-zero integer.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    [Z3Function("Z3_mk_divides")]
    internal IntPtr MkDivides(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_divides");
        var func = Marshal.GetDelegateForFunctionPointer<MkDividesDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkInt2realDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// <para>
    /// Coerce an integer to a real.
    /// </para>
    /// <para>
    /// There is also a converse operation exposed.
    /// It follows the semantics prescribed by the SMT-LIB standard.
    /// </para>
    /// <para>
    /// You can take the floor of a real by
    /// creating an auxiliary integer constant k and
    /// and asserting <code>mk_int2real(k) &lt;= t1 &lt; mk_int2real(k)+1</code>.
    /// </para>
    /// <para>
    /// The node t1 must have sort integer.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="MkReal2int"/>
    /// <seealso cref="MkIsInt"/>
    [Z3Function("Z3_mk_int2real")]
    internal IntPtr MkInt2real(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_int2real");
        var func = Marshal.GetDelegateForFunctionPointer<MkInt2realDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkReal2intDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// <para>
    /// Coerce a real to an integer.
    /// </para>
    /// <para>
    /// The semantics of this function follows the SMT-LIB standard
    /// for the function to_int
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="MkInt2real"/>
    /// <seealso cref="MkIsInt"/>
    [Z3Function("Z3_mk_real2int")]
    internal IntPtr MkReal2int(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_real2int");
        var func = Marshal.GetDelegateForFunctionPointer<MkReal2intDelegate>(funcPtr);
        return func(c, t1);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkIsIntDelegate(IntPtr c, IntPtr t1);

    /// <summary>
    /// Check if a real number is an integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="MkInt2real"/>
    /// <seealso cref="MkReal2int"/>
    [Z3Function("Z3_mk_is_int")]
    internal IntPtr MkIsInt(IntPtr c, IntPtr t1)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_is_int");
        var func = Marshal.GetDelegateForFunctionPointer<MkIsIntDelegate>(funcPtr);
        return func(c, t1);
    }

}
