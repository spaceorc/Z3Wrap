// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Sorts
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkUninterpretedSortDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Create a free (uninterpreted) type using the given name (symbol).
    /// Two free types are considered the same iff the have the same name.
    /// </summary>
    [Z3Function("Z3_mk_uninterpreted_sort")]
    internal IntPtr MkUninterpretedSort(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_uninterpreted_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkUninterpretedSortDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkTypeVariableDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Create a type variable.
    /// Functions using type variables can be applied to instantiations that match the signature
    /// of the function. Assertions using type variables correspond to assertions over all possible
    /// instantiations.
    /// </summary>
    [Z3Function("Z3_mk_type_variable")]
    internal IntPtr MkTypeVariable(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_type_variable");
        var func = Marshal.GetDelegateForFunctionPointer<MkTypeVariableDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBoolSortDelegate(IntPtr c);

    /// <summary>
    /// Create the Boolean type.
    /// This type is used to create propositional variables and predicates.
    /// </summary>
    [Z3Function("Z3_mk_bool_sort")]
    internal IntPtr MkBoolSort(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bool_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkBoolSortDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkIntSortDelegate(IntPtr c);

    /// <summary>
    /// Create the integer type.
    /// This type is not the int type found in programming languages.
    /// A machine integer can be represented using bit-vectors. The function
    /// <see cref="MkBvSort"/> creates a bit-vector type.
    /// </summary>
    /// <seealso cref="MkBvSort"/>
    [Z3Function("Z3_mk_int_sort")]
    internal IntPtr MkIntSort(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_int_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkIntSortDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRealSortDelegate(IntPtr c);

    /// <summary>
    /// Create the real type.
    /// Note that this type is not a floating point number.
    /// </summary>
    [Z3Function("Z3_mk_real_sort")]
    internal IntPtr MkRealSort(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_real_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkRealSortDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvSortDelegate(IntPtr c, uint sz);

    /// <summary>
    /// Create a bit-vector type of the given size.
    /// This type can also be seen as a machine integer.
    /// </summary>
    /// <remarks>
    /// The size of the bit-vector type must be greater than zero.
    /// </remarks>
    [Z3Function("Z3_mk_bv_sort")]
    internal IntPtr MkBvSort(IntPtr c, uint sz)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bv_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvSortDelegate>(funcPtr);
        return func(c, sz);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkFiniteDomainSortDelegate(IntPtr c, IntPtr name, ulong size);

    /// <summary>
    /// Create a named finite domain sort.
    /// To create constants that belong to the finite domain,
    /// use the APIs for creating numerals and pass a numeric
    /// constant together with the sort returned by this call.
    /// The numeric constant should be between 0 and the less
    /// than the size of the domain.
    /// </summary>
    /// <seealso cref="GetFiniteDomainSortSize"/>
    [Z3Function("Z3_mk_finite_domain_sort")]
    internal IntPtr MkFiniteDomainSort(IntPtr c, IntPtr name, ulong size)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_finite_domain_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkFiniteDomainSortDelegate>(funcPtr);
        return func(c, name, size);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkArraySortDelegate(IntPtr c, IntPtr domain, IntPtr range);

    /// <summary>
    /// Create an array type.
    /// We usually represent the array type as: <code>[domain -&gt; range]</code>.
    /// Arrays are usually used to model the heap/memory in software verification.
    /// </summary>
    /// <seealso cref="MkSelect"/>
    /// <seealso cref="MkStore"/>
    [Z3Function("Z3_mk_array_sort")]
    internal IntPtr MkArraySort(IntPtr c, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_array_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkArraySortDelegate>(funcPtr);
        return func(c, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkArraySortNDelegate(IntPtr c, uint n, IntPtr domain, IntPtr range);

    /// <summary>
    /// Create an array type with N arguments
    /// </summary>
    /// <seealso cref="MkSelectN"/>
    /// <seealso cref="MkStoreN"/>
    [Z3Function("Z3_mk_array_sort_n")]
    internal IntPtr MkArraySortN(IntPtr c, uint n, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_array_sort_n");
        var func = Marshal.GetDelegateForFunctionPointer<MkArraySortNDelegate>(funcPtr);
        return func(c, n, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkTupleSortDelegate(IntPtr c, IntPtr mkTupleName, uint numFields, IntPtr[] fieldNames, IntPtr[] fieldSorts, IntPtr mkTupleDecl, IntPtr[] projDecl);

    /// <summary>
    /// Create a tuple type.
    /// A tuple with n fields has a constructor and n projections.
    /// This function will also declare the constructor and projection functions.
    /// </summary>
    /// <param name="c">logical context</param>
    /// <param name="mkTupleName">name of the constructor function associated with the tuple type.</param>
    /// <param name="numFields">number of fields in the tuple type.</param>
    /// <param name="fieldNames">name of the projection functions.</param>
    /// <param name="fieldSorts">type of the tuple fields.</param>
    /// <param name="mkTupleDecl">output parameter that will contain the constructor declaration.</param>
    /// <param name="projDecl">output parameter that will contain the projection function declarations. This field must be a buffer of size num_fields allocated by the user.</param>
    [Z3Function("Z3_mk_tuple_sort")]
    internal IntPtr MkTupleSort(IntPtr c, IntPtr mkTupleName, uint numFields, IntPtr[] fieldNames, IntPtr[] fieldSorts, IntPtr mkTupleDecl, IntPtr[] projDecl)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_tuple_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkTupleSortDelegate>(funcPtr);
        return func(c, mkTupleName, numFields, fieldNames, fieldSorts, mkTupleDecl, projDecl);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkEnumerationSortDelegate(IntPtr c, IntPtr name, uint n, IntPtr[] enumNames, IntPtr[] enumConsts, IntPtr[] enumTesters);

    /// <summary>
    /// Create a enumeration sort.
    /// An enumeration sort with n elements.
    /// This function will also declare the functions corresponding to the enumerations.
    /// </summary>
    /// <param name="c">logical context</param>
    /// <param name="name">name of the enumeration sort.</param>
    /// <param name="n">number of elements in enumeration sort.</param>
    /// <param name="enumNames">names of the enumerated elements.</param>
    /// <param name="enumConsts">constants corresponding to the enumerated elements.</param>
    /// <param name="enumTesters">
    /// predicates testing if terms of the enumeration sort correspond to an enumeration.
    /// For example, if this function is called with three symbols A, B, C and the name S, then
    /// s is a sort whose name is S, and the function returns three terms corresponding to A, B, C in
    /// enum_consts. The array enum_testers has three predicates of type <code>(s -&gt; Bool)</code>.
    /// The first predicate (corresponding to A) is true when applied to A, and false otherwise.
    /// Similarly for the other predicates.
    /// </param>
    [Z3Function("Z3_mk_enumeration_sort")]
    internal IntPtr MkEnumerationSort(IntPtr c, IntPtr name, uint n, IntPtr[] enumNames, IntPtr[] enumConsts, IntPtr[] enumTesters)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_enumeration_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkEnumerationSortDelegate>(funcPtr);
        return func(c, name, n, enumNames, enumConsts, enumTesters);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkListSortDelegate(IntPtr c, IntPtr name, IntPtr elemSort, IntPtr nilDecl, IntPtr isNilDecl, IntPtr consDecl, IntPtr isConsDecl, IntPtr headDecl, IntPtr tailDecl);

    /// <summary>
    /// Create a list sort
    /// A list sort over elem_sort
    /// This function declares the corresponding constructors and testers for lists.
    /// </summary>
    /// <param name="c">logical context</param>
    /// <param name="name">name of the list sort.</param>
    /// <param name="elemSort">sort of list elements.</param>
    /// <param name="nilDecl">declaration for the empty list.</param>
    /// <param name="isNilDecl">test for the empty list.</param>
    /// <param name="consDecl">declaration for a cons cell.</param>
    /// <param name="isConsDecl">cons cell test.</param>
    /// <param name="headDecl">list head.</param>
    /// <param name="tailDecl">list tail.</param>
    [Z3Function("Z3_mk_list_sort")]
    internal IntPtr MkListSort(IntPtr c, IntPtr name, IntPtr elemSort, IntPtr nilDecl, IntPtr isNilDecl, IntPtr consDecl, IntPtr isConsDecl, IntPtr headDecl, IntPtr tailDecl)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_list_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkListSortDelegate>(funcPtr);
        return func(c, name, elemSort, nilDecl, isNilDecl, consDecl, isConsDecl, headDecl, tailDecl);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConstructorDelegate(IntPtr c, IntPtr name, IntPtr recognizer, uint numFields, IntPtr[] fieldNames, IntPtr[] sorts, uint[] sortRefs);

    /// <summary>
    /// Create a constructor.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="name">constructor name.</param>
    /// <param name="recognizer">name of recognizer function.</param>
    /// <param name="numFields">number of fields in constructor.</param>
    /// <param name="fieldNames">names of the constructor fields.</param>
    /// <param name="sorts">field sorts, 0 if the field sort refers to a recursive sort.</param>
    /// <param name="sortRefs">
    /// reference to datatype sort that is an argument to the constructor; if the corresponding
    /// sort reference is 0, then the value in sort_refs should be an index referring to
    /// one of the recursive datatypes that is declared.
    /// </param>
    /// <seealso cref="DelConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="QueryConstructor"/>
    [Z3Function("Z3_mk_constructor")]
    internal IntPtr MkConstructor(IntPtr c, IntPtr name, IntPtr recognizer, uint numFields, IntPtr[] fieldNames, IntPtr[] sorts, uint[] sortRefs)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_constructor");
        var func = Marshal.GetDelegateForFunctionPointer<MkConstructorDelegate>(funcPtr);
        return func(c, name, recognizer, numFields, fieldNames, sorts, sortRefs);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ConstructorNumFieldsDelegate(IntPtr c, IntPtr constr);

    /// <summary>
    /// Retrieve the number of fields of a constructor
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="constr">constructor.</param>
    [Z3Function("Z3_constructor_num_fields")]
    internal uint ConstructorNumFields(IntPtr c, IntPtr constr)
    {
        var funcPtr = GetFunctionPointer("Z3_constructor_num_fields");
        var func = Marshal.GetDelegateForFunctionPointer<ConstructorNumFieldsDelegate>(funcPtr);
        return func(c, constr);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void DelConstructorDelegate(IntPtr c, IntPtr constr);

    /// <summary>
    /// Reclaim memory allocated to constructor.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="constr">constructor.</param>
    /// <seealso cref="MkConstructor"/>
    [Z3Function("Z3_del_constructor")]
    internal void DelConstructor(IntPtr c, IntPtr constr)
    {
        var funcPtr = GetFunctionPointer("Z3_del_constructor");
        var func = Marshal.GetDelegateForFunctionPointer<DelConstructorDelegate>(funcPtr);
        func(c, constr);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkDatatypeDelegate(IntPtr c, IntPtr name, uint numConstructors, IntPtr[] constructors);

    /// <summary>
    /// Create datatype, such as lists, trees, records, enumerations or unions of records.
    /// The datatype may be recursive. Return the datatype sort.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="name">name of datatype.</param>
    /// <param name="numConstructors">number of constructors passed in.</param>
    /// <param name="constructors">array of constructor containers.</param>
    /// <seealso cref="MkConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="MkDatatypes"/>
    [Z3Function("Z3_mk_datatype")]
    internal IntPtr MkDatatype(IntPtr c, IntPtr name, uint numConstructors, IntPtr[] constructors)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_datatype");
        var func = Marshal.GetDelegateForFunctionPointer<MkDatatypeDelegate>(funcPtr);
        return func(c, name, numConstructors, constructors);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkDatatypeSortDelegate(IntPtr c, IntPtr name);

    /// <summary>
    /// create a forward reference to a recursive datatype being declared.
    /// The forward reference can be used in a nested occurrence: the range of an array
    /// or as element sort of a sequence. The forward reference should only be used when
    /// used in an accessor for a recursive datatype that gets declared.
    /// Forward references can replace the use sort references, that are unsigned integers
    /// in the Z3_mk_constructor call
    /// </summary>
    [Z3Function("Z3_mk_datatype_sort")]
    internal IntPtr MkDatatypeSort(IntPtr c, IntPtr name)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_datatype_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkDatatypeSortDelegate>(funcPtr);
        return func(c, name);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConstructorListDelegate(IntPtr c, uint numConstructors, IntPtr[] constructors);

    /// <summary>
    /// Create list of constructors.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="numConstructors">number of constructors in list.</param>
    /// <param name="constructors">list of constructors.</param>
    /// <seealso cref="DelConstructorList"/>
    /// <seealso cref="MkConstructor"/>
    [Z3Function("Z3_mk_constructor_list")]
    internal IntPtr MkConstructorList(IntPtr c, uint numConstructors, IntPtr[] constructors)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_constructor_list");
        var func = Marshal.GetDelegateForFunctionPointer<MkConstructorListDelegate>(funcPtr);
        return func(c, numConstructors, constructors);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void DelConstructorListDelegate(IntPtr c, IntPtr clist);

    /// <summary>
    /// Reclaim memory allocated for constructor list.
    /// Each constructor inside the constructor list must be independently reclaimed using <see cref="DelConstructor"/>.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="clist">constructor list container.</param>
    /// <seealso cref="MkConstructorList"/>
    [Z3Function("Z3_del_constructor_list")]
    internal void DelConstructorList(IntPtr c, IntPtr clist)
    {
        var funcPtr = GetFunctionPointer("Z3_del_constructor_list");
        var func = Marshal.GetDelegateForFunctionPointer<DelConstructorListDelegate>(funcPtr);
        func(c, clist);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void MkDatatypesDelegate(IntPtr c, uint numSorts, IntPtr[] sortNames, IntPtr[] sorts, IntPtr[] constructorLists);

    /// <summary>
    /// Create mutually recursive datatypes.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="numSorts">number of datatype sorts.</param>
    /// <param name="sortNames">names of datatype sorts.</param>
    /// <param name="sorts">array of datatype sorts.</param>
    /// <param name="constructorLists">list of constructors, one list per sort.</param>
    /// <seealso cref="MkConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="MkDatatype"/>
    [Z3Function("Z3_mk_datatypes")]
    internal void MkDatatypes(IntPtr c, uint numSorts, IntPtr[] sortNames, IntPtr[] sorts, IntPtr[] constructorLists)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_datatypes");
        var func = Marshal.GetDelegateForFunctionPointer<MkDatatypesDelegate>(funcPtr);
        func(c, numSorts, sortNames, sorts, constructorLists);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void QueryConstructorDelegate(IntPtr c, IntPtr constr, uint numFields, IntPtr constructor, IntPtr tester, IntPtr[] accessors);

    /// <summary>
    /// Query constructor for declared functions.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="constr">constructor container. The container must have been passed into a <see cref="MkDatatype"/> call.</param>
    /// <param name="numFields">number of accessor fields in the constructor.</param>
    /// <param name="constructor">constructor function declaration, allocated by user.</param>
    /// <param name="tester">constructor test function declaration, allocated by user.</param>
    /// <param name="accessors">array of accessor function declarations allocated by user. The array must contain num_fields elements.</param>
    /// <seealso cref="MkConstructor"/>
    [Z3Function("Z3_query_constructor")]
    internal void QueryConstructor(IntPtr c, IntPtr constr, uint numFields, IntPtr constructor, IntPtr tester, IntPtr[] accessors)
    {
        var funcPtr = GetFunctionPointer("Z3_query_constructor");
        var func = Marshal.GetDelegateForFunctionPointer<QueryConstructorDelegate>(funcPtr);
        func(c, constr, numFields, constructor, tester, accessors);
    }

}
