// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Sorts
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkUninterpretedSortDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Create a free (uninterpreted) type using the given name (symbol). Two free types are considered the same iff the have the same name.
    /// </summary>
    [Z3Function("Z3_mk_uninterpreted_sort")]
    internal IntPtr MkUninterpretedSort(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_uninterpreted_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkUninterpretedSortDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkTypeVariableDelegate(IntPtr c, IntPtr s);

    /// <summary>
    /// Create a type variable. Functions using type variables can be applied to instantiations that match the signature of the function. Assertions using type variables correspond to assertions over all possible instantiations.
    /// </summary>
    [Z3Function("Z3_mk_type_variable")]
    internal IntPtr MkTypeVariable(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_type_variable");
        var func = Marshal.GetDelegateForFunctionPointer<MkTypeVariableDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBoolSortDelegate(IntPtr c);

    /// <summary>
    /// Create the Boolean type. This type is used to create propositional variables and predicates.
    /// </summary>
    [Z3Function("Z3_mk_bool_sort")]
    internal IntPtr MkBoolSort(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bool_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkBoolSortDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkIntSortDelegate(IntPtr c);

    /// <summary>
    /// Create the integer type. This type is not the int type found in programming languages. A machine integer can be represented using bit-vectors. The function Z3_mk_bv_sort creates a bit-vector type.
    /// </summary>
    /// <seealso cref="MkBvSort"/>
    [Z3Function("Z3_mk_int_sort")]
    internal IntPtr MkIntSort(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_int_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkIntSortDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkRealSortDelegate(IntPtr c);

    /// <summary>
    /// Create the real type. Note that this type is not a floating point number.
    /// </summary>
    [Z3Function("Z3_mk_real_sort")]
    internal IntPtr MkRealSort(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_real_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkRealSortDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkBvSortDelegate(IntPtr c, uint sz);

    /// <summary>
    /// Create a bit-vector type of the given size. This type can also be seen as a machine integer.
    /// </summary>
    /// <remarks>
    /// The size of the bit-vector type must be greater than zero.
    /// </remarks>
    [Z3Function("Z3_mk_bv_sort")]
    internal IntPtr MkBvSort(IntPtr c, uint sz)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_bv_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkBvSortDelegate>(funcPtr);
        return func(c, sz);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkFiniteDomainSortDelegate(IntPtr c, IntPtr name, ulong size);

    /// <summary>
    /// Create a named finite domain sort. To create constants that belong to the finite domain, use the APIs for creating numerals and pass a numeric constant together with the sort returned by this call. The numeric constant should be between 0 and the less than the size of the domain.
    /// </summary>
    /// <seealso cref="GetFiniteDomainSortSize"/>
    [Z3Function("Z3_mk_finite_domain_sort")]
    internal IntPtr MkFiniteDomainSort(IntPtr c, IntPtr name, ulong size)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_finite_domain_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkFiniteDomainSortDelegate>(funcPtr);
        return func(c, name, size);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkArraySortDelegate(IntPtr c, IntPtr domain, IntPtr range);

    /// <summary>
    /// Create an array type. We usually represent the array type as: [domain -&gt; range]. Arrays are usually used to model the heap/memory in software verification.
    /// </summary>
    /// <seealso cref="MkSelect"/>
    /// <seealso cref="MkStore"/>
    [Z3Function("Z3_mk_array_sort")]
    internal IntPtr MkArraySort(IntPtr c, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_array_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkArraySortDelegate>(funcPtr);
        return func(c, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkArraySortNDelegate(IntPtr c, uint n, IntPtr domain, IntPtr range);

    /// <summary>
    /// Create an array type with N arguments
    /// </summary>
    /// <seealso cref="MkSelectN"/>
    /// <seealso cref="MkStoreN"/>
    [Z3Function("Z3_mk_array_sort_n")]
    internal IntPtr MkArraySortN(IntPtr c, uint n, IntPtr domain, IntPtr range)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_array_sort_n");
        var func = Marshal.GetDelegateForFunctionPointer<MkArraySortNDelegate>(funcPtr);
        return func(c, n, domain, range);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkTupleSortDelegate(IntPtr c, IntPtr mk_tuple_name, uint num_fields, IntPtr[] field_names, IntPtr[] field_sorts, IntPtr mk_tuple_decl, IntPtr[] proj_decl);

    /// <summary>
    /// Create a tuple type. A tuple with n fields has a constructor and n projections. This function will also declare the constructor and projection functions.
    /// </summary>
    /// <param name="c">logical context</param>
    /// <param name="mk_tuple_name">name of the constructor function associated with the tuple type.</param>
    /// <param name="num_fields">number of fields in the tuple type.</param>
    /// <param name="field_names">name of the projection functions.</param>
    /// <param name="field_sorts">type of the tuple fields.</param>
    /// <param name="mk_tuple_decl">output parameter that will contain the constructor declaration.</param>
    /// <param name="proj_decl">output parameter that will contain the projection function declarations. This field must be a buffer of size num_fields allocated by the user.</param>
    [Z3Function("Z3_mk_tuple_sort")]
    internal IntPtr MkTupleSort(IntPtr c, IntPtr mk_tuple_name, uint num_fields, IntPtr[] field_names, IntPtr[] field_sorts, IntPtr mk_tuple_decl, IntPtr[] proj_decl)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_tuple_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkTupleSortDelegate>(funcPtr);
        return func(c, mk_tuple_name, num_fields, field_names, field_sorts, mk_tuple_decl, proj_decl);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkEnumerationSortDelegate(IntPtr c, IntPtr name, uint n, IntPtr[] enum_names, IntPtr[] enum_consts, IntPtr[] enum_testers);

    /// <summary>
    /// Create a enumeration sort. An enumeration sort with n elements. This function will also declare the functions corresponding to the enumerations.
    /// </summary>
    /// <param name="c">logical context</param>
    /// <param name="name">name of the enumeration sort.</param>
    /// <param name="n">number of elements in enumeration sort.</param>
    /// <param name="enum_names">names of the enumerated elements.</param>
    /// <param name="enum_consts">constants corresponding to the enumerated elements.</param>
    /// <param name="enum_testers">predicates testing if terms of the enumeration sort correspond to an enumeration. For example, if this function is called with three symbols A, B, C and the name S, then s is a sort whose name is S, and the function returns three terms corresponding to A, B, C in enum_consts. The array enum_testers has three predicates of type (s -&gt; Bool). The first predicate (corresponding to A) is true when applied to A, and false otherwise. Similarly for the other predicates.</param>
    [Z3Function("Z3_mk_enumeration_sort")]
    internal IntPtr MkEnumerationSort(IntPtr c, IntPtr name, uint n, IntPtr[] enum_names, IntPtr[] enum_consts, IntPtr[] enum_testers)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_enumeration_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkEnumerationSortDelegate>(funcPtr);
        return func(c, name, n, enum_names, enum_consts, enum_testers);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkListSortDelegate(IntPtr c, IntPtr name, IntPtr elem_sort, IntPtr nil_decl, IntPtr is_nil_decl, IntPtr cons_decl, IntPtr is_cons_decl, IntPtr head_decl, IntPtr tail_decl);

    /// <summary>
    /// Create a list sort A list sort over elem_sort This function declares the corresponding constructors and testers for lists.
    /// </summary>
    /// <param name="c">logical context</param>
    /// <param name="name">name of the list sort.</param>
    /// <param name="elem_sort">sort of list elements.</param>
    /// <param name="nil_decl">declaration for the empty list.</param>
    /// <param name="is_nil_decl">test for the empty list.</param>
    /// <param name="cons_decl">declaration for a cons cell.</param>
    /// <param name="is_cons_decl">cons cell test.</param>
    /// <param name="head_decl">list head.</param>
    /// <param name="tail_decl">list tail.</param>
    [Z3Function("Z3_mk_list_sort")]
    internal IntPtr MkListSort(IntPtr c, IntPtr name, IntPtr elem_sort, IntPtr nil_decl, IntPtr is_nil_decl, IntPtr cons_decl, IntPtr is_cons_decl, IntPtr head_decl, IntPtr tail_decl)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_list_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkListSortDelegate>(funcPtr);
        return func(c, name, elem_sort, nil_decl, is_nil_decl, cons_decl, is_cons_decl, head_decl, tail_decl);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConstructorDelegate(IntPtr c, IntPtr name, IntPtr recognizer, uint num_fields, IntPtr[] field_names, IntPtr[] sorts, uint[] sort_refs);

    /// <summary>
    /// Create a constructor.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="name">constructor name.</param>
    /// <param name="recognizer">name of recognizer function.</param>
    /// <param name="num_fields">number of fields in constructor.</param>
    /// <param name="field_names">names of the constructor fields.</param>
    /// <param name="sorts">field sorts, 0 if the field sort refers to a recursive sort.</param>
    /// <param name="sort_refs">reference to datatype sort that is an argument to the constructor; if the corresponding sort reference is 0, then the value in sort_refs should be an index referring to one of the recursive datatypes that is declared.</param>
    /// <seealso cref="DelConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="QueryConstructor"/>
    [Z3Function("Z3_mk_constructor")]
    internal IntPtr MkConstructor(IntPtr c, IntPtr name, IntPtr recognizer, uint num_fields, IntPtr[] field_names, IntPtr[] sorts, uint[] sort_refs)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_constructor");
        var func = Marshal.GetDelegateForFunctionPointer<MkConstructorDelegate>(funcPtr);
        return func(c, name, recognizer, num_fields, field_names, sorts, sort_refs);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate uint ConstructorNumFieldsDelegate(IntPtr c, IntPtr constr);

    /// <summary>
    /// Retrieve the number of fields of a constructor
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="constr">constructor.</param>
    [Z3Function("Z3_constructor_num_fields")]
    internal uint ConstructorNumFields(IntPtr c, IntPtr constr)
    {
        var funcPtr = GetFunctionPointer("Z3_constructor_num_fields");
        var func = Marshal.GetDelegateForFunctionPointer<ConstructorNumFieldsDelegate>(funcPtr);
        return func(c, constr);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void DelConstructorDelegate(IntPtr c, IntPtr constr);

    /// <summary>
    /// Reclaim memory allocated to constructor.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="constr">constructor.</param>
    /// <seealso cref="MkConstructor"/>
    [Z3Function("Z3_del_constructor")]
    internal void DelConstructor(IntPtr c, IntPtr constr)
    {
        var funcPtr = GetFunctionPointer("Z3_del_constructor");
        var func = Marshal.GetDelegateForFunctionPointer<DelConstructorDelegate>(funcPtr);
        func(c, constr);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkDatatypeDelegate(IntPtr c, IntPtr name, uint num_constructors, IntPtr[] constructors);

    /// <summary>
    /// Create datatype, such as lists, trees, records, enumerations or unions of records. The datatype may be recursive. Return the datatype sort.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="name">name of datatype.</param>
    /// <param name="num_constructors">number of constructors passed in.</param>
    /// <param name="constructors">array of constructor containers.</param>
    /// <seealso cref="MkConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="MkDatatypes"/>
    [Z3Function("Z3_mk_datatype")]
    internal IntPtr MkDatatype(IntPtr c, IntPtr name, uint num_constructors, IntPtr[] constructors)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_datatype");
        var func = Marshal.GetDelegateForFunctionPointer<MkDatatypeDelegate>(funcPtr);
        return func(c, name, num_constructors, constructors);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkDatatypeSortDelegate(IntPtr c, IntPtr name);

    /// <summary>
    /// create a forward reference to a recursive datatype being declared. The forward reference can be used in a nested occurrence: the range of an array or as element sort of a sequence. The forward reference should only be used when used in an accessor for a recursive datatype that gets declared. Forward references can replace the use sort references, that are unsigned integers in the Z3_mk_constructor call
    /// </summary>
    [Z3Function("Z3_mk_datatype_sort")]
    internal IntPtr MkDatatypeSort(IntPtr c, IntPtr name)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_datatype_sort");
        var func = Marshal.GetDelegateForFunctionPointer<MkDatatypeSortDelegate>(funcPtr);
        return func(c, name);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkConstructorListDelegate(IntPtr c, uint num_constructors, IntPtr[] constructors);

    /// <summary>
    /// Create list of constructors.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="num_constructors">number of constructors in list.</param>
    /// <param name="constructors">list of constructors.</param>
    /// <seealso cref="DelConstructorList"/>
    /// <seealso cref="MkConstructor"/>
    [Z3Function("Z3_mk_constructor_list")]
    internal IntPtr MkConstructorList(IntPtr c, uint num_constructors, IntPtr[] constructors)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_constructor_list");
        var func = Marshal.GetDelegateForFunctionPointer<MkConstructorListDelegate>(funcPtr);
        return func(c, num_constructors, constructors);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void DelConstructorListDelegate(IntPtr c, IntPtr clist);

    /// <summary>
    /// Reclaim memory allocated for constructor list. Each constructor inside the constructor list must be independently reclaimed using Z3_del_constructor.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="clist">constructor list container.</param>
    /// <seealso cref="MkConstructorList"/>
    [Z3Function("Z3_del_constructor_list")]
    internal void DelConstructorList(IntPtr c, IntPtr clist)
    {
        var funcPtr = GetFunctionPointer("Z3_del_constructor_list");
        var func = Marshal.GetDelegateForFunctionPointer<DelConstructorListDelegate>(funcPtr);
        func(c, clist);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void MkDatatypesDelegate(IntPtr c, uint num_sorts, IntPtr[] sort_names, IntPtr[] sorts, IntPtr[] constructor_lists);

    /// <summary>
    /// Create mutually recursive datatypes.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="num_sorts">number of datatype sorts.</param>
    /// <param name="sort_names">names of datatype sorts.</param>
    /// <param name="sorts">array of datatype sorts.</param>
    /// <param name="constructor_lists">list of constructors, one list per sort.</param>
    /// <seealso cref="MkConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="MkDatatype"/>
    [Z3Function("Z3_mk_datatypes")]
    internal void MkDatatypes(IntPtr c, uint num_sorts, IntPtr[] sort_names, IntPtr[] sorts, IntPtr[] constructor_lists)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_datatypes");
        var func = Marshal.GetDelegateForFunctionPointer<MkDatatypesDelegate>(funcPtr);
        func(c, num_sorts, sort_names, sorts, constructor_lists);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void QueryConstructorDelegate(IntPtr c, IntPtr constr, uint num_fields, IntPtr constructor, IntPtr tester, IntPtr[] accessors);

    /// <summary>
    /// Query constructor for declared functions.
    /// </summary>
    /// <param name="c">logical context.</param>
    /// <param name="constr">constructor container. The container must have been passed into a Z3_mk_datatype call.</param>
    /// <param name="num_fields">number of accessor fields in the constructor.</param>
    /// <param name="constructor">constructor function declaration, allocated by user.</param>
    /// <param name="tester">constructor test function declaration, allocated by user.</param>
    /// <param name="accessors">array of accessor function declarations allocated by user. The array must contain num_fields elements.</param>
    /// <seealso cref="MkConstructor"/>
    [Z3Function("Z3_query_constructor")]
    internal void QueryConstructor(IntPtr c, IntPtr constr, uint num_fields, IntPtr constructor, IntPtr tester, IntPtr[] accessors)
    {
        var funcPtr = GetFunctionPointer("Z3_query_constructor");
        var func = Marshal.GetDelegateForFunctionPointer<QueryConstructorDelegate>(funcPtr);
        func(c, constr, num_fields, constructor, tester, accessors);
    }

}
