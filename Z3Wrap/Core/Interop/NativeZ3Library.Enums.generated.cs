// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: All Z3 header files
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    /// <summary>
    /// The different kinds of Z3 AST (abstract syntax trees). That is, terms, formulas and types.
    /// </summary>
    internal enum AstKind
    {
        /// <summary>
        /// Z3_NUMERAL_AST
        /// </summary>
        /// <remarks>
        /// numeral constants
        /// </remarks>
        NumeralAst = 0,
        /// <summary>
        /// Z3_APP_AST
        /// </summary>
        /// <remarks>
        /// constant and applications
        /// </remarks>
        AppAst = 1,
        /// <summary>
        /// Z3_VAR_AST
        /// </summary>
        /// <remarks>
        /// bound variables
        /// </remarks>
        VarAst = 2,
        /// <summary>
        /// Z3_QUANTIFIER_AST
        /// </summary>
        /// <remarks>
        /// quantifiers
        /// </remarks>
        QuantifierAst = 3,
        /// <summary>
        /// Z3_SORT_AST
        /// </summary>
        /// <remarks>
        /// sort
        /// </remarks>
        SortAst = 4,
        /// <summary>
        /// Z3_FUNC_DECL_AST
        /// </summary>
        /// <remarks>
        /// function declaration
        /// </remarks>
        FuncDeclAst = 5,
        /// <summary>Z3_UNKNOWN_AST</summary>
        UnknownAst = 1000,
    }

    /// <summary>
    /// Z3 pretty printing modes (See <see cref="SetAstPrintMode"/>).
    /// </summary>
    internal enum AstPrintMode
    {
        /// <summary>
        /// Z3_PRINT_SMTLIB_FULL
        /// </summary>
        /// <remarks>
        /// Print AST nodes in SMTLIB verbose format.
        /// </remarks>
        PrintSmtlibFull = 0,
        /// <summary>
        /// Z3_PRINT_LOW_LEVEL
        /// </summary>
        /// <remarks>
        /// Print AST nodes using a low-level format.
        /// </remarks>
        PrintLowLevel = 1,
        /// <summary>Z3_PRINT_SMTLIB2_COMPLIANT</summary>
        PrintSmtlib2Compliant = 2,
    }

    /// <summary>
    /// The different kinds of interpreted function kinds.
    /// </summary>
    /// <seealso cref="MkBvmulNoOverflow"/>
    /// <seealso cref="MkBvmulNoOverflow"/>
    internal enum DeclKind
    {
        /// <summary>Z3_OP_TRUE</summary>
        OpTrue = 0x100,
        /// <summary>Z3_OP_FALSE</summary>
        OpFalse = 257,
        /// <summary>Z3_OP_EQ</summary>
        OpEq = 258,
        /// <summary>Z3_OP_DISTINCT</summary>
        OpDistinct = 259,
        /// <summary>Z3_OP_ITE</summary>
        OpIte = 260,
        /// <summary>Z3_OP_AND</summary>
        OpAnd = 261,
        /// <summary>Z3_OP_OR</summary>
        OpOr = 262,
        /// <summary>Z3_OP_IFF</summary>
        OpIff = 263,
        /// <summary>Z3_OP_XOR</summary>
        OpXor = 264,
        /// <summary>Z3_OP_NOT</summary>
        OpNot = 265,
        /// <summary>Z3_OP_IMPLIES</summary>
        OpImplies = 266,
        /// <summary>Z3_OP_OEQ</summary>
        OpOeq = 267,
        /// <summary>Z3_OP_ANUM</summary>
        OpAnum = 0x200,
        /// <summary>Z3_OP_AGNUM</summary>
        OpAgnum = 513,
        /// <summary>Z3_OP_LE</summary>
        OpLe = 514,
        /// <summary>Z3_OP_GE</summary>
        OpGe = 515,
        /// <summary>Z3_OP_LT</summary>
        OpLt = 516,
        /// <summary>Z3_OP_GT</summary>
        OpGt = 517,
        /// <summary>Z3_OP_ADD</summary>
        OpAdd = 518,
        /// <summary>Z3_OP_SUB</summary>
        OpSub = 519,
        /// <summary>Z3_OP_UMINUS</summary>
        OpUminus = 520,
        /// <summary>Z3_OP_MUL</summary>
        OpMul = 521,
        /// <summary>Z3_OP_DIV</summary>
        OpDiv = 522,
        /// <summary>Z3_OP_IDIV</summary>
        OpIdiv = 523,
        /// <summary>Z3_OP_REM</summary>
        OpRem = 524,
        /// <summary>Z3_OP_MOD</summary>
        OpMod = 525,
        /// <summary>Z3_OP_TO_REAL</summary>
        OpToReal = 526,
        /// <summary>Z3_OP_TO_INT</summary>
        OpToInt = 527,
        /// <summary>Z3_OP_IS_INT</summary>
        OpIsInt = 528,
        /// <summary>Z3_OP_POWER</summary>
        OpPower = 529,
        /// <summary>Z3_OP_ABS</summary>
        OpAbs = 530,
        /// <summary>Z3_OP_STORE</summary>
        OpStore = 0x300,
        /// <summary>Z3_OP_SELECT</summary>
        OpSelect = 769,
        /// <summary>Z3_OP_CONST_ARRAY</summary>
        OpConstArray = 770,
        /// <summary>Z3_OP_ARRAY_MAP</summary>
        OpArrayMap = 771,
        /// <summary>Z3_OP_ARRAY_DEFAULT</summary>
        OpArrayDefault = 772,
        /// <summary>Z3_OP_SET_UNION</summary>
        OpSetUnion = 773,
        /// <summary>Z3_OP_SET_INTERSECT</summary>
        OpSetIntersect = 774,
        /// <summary>Z3_OP_SET_DIFFERENCE</summary>
        OpSetDifference = 775,
        /// <summary>Z3_OP_SET_COMPLEMENT</summary>
        OpSetComplement = 776,
        /// <summary>Z3_OP_SET_SUBSET</summary>
        OpSetSubset = 777,
        /// <summary>Z3_OP_AS_ARRAY</summary>
        OpAsArray = 778,
        /// <summary>Z3_OP_ARRAY_EXT</summary>
        OpArrayExt = 779,
        /// <summary>Z3_OP_SET_HAS_SIZE</summary>
        OpSetHasSize = 780,
        /// <summary>Z3_OP_SET_CARD</summary>
        OpSetCard = 781,
        /// <summary>Z3_OP_BNUM</summary>
        OpBnum = 0x400,
        /// <summary>Z3_OP_BIT1</summary>
        OpBit1 = 1025,
        /// <summary>Z3_OP_BIT0</summary>
        OpBit0 = 1026,
        /// <summary>Z3_OP_BNEG</summary>
        OpBneg = 1027,
        /// <summary>Z3_OP_BADD</summary>
        OpBadd = 1028,
        /// <summary>Z3_OP_BSUB</summary>
        OpBsub = 1029,
        /// <summary>Z3_OP_BMUL</summary>
        OpBmul = 1030,
        /// <summary>Z3_OP_BSDIV</summary>
        OpBsdiv = 1031,
        /// <summary>Z3_OP_BUDIV</summary>
        OpBudiv = 1032,
        /// <summary>Z3_OP_BSREM</summary>
        OpBsrem = 1033,
        /// <summary>Z3_OP_BUREM</summary>
        OpBurem = 1034,
        /// <summary>Z3_OP_BSMOD</summary>
        OpBsmod = 1035,
        /// <summary>Z3_OP_BSDIV0</summary>
        OpBsdiv0 = 1036,
        /// <summary>Z3_OP_BUDIV0</summary>
        OpBudiv0 = 1037,
        /// <summary>Z3_OP_BSREM0</summary>
        OpBsrem0 = 1038,
        /// <summary>Z3_OP_BUREM0</summary>
        OpBurem0 = 1039,
        /// <summary>Z3_OP_BSMOD0</summary>
        OpBsmod0 = 1040,
        /// <summary>Z3_OP_ULEQ</summary>
        OpUleq = 1041,
        /// <summary>Z3_OP_SLEQ</summary>
        OpSleq = 1042,
        /// <summary>Z3_OP_UGEQ</summary>
        OpUgeq = 1043,
        /// <summary>Z3_OP_SGEQ</summary>
        OpSgeq = 1044,
        /// <summary>Z3_OP_ULT</summary>
        OpUlt = 1045,
        /// <summary>Z3_OP_SLT</summary>
        OpSlt = 1046,
        /// <summary>Z3_OP_UGT</summary>
        OpUgt = 1047,
        /// <summary>Z3_OP_SGT</summary>
        OpSgt = 1048,
        /// <summary>Z3_OP_BAND</summary>
        OpBand = 1049,
        /// <summary>Z3_OP_BOR</summary>
        OpBor = 1050,
        /// <summary>Z3_OP_BNOT</summary>
        OpBnot = 1051,
        /// <summary>Z3_OP_BXOR</summary>
        OpBxor = 1052,
        /// <summary>Z3_OP_BNAND</summary>
        OpBnand = 1053,
        /// <summary>Z3_OP_BNOR</summary>
        OpBnor = 1054,
        /// <summary>Z3_OP_BXNOR</summary>
        OpBxnor = 1055,
        /// <summary>Z3_OP_CONCAT</summary>
        OpConcat = 1056,
        /// <summary>Z3_OP_SIGN_EXT</summary>
        OpSignExt = 1057,
        /// <summary>Z3_OP_ZERO_EXT</summary>
        OpZeroExt = 1058,
        /// <summary>Z3_OP_EXTRACT</summary>
        OpExtract = 1059,
        /// <summary>Z3_OP_REPEAT</summary>
        OpRepeat = 1060,
        /// <summary>Z3_OP_BREDOR</summary>
        OpBredor = 1061,
        /// <summary>Z3_OP_BREDAND</summary>
        OpBredand = 1062,
        /// <summary>Z3_OP_BCOMP</summary>
        OpBcomp = 1063,
        /// <summary>Z3_OP_BSHL</summary>
        OpBshl = 1064,
        /// <summary>Z3_OP_BLSHR</summary>
        OpBlshr = 1065,
        /// <summary>Z3_OP_BASHR</summary>
        OpBashr = 1066,
        /// <summary>Z3_OP_ROTATE_LEFT</summary>
        OpRotateLeft = 1067,
        /// <summary>Z3_OP_ROTATE_RIGHT</summary>
        OpRotateRight = 1068,
        /// <summary>Z3_OP_EXT_ROTATE_LEFT</summary>
        OpExtRotateLeft = 1069,
        /// <summary>Z3_OP_EXT_ROTATE_RIGHT</summary>
        OpExtRotateRight = 1070,
        /// <summary>Z3_OP_BIT2BOOL</summary>
        OpBit2bool = 1071,
        /// <summary>Z3_OP_INT2BV</summary>
        OpInt2bv = 1072,
        /// <summary>Z3_OP_BV2INT</summary>
        OpBv2int = 1073,
        /// <summary>Z3_OP_SBV2INT</summary>
        OpSbv2int = 1074,
        /// <summary>Z3_OP_CARRY</summary>
        OpCarry = 1075,
        /// <summary>Z3_OP_XOR3</summary>
        OpXor3 = 1076,
        /// <summary>
        /// Z3_OP_BSMUL_NO_OVFL
        /// </summary>
        /// <remarks>
        /// a predicate to check that bit-wise signed multiplication does not overflow.
        /// Signed multiplication overflows if the operands have the same sign and the result of multiplication
        /// does not fit within the available bits. \sa Z3_mk_bvmul_no_overflow.
        /// </remarks>
        OpBsmulNoOvfl = 1077,
        /// <summary>
        /// Z3_OP_BUMUL_NO_OVFL
        /// </summary>
        /// <remarks>
        /// check that bit-wise unsigned multiplication does not overflow.
        /// Unsigned multiplication overflows if the result does not fit within the available bits.
        /// \sa Z3_mk_bvmul_no_overflow.
        /// </remarks>
        OpBumulNoOvfl = 1078,
        /// <summary>
        /// Z3_OP_BSMUL_NO_UDFL
        /// </summary>
        /// <remarks>
        /// check that bit-wise signed multiplication does not underflow.
        /// Signed multiplication underflows if the operands have opposite signs and the result of multiplication
        /// does not fit within the available bits. Z3_mk_bvmul_no_underflow.
        /// </remarks>
        OpBsmulNoUdfl = 1079,
        /// <summary>
        /// Z3_OP_BSDIV_I
        /// </summary>
        /// <remarks>
        /// Binary signed division.
        /// It has the same semantics as Z3_OP_BSDIV, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBsdivI = 1080,
        /// <summary>
        /// Z3_OP_BUDIV_I
        /// </summary>
        /// <remarks>
        /// Binary unsigned division.
        /// It has the same semantics as Z3_OP_BUDIV, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBudivI = 1081,
        /// <summary>
        /// Z3_OP_BSREM_I
        /// </summary>
        /// <remarks>
        /// Binary signed remainder.
        /// It has the same semantics as Z3_OP_BSREM, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBsremI = 1082,
        /// <summary>
        /// Z3_OP_BUREM_I
        /// </summary>
        /// <remarks>
        /// Binary unsigned remainder.
        /// It has the same semantics as Z3_OP_BUREM, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBuremI = 1083,
        /// <summary>
        /// Z3_OP_BSMOD_I
        /// </summary>
        /// <remarks>
        /// Binary signed modulus.
        /// It has the same semantics as Z3_OP_BSMOD, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBsmodI = 1084,
        /// <summary>
        /// Z3_OP_PR_UNDEF
        /// </summary>
        /// <remarks>
        /// Undef/Null proof object.
        /// </remarks>
        OpPrUndef = 0x500,
        /// <summary>
        /// Z3_OP_PR_TRUE
        /// </summary>
        /// <remarks>
        /// Proof for the expression 'true'.
        /// </remarks>
        OpPrTrue = 1281,
        /// <summary>
        /// Z3_OP_PR_ASSERTED
        /// </summary>
        /// <remarks>
        /// Proof for a fact asserted by the user.
        /// </remarks>
        OpPrAsserted = 1282,
        /// <summary>
        /// Z3_OP_PR_GOAL
        /// </summary>
        /// <remarks>
        /// Proof for a fact (tagged as goal) asserted by the user.
        /// </remarks>
        OpPrGoal = 1283,
        /// <summary>
        /// Z3_OP_PR_MODUS_PONENS
        /// </summary>
        /// <remarks>
        /// Given a proof for p and a proof for (implies p q), produces a proof for q.
        /// T1: p
        /// T2: (implies p q)
        /// [mp T1 T2]: q
        /// The second antecedents may also be a proof for (iff p q).
        /// </remarks>
        OpPrModusPonens = 1284,
        /// <summary>
        /// Z3_OP_PR_REFLEXIVITY
        /// </summary>
        /// <remarks>
        /// A proof for (R t t), where R is a reflexive relation. This proof object has no antecedents.
        /// The only reflexive relations that are used are
        /// equivalence modulo namings, equality and equivalence.
        /// That is, R is either '~', '=' or 'iff'.
        /// </remarks>
        OpPrReflexivity = 1285,
        /// <summary>
        /// Z3_OP_PR_SYMMETRY
        /// </summary>
        /// <remarks>
        /// Given an symmetric relation R and a proof for (R t s), produces a proof for (R s t).
        /// <code>
        /// ╔════════════════════════╗
        /// ║ T1: (R t s)            ║
        /// ║ [symmetry T1]: (R s t) ║
        /// ╚════════════════════════╝
        /// </code>
        /// T1 is the antecedent of this proof object.
        /// </remarks>
        OpPrSymmetry = 1286,
        /// <summary>
        /// Z3_OP_PR_TRANSITIVITY
        /// </summary>
        /// <remarks>
        /// Given a transitive relation R, and proofs for (R t s) and (R s u), produces a proof
        /// for (R t u).
        /// <code>
        /// ╔════════════════════════╗
        /// ║ T1: (R t s)            ║
        /// ║ T2: (R s u)            ║
        /// ║ [trans T1 T2]: (R t u) ║
        /// ╚════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrTransitivity = 1287,
        /// <summary>
        /// Z3_OP_PR_TRANSITIVITY_STAR
        /// </summary>
        /// <remarks>
        /// Condensed transitivity proof.
        /// It combines several symmetry and transitivity proofs. Example:
        /// <code>
        /// ╔════════════════════════════╗
        /// ║ T1: (R a b)                ║
        /// ║ T2: (R c b)                ║
        /// ║ T3: (R c d)                ║
        /// ║ [trans* T1 T2 T3]: (R a d) ║
        /// ╚════════════════════════════╝
        /// </code>
        /// R must be a symmetric and transitive relation.
        /// Assuming that this proof object is a proof for (R s t), then
        /// a proof checker must check if it is possible to prove (R s t)
        /// using the antecedents, symmetry and transitivity.  That is,
        /// if there is a path from s to t, if we view every
        /// antecedent (R a b) as an edge between a and b.
        /// </remarks>
        OpPrTransitivityStar = 1288,
        /// <summary>
        /// Z3_OP_PR_MONOTONICITY
        /// </summary>
        /// <remarks>
        /// Monotonicity proof object.
        /// T1: (R t_1 s_1)
        /// ...
        /// Tn: (R t_n s_n)
        /// [monotonicity T1 ... Tn]: (R (f t_1 ... t_n) (f s_1 ... s_n))
        /// Remark: if t_i == s_i, then the antecedent Ti is suppressed.
        /// That is, reflexivity proofs are suppressed to save space.
        /// </remarks>
        OpPrMonotonicity = 1289,
        /// <summary>
        /// Z3_OP_PR_QUANT_INTRO
        /// </summary>
        /// <remarks>
        /// Given a proof for (~ p q), produces a proof for (~ (forall (x) p) (forall (x) q)).
        /// T1: (~ p q)
        /// [quant-intro T1]: (~ (forall (x) p) (forall (x) q))
        /// </remarks>
        OpPrQuantIntro = 1290,
        /// <summary>
        /// Z3_OP_PR_BIND
        /// </summary>
        /// <remarks>
        /// Given a proof p, produces a proof of lambda x . p, where x are free variables in p.
        /// T1: f
        /// [proof-bind T1] forall (x) f
        /// </remarks>
        OpPrBind = 1291,
        /// <summary>
        /// Z3_OP_PR_DISTRIBUTIVITY
        /// </summary>
        /// <remarks>
        /// Distributivity proof object.
        /// Given that f (= or) distributes over g (= and), produces a proof for
        /// <code>
        /// ╔══════════════════════╗
        /// ║ (= (f a (g c d))     ║
        /// ║ (g (f a c) (f a d))) ║
        /// ╚══════════════════════╝
        /// </code>
        /// If f and g are associative, this proof also justifies the following equality:
        /// <code>
        /// ╔══════════════════════════════════════╗
        /// ║ (= (f (g a b) (g c d))               ║
        /// ║ (g (f a c) (f a d) (f b c) (f b d))) ║
        /// ╚══════════════════════════════════════╝
        /// </code>
        /// where each f and g can have arbitrary number of arguments.
        /// This proof object has no antecedents.
        /// Remark. This rule is used by the CNF conversion pass and
        /// instantiated by f = or, and g = and.
        /// </remarks>
        OpPrDistributivity = 1292,
        /// <summary>
        /// Z3_OP_PR_AND_ELIM
        /// </summary>
        /// <remarks>
        /// Given a proof for (and l_1 ... l_n), produces a proof for l_i
        /// T1: (and l_1 ... l_n)
        /// [and-elim T1]: l_i
        /// </remarks>
        OpPrAndElim = 1293,
        /// <summary>
        /// Z3_OP_PR_NOT_OR_ELIM
        /// </summary>
        /// <remarks>
        /// Given a proof for (not (or l_1 ... l_n)), produces a proof for (not l_i).
        /// T1: (not (or l_1 ... l_n))
        /// [not-or-elim T1]: (not l_i)
        /// </remarks>
        OpPrNotOrElim = 1294,
        /// <summary>
        /// Z3_OP_PR_REWRITE
        /// </summary>
        /// <remarks>
        /// A proof for a local rewriting step (= t s).
        /// The head function symbol of t is interpreted.
        /// This proof object has no antecedents.
        /// The conclusion of a rewrite rule is either an equality (= t s),
        /// an equivalence (iff t s), or equi-satisfiability (~ t s).
        /// Remark: if f is bool, then = is iff.
        /// Examples:
        /// <code>
        /// ╔═══════════════════════╗
        /// ║ (= (+ x 0) x)         ║
        /// ║ (= (+ x 1 2) (+ 3 x)) ║
        /// ║ (iff (or x false) x)  ║
        /// ╚═══════════════════════╝
        /// </code>
        /// </remarks>
        OpPrRewrite = 1295,
        /// <summary>
        /// Z3_OP_PR_REWRITE_STAR
        /// </summary>
        /// <remarks>
        /// A proof for rewriting an expression t into an expression s.
        /// This proof object can have n antecedents.
        /// The antecedents are proofs for equalities used as substitution rules.
        /// The proof rule is used in a few cases. The cases are:
        /// - When applying contextual simplification (CONTEXT_SIMPLIFIER=true)
        /// - When converting bit-vectors to Booleans (BIT2BOOL=true)
        /// </remarks>
        OpPrRewriteStar = 1296,
        /// <summary>
        /// Z3_OP_PR_PULL_QUANT
        /// </summary>
        /// <remarks>
        /// A proof for (iff (f (forall (x) q(x)) r) (forall (x) (f (q x) r))). This proof object has no antecedents.
        /// </remarks>
        OpPrPullQuant = 1297,
        /// <summary>
        /// Z3_OP_PR_PUSH_QUANT
        /// </summary>
        /// <remarks>
        /// A proof for:
        /// <code>
        /// ╔═════════════════════════════════════════════════════════════════════════╗
        /// ║ (iff (forall (x_1 ... x_m) (and p_1[x_1 ... x_m] ... p_n[x_1 ... x_m])) ║
        /// ║ (and (forall (x_1 ... x_m) p_1[x_1 ... x_m])                            ║
        /// ║ ...                                                                     ║
        /// ║ (forall (x_1 ... x_m) p_n[x_1 ... x_m])))                               ║
        /// ╚═════════════════════════════════════════════════════════════════════════╝
        /// </code>
        /// This proof object has no antecedents.
        /// </remarks>
        OpPrPushQuant = 1298,
        /// <summary>
        /// Z3_OP_PR_ELIM_UNUSED_VARS
        /// </summary>
        /// <remarks>
        /// A proof for (iff (forall (x_1 ... x_n y_1 ... y_m) p[x_1 ... x_n])
        /// (forall (x_1 ... x_n) p[x_1 ... x_n]))
        /// It is used to justify the elimination of unused variables.
        /// This proof object has no antecedents.
        /// </remarks>
        OpPrElimUnusedVars = 1299,
        /// <summary>
        /// Z3_OP_PR_DER
        /// </summary>
        /// <remarks>
        /// A proof for destructive equality resolution:
        /// (iff (forall (x) (or (not (= x t)) P[x])) P[t])
        /// if x does not occur in t.
        /// This proof object has no antecedents.
        /// Several variables can be eliminated simultaneously.
        /// </remarks>
        OpPrDer = 1300,
        /// <summary>
        /// Z3_OP_PR_QUANT_INST
        /// </summary>
        /// <remarks>
        /// A proof of (or (not (forall (x) (P x))) (P a))
        /// </remarks>
        OpPrQuantInst = 1301,
        /// <summary>
        /// Z3_OP_PR_HYPOTHESIS
        /// </summary>
        /// <remarks>
        /// Mark a hypothesis in a natural deduction style proof.
        /// </remarks>
        OpPrHypothesis = 1302,
        /// <summary>
        /// Z3_OP_PR_LEMMA
        /// </summary>
        /// <remarks>
        /// T1: false
        /// [lemma T1]: (or (not l_1) ... (not l_n))
        /// This proof object has one antecedent: a hypothetical proof for false.
        /// It converts the proof in a proof for (or (not l_1) ... (not l_n)),
        /// when T1 contains the open hypotheses: l_1, ..., l_n.
        /// The hypotheses are closed after an application of a lemma.
        /// Furthermore, there are no other open hypotheses in the subtree covered by
        /// the lemma.
        /// </remarks>
        OpPrLemma = 1303,
        /// <summary>
        /// Z3_OP_PR_UNIT_RESOLUTION
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═════════════════════════════════════════════════════╗
        /// ║ T1:      (or l_1 ... l_n l_1' ... l_m')             ║
        /// ║ T2:      (not l_1)                                  ║
        /// ║ ...                                                 ║
        /// ║ T(n+1):  (not l_n)                                  ║
        /// ║ [unit-resolution T1 ... T(n+1)]: (or l_1' ... l_m') ║
        /// ╚═════════════════════════════════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrUnitResolution = 1304,
        /// <summary>
        /// Z3_OP_PR_IFF_TRUE
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═════════════════════════════╗
        /// ║ T1: p                       ║
        /// ║ [iff-true T1]: (iff p true) ║
        /// ╚═════════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrIffTrue = 1305,
        /// <summary>
        /// Z3_OP_PR_IFF_FALSE
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═══════════════════════════════╗
        /// ║ T1: (not p)                   ║
        /// ║ [iff-false T1]: (iff p false) ║
        /// ╚═══════════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrIffFalse = 1306,
        /// <summary>
        /// Z3_OP_PR_COMMUTATIVITY
        /// </summary>
        /// <remarks>
        /// [comm]: (= (f a b) (f b a))
        /// f is a commutative operator.
        /// This proof object has no antecedents.
        /// Remark: if f is bool, then = is iff.
        /// </remarks>
        OpPrCommutativity = 1307,
        /// <summary>
        /// Z3_OP_PR_DEF_AXIOM
        /// </summary>
        /// <remarks>
        /// Proof object used to justify Tseitin's like axioms:
        /// <code>
        /// ╔══════════════════════════════════╗
        /// ║ (or (not (and p q)) p)           ║
        /// ║ (or (not (and p q)) q)           ║
        /// ║ (or (not (and p q r)) p)         ║
        /// ║ (or (not (and p q r)) q)         ║
        /// ║ (or (not (and p q r)) r)         ║
        /// ║ ...                              ║
        /// ║ (or (and p q) (not p) (not q))   ║
        /// ║ (or (not (or p q)) p q)          ║
        /// ║ (or (or p q) (not p))            ║
        /// ║ (or (or p q) (not q))            ║
        /// ║ (or (not (iff p q)) (not p) q)   ║
        /// ║ (or (not (iff p q)) p (not q))   ║
        /// ║ (or (iff p q) (not p) (not q))   ║
        /// ║ (or (iff p q) p q)               ║
        /// ║ (or (not (ite a b c)) (not a) b) ║
        /// ║ (or (not (ite a b c)) a c)       ║
        /// ║ (or (ite a b c) (not a) (not b)) ║
        /// ║ (or (ite a b c) a (not c))       ║
        /// ║ (or (not (not a)) (not a))       ║
        /// ║ (or (not a) a)                   ║
        /// ╚══════════════════════════════════╝
        /// </code>
        /// This proof object has no antecedents.
        /// Note: all axioms are propositional tautologies.
        /// Note also that 'and' and 'or' can take multiple arguments.
        /// You can recover the propositional tautologies by
        /// unfolding the Boolean connectives in the axioms a small
        /// bounded number of steps (=3).
        /// </remarks>
        OpPrDefAxiom = 1308,
        /// <summary>Z3_OP_PR_ASSUMPTION_ADD</summary>
        OpPrAssumptionAdd = 1309,
        /// <summary>Z3_OP_PR_LEMMA_ADD</summary>
        OpPrLemmaAdd = 1310,
        /// <summary>Z3_OP_PR_REDUNDANT_DEL</summary>
        OpPrRedundantDel = 1311,
        /// <summary>Z3_OP_PR_CLAUSE_TRAIL</summary>
        OpPrClauseTrail = 1312,
        /// <summary>
        /// Z3_OP_PR_DEF_INTRO
        /// </summary>
        /// <remarks>
        /// Introduces a name for a formula/term.
        /// Suppose e is an expression with free variables x, and def-intro
        /// introduces the name n(x). The possible cases are:
        /// When e is of Boolean type:
        /// [def-intro]: (and (or n (not e)) (or (not n) e))
        /// or:
        /// [def-intro]: (or (not n) e)
        /// when e only occurs positively.
        /// When e is of the form (ite cond th el):
        /// [def-intro]: (and (or (not cond) (= n th)) (or cond (= n el)))
        /// Otherwise:
        /// [def-intro]: (= n e)
        /// </remarks>
        OpPrDefIntro = 1313,
        /// <summary>
        /// Z3_OP_PR_APPLY_DEF
        /// </summary>
        /// <remarks>
        /// [apply-def T1]: F ~ n
        /// F is 'equivalent' to n, given that T1 is a proof that
        /// n is a name for F.
        /// </remarks>
        OpPrApplyDef = 1314,
        /// <summary>
        /// Z3_OP_PR_IFF_OEQ
        /// </summary>
        /// <remarks>
        /// T1: (iff p q)
        /// [iff~ T1]: (~ p q)
        /// </remarks>
        OpPrIffOeq = 1315,
        /// <summary>
        /// Z3_OP_PR_NNF_POS
        /// </summary>
        /// <remarks>
        /// Proof for a (positive) NNF step. Example:
        /// T1: (not s_1) ~ r_1
        /// T2: (not s_2) ~ r_2
        /// T3: s_1 ~ r_1'
        /// T4: s_2 ~ r_2'
        /// [nnf-pos T1 T2 T3 T4]: (~ (iff s_1 s_2) (and (or r_1 r_2') (or r_1' r_2)))
        /// The negation normal form steps NNF_POS and NNF_NEG are used in the following cases:
        /// (a) When creating the NNF of a positive force quantifier.
        /// The quantifier is retained (unless the bound variables are eliminated).
        /// Example
        /// T1: q ~ q_new
        /// [nnf-pos T1]: (~ (forall (x T) q) (forall (x T) q_new))
        /// (b) When recursively creating NNF over Boolean formulas, where the top-level
        /// connective is changed during NNF conversion. The relevant Boolean connectives
        /// for NNF_POS are 'implies', 'iff', 'xor', 'ite'.
        /// NNF_NEG furthermore handles the case where negation is pushed
        /// over Boolean connectives 'and' and 'or'.
        /// </remarks>
        OpPrNnfPos = 1316,
        /// <summary>
        /// Z3_OP_PR_NNF_NEG
        /// </summary>
        /// <remarks>
        /// Proof for a (negative) NNF step. Examples:
        /// T1: (not s_1) ~ r_1
        /// ...
        /// Tn: (not s_n) ~ r_n
        /// [nnf-neg T1 ... Tn]: (not (and s_1 ... s_n)) ~ (or r_1 ... r_n)
        /// and
        /// T1: (not s_1) ~ r_1
        /// ...
        /// Tn: (not s_n) ~ r_n
        /// [nnf-neg T1 ... Tn]: (not (or s_1 ... s_n)) ~ (and r_1 ... r_n)
        /// and
        /// T1: (not s_1) ~ r_1
        /// T2: (not s_2) ~ r_2
        /// T3: s_1 ~ r_1'
        /// T4: s_2 ~ r_2'
        /// [nnf-neg T1 T2 T3 T4]: (~ (not (iff s_1 s_2))
        /// (and (or r_1 r_2) (or r_1' r_2')))
        /// </remarks>
        OpPrNnfNeg = 1317,
        /// <summary>
        /// Z3_OP_PR_SKOLEMIZE
        /// </summary>
        /// <remarks>
        /// Proof for:
        /// [sk]: (~ (not (forall x (p x y))) (not (p (sk y) y)))
        /// [sk]: (~ (exists x (p x y)) (p (sk y) y))
        /// This proof object has no antecedents.
        /// </remarks>
        OpPrSkolemize = 1318,
        /// <summary>
        /// Z3_OP_PR_MODUS_PONENS_OEQ
        /// </summary>
        /// <remarks>
        /// Modus ponens style rule for equi-satisfiability.
        /// T1: p
        /// T2: (~ p q)
        /// [mp~ T1 T2]: q
        /// </remarks>
        OpPrModusPonensOeq = 1319,
        /// <summary>
        /// Z3_OP_PR_TH_LEMMA
        /// </summary>
        /// <remarks>
        /// Generic proof for theory lemmas.
        /// The theory lemma function comes with one or more parameters.
        /// The first parameter indicates the name of the theory.
        /// For the theory of arithmetic, additional parameters provide hints for
        /// checking the theory lemma.
        /// The hints for arithmetic are:
        /// - farkas - followed by rational coefficients. Multiply the coefficients to the
        /// inequalities in the lemma, add the (negated) inequalities and obtain a contradiction.
        /// - triangle-eq - Indicates a lemma related to the equivalence:
        /// (iff (= t1 t2) (and (&lt;= t1 t2) (&lt;= t2 t1)))
        /// - gcd-test - Indicates an integer linear arithmetic lemma that uses a gcd test.
        /// </remarks>
        OpPrThLemma = 1320,
        /// <summary>
        /// Z3_OP_PR_HYPER_RESOLVE
        /// </summary>
        /// <remarks>
        /// Hyper-resolution rule.
        /// The premises of the rules is a sequence of clauses.
        /// The first clause argument is the main clause of the rule.
        /// with a literal from the first (main) clause.
        /// Premises of the rules are of the form
        /// <code>
        /// ╔═════════════════════╗
        /// ║ (or l0 l1 l2 .. ln) ║
        /// ╚═════════════════════╝
        /// </code>
        /// or
        /// <code>
        /// ╔═══════════════════════════╗
        /// ║ (=> (and l1 l2 .. ln) l0) ║
        /// ╚═══════════════════════════╝
        /// </code>
        /// or in the most general (ground) form:
        /// <code>
        /// ╔═══════════════════════════════════════════════╗
        /// ║ (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln)) ║
        /// ╚═══════════════════════════════════════════════╝
        /// </code>
        /// In other words we use the following (Prolog style) convention for Horn
        /// implications:
        /// The head of a Horn implication is position 0,
        /// the first conjunct in the body of an implication is position 1
        /// the second conjunct in the body of an implication is position 2
        /// For general implications where the head is a disjunction, the
        /// first n positions correspond to the n disjuncts in the head.
        /// The next m positions correspond to the m conjuncts in the body.
        /// The premises can be universally quantified so that the most
        /// general non-ground form is:
        /// <code>
        /// ╔═══════════════════════════════════════════════════════════════╗
        /// ║ (forall (vars) (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln))) ║
        /// ╚═══════════════════════════════════════════════════════════════╝
        /// </code>
        /// The hyper-resolution rule takes a sequence of parameters.
        /// The parameters are substitutions of bound variables separated by pairs
        /// of literal positions from the main clause and side clause.
        /// </remarks>
        OpPrHyperResolve = 1321,
        /// <summary>
        /// Z3_OP_RA_STORE
        /// </summary>
        /// <remarks>
        /// Insert a record into a relation.
        /// The function takes n+1 arguments, where the first argument is the relation and the remaining n elements
        /// correspond to the n columns of the relation.
        /// </remarks>
        OpRaStore = 0x600,
        /// <summary>
        /// Z3_OP_RA_EMPTY
        /// </summary>
        /// <remarks>
        /// Creates the empty relation.
        /// </remarks>
        OpRaEmpty = 1537,
        /// <summary>
        /// Z3_OP_RA_IS_EMPTY
        /// </summary>
        /// <remarks>
        /// Tests if the relation is empty.
        /// </remarks>
        OpRaIsEmpty = 1538,
        /// <summary>
        /// Z3_OP_RA_JOIN
        /// </summary>
        /// <remarks>
        /// Create the relational join.
        /// </remarks>
        OpRaJoin = 1539,
        /// <summary>
        /// Z3_OP_RA_UNION
        /// </summary>
        /// <remarks>
        /// Create the union or convex hull of two relations.
        /// The function takes two arguments.
        /// </remarks>
        OpRaUnion = 1540,
        /// <summary>
        /// Z3_OP_RA_WIDEN
        /// </summary>
        /// <remarks>
        /// Widen two relations.
        /// The function takes two arguments.
        /// </remarks>
        OpRaWiden = 1541,
        /// <summary>
        /// Z3_OP_RA_PROJECT
        /// </summary>
        /// <remarks>
        /// Project the columns (provided as numbers in the parameters).
        /// The function takes one argument.
        /// </remarks>
        OpRaProject = 1542,
        /// <summary>
        /// Z3_OP_RA_FILTER
        /// </summary>
        /// <remarks>
        /// Filter (restrict) a relation with respect to a predicate.
        /// The first argument is a relation.
        /// The second argument is a predicate with free de-Bruijn indices
        /// corresponding to the columns of the relation.
        /// So the first column in the relation has index 0.
        /// </remarks>
        OpRaFilter = 1543,
        /// <summary>
        /// Z3_OP_RA_NEGATION_FILTER
        /// </summary>
        /// <remarks>
        /// Intersect the first relation with respect to negation
        /// of the second relation (the function takes two arguments).
        /// Logically, the specification can be described by a function
        /// target = filter_by_negation(pos, neg, columns)
        /// where columns are pairs c1, d1, .., cN, dN of columns from pos and neg, such that
        /// target are elements in x in pos, such that there is no y in neg that agrees with
        /// x on the columns c1, d1, .., cN, dN.
        /// </remarks>
        OpRaNegationFilter = 1544,
        /// <summary>
        /// Z3_OP_RA_RENAME
        /// </summary>
        /// <remarks>
        /// rename columns in the relation.
        /// The function takes one argument.
        /// The parameters contain the renaming as a cycle.
        /// </remarks>
        OpRaRename = 1545,
        /// <summary>
        /// Z3_OP_RA_COMPLEMENT
        /// </summary>
        /// <remarks>
        /// Complement the relation.
        /// </remarks>
        OpRaComplement = 1546,
        /// <summary>
        /// Z3_OP_RA_SELECT
        /// </summary>
        /// <remarks>
        /// Check if a record is an element of the relation.
        /// The function takes n+1 arguments, where the first argument is a relation,
        /// and the remaining n arguments correspond to a record.
        /// </remarks>
        OpRaSelect = 1547,
        /// <summary>
        /// Z3_OP_RA_CLONE
        /// </summary>
        /// <remarks>
        /// Create a fresh copy (clone) of a relation.
        /// The function is logically the identity, but
        /// in the context of a register machine allows
        /// for <see cref="OpRaUnion"/> to perform destructive updates to the first argument.
        /// </remarks>
        OpRaClone = 1548,
        /// <summary>Z3_OP_FD_CONSTANT</summary>
        OpFdConstant = 1549,
        /// <summary>
        /// Z3_OP_FD_LT
        /// </summary>
        /// <remarks>
        /// A less than predicate over the finite domain Z3_FINITE_DOMAIN_SORT.
        /// </remarks>
        OpFdLt = 1550,
        /// <summary>Z3_OP_SEQ_UNIT</summary>
        OpSeqUnit = 1551,
        /// <summary>Z3_OP_SEQ_EMPTY</summary>
        OpSeqEmpty = 1552,
        /// <summary>Z3_OP_SEQ_CONCAT</summary>
        OpSeqConcat = 1553,
        /// <summary>Z3_OP_SEQ_PREFIX</summary>
        OpSeqPrefix = 1554,
        /// <summary>Z3_OP_SEQ_SUFFIX</summary>
        OpSeqSuffix = 1555,
        /// <summary>Z3_OP_SEQ_CONTAINS</summary>
        OpSeqContains = 1556,
        /// <summary>Z3_OP_SEQ_EXTRACT</summary>
        OpSeqExtract = 1557,
        /// <summary>Z3_OP_SEQ_REPLACE</summary>
        OpSeqReplace = 1558,
        /// <summary>Z3_OP_SEQ_REPLACE_RE</summary>
        OpSeqReplaceRe = 1559,
        /// <summary>Z3_OP_SEQ_REPLACE_RE_ALL</summary>
        OpSeqReplaceReAll = 1560,
        /// <summary>Z3_OP_SEQ_REPLACE_ALL</summary>
        OpSeqReplaceAll = 1561,
        /// <summary>Z3_OP_SEQ_AT</summary>
        OpSeqAt = 1562,
        /// <summary>Z3_OP_SEQ_NTH</summary>
        OpSeqNth = 1563,
        /// <summary>Z3_OP_SEQ_LENGTH</summary>
        OpSeqLength = 1564,
        /// <summary>Z3_OP_SEQ_INDEX</summary>
        OpSeqIndex = 1565,
        /// <summary>Z3_OP_SEQ_LAST_INDEX</summary>
        OpSeqLastIndex = 1566,
        /// <summary>Z3_OP_SEQ_TO_RE</summary>
        OpSeqToRe = 1567,
        /// <summary>Z3_OP_SEQ_IN_RE</summary>
        OpSeqInRe = 1568,
        /// <summary>Z3_OP_SEQ_MAP</summary>
        OpSeqMap = 1569,
        /// <summary>Z3_OP_SEQ_MAPI</summary>
        OpSeqMapi = 1570,
        /// <summary>Z3_OP_SEQ_FOLDL</summary>
        OpSeqFoldl = 1571,
        /// <summary>Z3_OP_SEQ_FOLDLI</summary>
        OpSeqFoldli = 1572,
        /// <summary>Z3_OP_STR_TO_INT</summary>
        OpStrToInt = 1573,
        /// <summary>Z3_OP_INT_TO_STR</summary>
        OpIntToStr = 1574,
        /// <summary>Z3_OP_UBV_TO_STR</summary>
        OpUbvToStr = 1575,
        /// <summary>Z3_OP_SBV_TO_STR</summary>
        OpSbvToStr = 1576,
        /// <summary>Z3_OP_STR_TO_CODE</summary>
        OpStrToCode = 1577,
        /// <summary>Z3_OP_STR_FROM_CODE</summary>
        OpStrFromCode = 1578,
        /// <summary>Z3_OP_STRING_LT</summary>
        OpStringLt = 1579,
        /// <summary>Z3_OP_STRING_LE</summary>
        OpStringLe = 1580,
        /// <summary>Z3_OP_RE_PLUS</summary>
        OpRePlus = 1581,
        /// <summary>Z3_OP_RE_STAR</summary>
        OpReStar = 1582,
        /// <summary>Z3_OP_RE_OPTION</summary>
        OpReOption = 1583,
        /// <summary>Z3_OP_RE_CONCAT</summary>
        OpReConcat = 1584,
        /// <summary>Z3_OP_RE_UNION</summary>
        OpReUnion = 1585,
        /// <summary>Z3_OP_RE_RANGE</summary>
        OpReRange = 1586,
        /// <summary>Z3_OP_RE_DIFF</summary>
        OpReDiff = 1587,
        /// <summary>Z3_OP_RE_INTERSECT</summary>
        OpReIntersect = 1588,
        /// <summary>Z3_OP_RE_LOOP</summary>
        OpReLoop = 1589,
        /// <summary>Z3_OP_RE_POWER</summary>
        OpRePower = 1590,
        /// <summary>Z3_OP_RE_COMPLEMENT</summary>
        OpReComplement = 1591,
        /// <summary>Z3_OP_RE_EMPTY_SET</summary>
        OpReEmptySet = 1592,
        /// <summary>Z3_OP_RE_FULL_SET</summary>
        OpReFullSet = 1593,
        /// <summary>Z3_OP_RE_FULL_CHAR_SET</summary>
        OpReFullCharSet = 1594,
        /// <summary>Z3_OP_RE_OF_PRED</summary>
        OpReOfPred = 1595,
        /// <summary>Z3_OP_RE_REVERSE</summary>
        OpReReverse = 1596,
        /// <summary>Z3_OP_RE_DERIVATIVE</summary>
        OpReDerivative = 1597,
        /// <summary>Z3_OP_CHAR_CONST</summary>
        OpCharConst = 1598,
        /// <summary>Z3_OP_CHAR_LE</summary>
        OpCharLe = 1599,
        /// <summary>Z3_OP_CHAR_TO_INT</summary>
        OpCharToInt = 1600,
        /// <summary>Z3_OP_CHAR_TO_BV</summary>
        OpCharToBv = 1601,
        /// <summary>Z3_OP_CHAR_FROM_BV</summary>
        OpCharFromBv = 1602,
        /// <summary>Z3_OP_CHAR_IS_DIGIT</summary>
        OpCharIsDigit = 1603,
        /// <summary>
        /// Z3_OP_LABEL
        /// </summary>
        /// <remarks>
        /// A label (used by the Boogie Verification condition generator).
        /// The label has two parameters, a string and a Boolean polarity.
        /// It takes one argument, a formula.
        /// </remarks>
        OpLabel = 0x700,
        /// <summary>
        /// Z3_OP_LABEL_LIT
        /// </summary>
        /// <remarks>
        /// A label literal (used by the Boogie Verification condition generator).
        /// A label literal has a set of string parameters. It takes no arguments.
        /// </remarks>
        OpLabelLit = 1793,
        /// <summary>
        /// Z3_OP_DT_CONSTRUCTOR
        /// </summary>
        /// <remarks>
        /// datatype constructor.
        /// </remarks>
        OpDtConstructor = 0x800,
        /// <summary>
        /// Z3_OP_DT_RECOGNISER
        /// </summary>
        /// <remarks>
        /// datatype recognizer.
        /// </remarks>
        OpDtRecogniser = 2049,
        /// <summary>
        /// Z3_OP_DT_IS
        /// </summary>
        /// <remarks>
        /// datatype recognizer.
        /// </remarks>
        OpDtIs = 2050,
        /// <summary>
        /// Z3_OP_DT_ACCESSOR
        /// </summary>
        /// <remarks>
        /// datatype accessor.
        /// </remarks>
        OpDtAccessor = 2051,
        /// <summary>
        /// Z3_OP_DT_UPDATE_FIELD
        /// </summary>
        /// <remarks>
        /// datatype field update.
        /// </remarks>
        OpDtUpdateField = 2052,
        /// <summary>
        /// Z3_OP_PB_AT_MOST
        /// </summary>
        /// <remarks>
        /// Cardinality constraint.
        /// E.g., x + y + z &lt;= 2
        /// </remarks>
        OpPbAtMost = 0x900,
        /// <summary>
        /// Z3_OP_PB_AT_LEAST
        /// </summary>
        /// <remarks>
        /// Cardinality constraint.
        /// E.g., x + y + z &gt;= 2
        /// </remarks>
        OpPbAtLeast = 2305,
        /// <summary>
        /// Z3_OP_PB_LE
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean cardinality constraint.
        /// Example  2*x + 3*y &lt;= 4
        /// </remarks>
        OpPbLe = 2306,
        /// <summary>
        /// Z3_OP_PB_GE
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean cardinality constraint.
        /// Example  2*x + 3*y + 2*z &gt;= 4
        /// </remarks>
        OpPbGe = 2307,
        /// <summary>
        /// Z3_OP_PB_EQ
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean equality constraint.
        /// Example  2*x + 1*y + 2*z + 1*u = 4
        /// </remarks>
        OpPbEq = 2308,
        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_LO
        /// </summary>
        /// <remarks>
        /// A relation that is a total linear order
        /// </remarks>
        OpSpecialRelationLo = 0xa000,
        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_PO
        /// </summary>
        /// <remarks>
        /// A relation that is a partial order
        /// </remarks>
        OpSpecialRelationPo = 40961,
        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_PLO
        /// </summary>
        /// <remarks>
        /// A relation that is a piecewise linear order
        /// </remarks>
        OpSpecialRelationPlo = 40962,
        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TO
        /// </summary>
        /// <remarks>
        /// A relation that is a tree order
        /// </remarks>
        OpSpecialRelationTo = 40963,
        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TC
        /// </summary>
        /// <remarks>
        /// Transitive closure of a relation
        /// </remarks>
        OpSpecialRelationTc = 40964,
        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TRC
        /// </summary>
        /// <remarks>
        /// Transitive reflexive closure of a relation
        /// </remarks>
        OpSpecialRelationTrc = 40965,
        /// <summary>
        /// Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RNE
        /// </remarks>
        OpFpaRmNearestTiesToEven = 0xb000,
        /// <summary>
        /// Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RNA
        /// </remarks>
        OpFpaRmNearestTiesToAway = 45057,
        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_POSITIVE
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTP
        /// </remarks>
        OpFpaRmTowardPositive = 45058,
        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_NEGATIVE
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTN
        /// </remarks>
        OpFpaRmTowardNegative = 45059,
        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTZ
        /// </remarks>
        OpFpaRmTowardZero = 45060,
        /// <summary>
        /// Z3_OP_FPA_NUM
        /// </summary>
        /// <remarks>
        /// Floating-point value
        /// </remarks>
        OpFpaNum = 45061,
        /// <summary>
        /// Z3_OP_FPA_PLUS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point +oo
        /// </remarks>
        OpFpaPlusInf = 45062,
        /// <summary>
        /// Z3_OP_FPA_MINUS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point -oo
        /// </remarks>
        OpFpaMinusInf = 45063,
        /// <summary>
        /// Z3_OP_FPA_NAN
        /// </summary>
        /// <remarks>
        /// Floating-point NaN
        /// </remarks>
        OpFpaNan = 45064,
        /// <summary>
        /// Z3_OP_FPA_PLUS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point +zero
        /// </remarks>
        OpFpaPlusZero = 45065,
        /// <summary>
        /// Z3_OP_FPA_MINUS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point -zero
        /// </remarks>
        OpFpaMinusZero = 45066,
        /// <summary>
        /// Z3_OP_FPA_ADD
        /// </summary>
        /// <remarks>
        /// Floating-point addition
        /// </remarks>
        OpFpaAdd = 45067,
        /// <summary>
        /// Z3_OP_FPA_SUB
        /// </summary>
        /// <remarks>
        /// Floating-point subtraction
        /// </remarks>
        OpFpaSub = 45068,
        /// <summary>
        /// Z3_OP_FPA_NEG
        /// </summary>
        /// <remarks>
        /// Floating-point negation
        /// </remarks>
        OpFpaNeg = 45069,
        /// <summary>
        /// Z3_OP_FPA_MUL
        /// </summary>
        /// <remarks>
        /// Floating-point multiplication
        /// </remarks>
        OpFpaMul = 45070,
        /// <summary>
        /// Z3_OP_FPA_DIV
        /// </summary>
        /// <remarks>
        /// Floating-point division
        /// </remarks>
        OpFpaDiv = 45071,
        /// <summary>
        /// Z3_OP_FPA_REM
        /// </summary>
        /// <remarks>
        /// Floating-point remainder
        /// </remarks>
        OpFpaRem = 45072,
        /// <summary>
        /// Z3_OP_FPA_ABS
        /// </summary>
        /// <remarks>
        /// Floating-point absolute value
        /// </remarks>
        OpFpaAbs = 45073,
        /// <summary>
        /// Z3_OP_FPA_MIN
        /// </summary>
        /// <remarks>
        /// Floating-point minimum
        /// </remarks>
        OpFpaMin = 45074,
        /// <summary>
        /// Z3_OP_FPA_MAX
        /// </summary>
        /// <remarks>
        /// Floating-point maximum
        /// </remarks>
        OpFpaMax = 45075,
        /// <summary>
        /// Z3_OP_FPA_FMA
        /// </summary>
        /// <remarks>
        /// Floating-point fused multiply-add
        /// </remarks>
        OpFpaFma = 45076,
        /// <summary>
        /// Z3_OP_FPA_SQRT
        /// </summary>
        /// <remarks>
        /// Floating-point square root
        /// </remarks>
        OpFpaSqrt = 45077,
        /// <summary>
        /// Z3_OP_FPA_ROUND_TO_INTEGRAL
        /// </summary>
        /// <remarks>
        /// Floating-point round to integral
        /// </remarks>
        OpFpaRoundToIntegral = 45078,
        /// <summary>
        /// Z3_OP_FPA_EQ
        /// </summary>
        /// <remarks>
        /// Floating-point equality
        /// </remarks>
        OpFpaEq = 45079,
        /// <summary>
        /// Z3_OP_FPA_LT
        /// </summary>
        /// <remarks>
        /// Floating-point less than
        /// </remarks>
        OpFpaLt = 45080,
        /// <summary>
        /// Z3_OP_FPA_GT
        /// </summary>
        /// <remarks>
        /// Floating-point greater than
        /// </remarks>
        OpFpaGt = 45081,
        /// <summary>
        /// Z3_OP_FPA_LE
        /// </summary>
        /// <remarks>
        /// Floating-point less than or equal
        /// </remarks>
        OpFpaLe = 45082,
        /// <summary>
        /// Z3_OP_FPA_GE
        /// </summary>
        /// <remarks>
        /// Floating-point greater than or equal
        /// </remarks>
        OpFpaGe = 45083,
        /// <summary>
        /// Z3_OP_FPA_IS_NAN
        /// </summary>
        /// <remarks>
        /// Floating-point isNaN
        /// </remarks>
        OpFpaIsNan = 45084,
        /// <summary>
        /// Z3_OP_FPA_IS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point isInfinite
        /// </remarks>
        OpFpaIsInf = 45085,
        /// <summary>
        /// Z3_OP_FPA_IS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point isZero
        /// </remarks>
        OpFpaIsZero = 45086,
        /// <summary>
        /// Z3_OP_FPA_IS_NORMAL
        /// </summary>
        /// <remarks>
        /// Floating-point isNormal
        /// </remarks>
        OpFpaIsNormal = 45087,
        /// <summary>
        /// Z3_OP_FPA_IS_SUBNORMAL
        /// </summary>
        /// <remarks>
        /// Floating-point isSubnormal
        /// </remarks>
        OpFpaIsSubnormal = 45088,
        /// <summary>
        /// Z3_OP_FPA_IS_NEGATIVE
        /// </summary>
        /// <remarks>
        /// Floating-point isNegative
        /// </remarks>
        OpFpaIsNegative = 45089,
        /// <summary>
        /// Z3_OP_FPA_IS_POSITIVE
        /// </summary>
        /// <remarks>
        /// Floating-point isPositive
        /// </remarks>
        OpFpaIsPositive = 45090,
        /// <summary>
        /// Z3_OP_FPA_FP
        /// </summary>
        /// <remarks>
        /// Floating-point constructor from 3 bit-vectors
        /// </remarks>
        OpFpaFp = 45091,
        /// <summary>
        /// Z3_OP_FPA_TO_FP
        /// </summary>
        /// <remarks>
        /// Floating-point conversion (various)
        /// </remarks>
        OpFpaToFp = 45092,
        /// <summary>
        /// Z3_OP_FPA_TO_FP_UNSIGNED
        /// </summary>
        /// <remarks>
        /// Floating-point conversion from unsigned bit-vector
        /// </remarks>
        OpFpaToFpUnsigned = 45093,
        /// <summary>
        /// Z3_OP_FPA_TO_UBV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to unsigned bit-vector
        /// </remarks>
        OpFpaToUbv = 45094,
        /// <summary>
        /// Z3_OP_FPA_TO_SBV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to signed bit-vector
        /// </remarks>
        OpFpaToSbv = 45095,
        /// <summary>
        /// Z3_OP_FPA_TO_REAL
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to real number
        /// </remarks>
        OpFpaToReal = 45096,
        /// <summary>
        /// Z3_OP_FPA_TO_IEEE_BV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to IEEE-754 bit-vector
        /// </remarks>
        OpFpaToIeeeBv = 45097,
        /// <summary>
        /// Z3_OP_FPA_BVWRAP
        /// </summary>
        /// <remarks>
        /// (Implicitly) represents the internal bitvector-
        /// representation of a floating-point term (used for the lazy encoding
        /// of non-relevant terms in theory_fpa)
        /// </remarks>
        OpFpaBvwrap = 45098,
        /// <summary>
        /// Z3_OP_FPA_BV2RM
        /// </summary>
        /// <remarks>
        /// Conversion of a 3-bit bit-vector term to a
        /// floating-point rounding-mode term
        /// The conversion uses the following values:
        /// 0 = 000 = Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN,
        /// 1 = 001 = Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY,
        /// 2 = 010 = Z3_OP_FPA_RM_TOWARD_POSITIVE,
        /// 3 = 011 = Z3_OP_FPA_RM_TOWARD_NEGATIVE,
        /// 4 = 100 = Z3_OP_FPA_RM_TOWARD_ZERO.
        /// </remarks>
        OpFpaBv2rm = 45099,
        /// <summary>
        /// Z3_OP_INTERNAL
        /// </summary>
        /// <remarks>
        /// internal (often interpreted) symbol, but no additional
        /// information is exposed. Tools may use the string representation of the
        /// function declaration to obtain more information.
        /// </remarks>
        OpInternal = 45100,
        /// <summary>
        /// Z3_OP_RECURSIVE
        /// </summary>
        /// <remarks>
        /// function declared as recursive
        /// </remarks>
        OpRecursive = 45101,
        /// <summary>Z3_OP_UNINTERPRETED</summary>
        OpUninterpreted = 45102,
    }

    /// <summary>
    /// Z3 error codes (See <see cref="GetErrorCode"/>).
    /// </summary>
    internal enum ErrorCode
    {
        /// <summary>
        /// Z3_OK
        /// </summary>
        /// <remarks>
        /// No error.
        /// </remarks>
        Ok = 0,
        /// <summary>
        /// Z3_SORT_ERROR
        /// </summary>
        /// <remarks>
        /// User tried to build an invalid (type incorrect) AST.
        /// </remarks>
        SortError = 1,
        /// <summary>
        /// Z3_IOB
        /// </summary>
        /// <remarks>
        /// Index out of bounds.
        /// </remarks>
        Iob = 2,
        /// <summary>
        /// Z3_INVALID_ARG
        /// </summary>
        /// <remarks>
        /// Invalid argument was provided.
        /// </remarks>
        InvalidArg = 3,
        /// <summary>
        /// Z3_PARSER_ERROR
        /// </summary>
        /// <remarks>
        /// An error occurred when parsing a string or file.
        /// </remarks>
        ParserError = 4,
        /// <summary>
        /// Z3_NO_PARSER
        /// </summary>
        /// <remarks>
        /// Parser output is not available, that is, user didn't invoke <see cref="ParseSmtlib2String"/> or <see cref="ParseSmtlib2File"/>.
        /// </remarks>
        NoParser = 5,
        /// <summary>
        /// Z3_INVALID_PATTERN
        /// </summary>
        /// <remarks>
        /// Invalid pattern was used to build a quantifier.
        /// </remarks>
        InvalidPattern = 6,
        /// <summary>
        /// Z3_MEMOUT_FAIL
        /// </summary>
        /// <remarks>
        /// A memory allocation failure was encountered.
        /// </remarks>
        MemoutFail = 7,
        /// <summary>
        /// Z3_FILE_ACCESS_ERROR
        /// </summary>
        /// <remarks>
        /// A file could not be accessed.
        /// </remarks>
        FileAccessError = 8,
        /// <summary>
        /// Z3_INTERNAL_FATAL
        /// </summary>
        /// <remarks>
        /// An error internal to Z3 occurred.
        /// </remarks>
        InternalFatal = 9,
        /// <summary>
        /// Z3_INVALID_USAGE
        /// </summary>
        /// <remarks>
        /// API call is invalid in the current state.
        /// </remarks>
        InvalidUsage = 10,
        /// <summary>
        /// Z3_DEC_REF_ERROR
        /// </summary>
        /// <remarks>
        /// Trying to decrement the reference counter of an AST that was deleted or the reference counter was not initialized with <see cref="IncRef"/>.
        /// </remarks>
        DecRefError = 11,
        /// <summary>Z3_EXCEPTION</summary>
        Exception = 12,
    }

    /// <summary>
    /// A Goal is essentially a set of formulas.
    /// Z3 provide APIs for building strategies/tactics for solving and transforming Goals.
    /// Some of these transformations apply under/over approximations.
    /// </summary>
    internal enum GoalPrec
    {
        /// <summary>
        /// Z3_GOAL_PRECISE
        /// </summary>
        /// <remarks>
        /// Approximations/Relaxations were not applied on the goal (sat and unsat answers were preserved).
        /// </remarks>
        GoalPrecise = 0,
        /// <summary>
        /// Z3_GOAL_UNDER
        /// </summary>
        /// <remarks>
        /// Goal is the product of a under-approximation (sat answers are preserved).
        /// </remarks>
        GoalUnder = 1,
        /// <summary>
        /// Z3_GOAL_OVER
        /// </summary>
        /// <remarks>
        /// Goal is the product of an over-approximation (unsat answers are preserved).
        /// </remarks>
        GoalOver = 2,
        /// <summary>Z3_GOAL_UNDER_OVER</summary>
        GoalUnderOver = 3,
    }

    /// <summary>
    /// Lifted Boolean type: false, undefined, true.
    /// </summary>
    internal enum Lbool
    {
        /// <summary>Z3_L_FALSE</summary>
        False = -1,
        /// <summary>Z3_L_UNDEF</summary>
        Undef = 0,
        /// <summary>Z3_L_TRUE</summary>
        True = 1,
    }

    /// <summary>
    /// The different kinds of parameters that can be associated with parameter sets.
    /// (see <see cref="MkParams"/>).
    /// </summary>
    internal enum ParamKind
    {
        /// <summary>Z3_PK_UINT</summary>
        Uint = 0,
        /// <summary>Z3_PK_BOOL</summary>
        Bool = 1,
        /// <summary>Z3_PK_DOUBLE</summary>
        Double = 2,
        /// <summary>Z3_PK_SYMBOL</summary>
        Symbol = 3,
        /// <summary>Z3_PK_STRING</summary>
        String = 4,
        /// <summary>Z3_PK_OTHER</summary>
        Other = 5,
        /// <summary>Z3_PK_INVALID</summary>
        Invalid = 6,
    }

    /// <summary>
    /// The different kinds of parameters that can be associated with function symbols.
    /// </summary>
    /// <seealso cref="GetDeclNumParameters"/>
    /// <seealso cref="GetDeclParameterKind"/>
    internal enum ParameterKind
    {
        /// <summary>Z3_PARAMETER_INT</summary>
        ParameterInt = 0,
        /// <summary>Z3_PARAMETER_DOUBLE</summary>
        ParameterDouble = 1,
        /// <summary>Z3_PARAMETER_RATIONAL</summary>
        ParameterRational = 2,
        /// <summary>Z3_PARAMETER_SYMBOL</summary>
        ParameterSymbol = 3,
        /// <summary>Z3_PARAMETER_SORT</summary>
        ParameterSort = 4,
        /// <summary>Z3_PARAMETER_AST</summary>
        ParameterAst = 5,
        /// <summary>Z3_PARAMETER_FUNC_DECL</summary>
        ParameterFuncDecl = 6,
        /// <summary>Z3_PARAMETER_INTERNAL</summary>
        ParameterInternal = 7,
        /// <summary>Z3_PARAMETER_ZSTRING</summary>
        ParameterZstring = 8,
    }

    /// <summary>
    /// The different kinds of Z3 types (See <see cref="GetSortKind"/>).
    /// </summary>
    internal enum SortKind
    {
        /// <summary>Z3_UNINTERPRETED_SORT</summary>
        UninterpretedSort = 0,
        /// <summary>Z3_BOOL_SORT</summary>
        BoolSort = 1,
        /// <summary>Z3_INT_SORT</summary>
        IntSort = 2,
        /// <summary>Z3_REAL_SORT</summary>
        RealSort = 3,
        /// <summary>Z3_BV_SORT</summary>
        BvSort = 4,
        /// <summary>Z3_ARRAY_SORT</summary>
        ArraySort = 5,
        /// <summary>Z3_DATATYPE_SORT</summary>
        DatatypeSort = 6,
        /// <summary>Z3_RELATION_SORT</summary>
        RelationSort = 7,
        /// <summary>Z3_FINITE_DOMAIN_SORT</summary>
        FiniteDomainSort = 8,
        /// <summary>Z3_FLOATING_POINT_SORT</summary>
        FloatingPointSort = 9,
        /// <summary>Z3_ROUNDING_MODE_SORT</summary>
        RoundingModeSort = 10,
        /// <summary>Z3_SEQ_SORT</summary>
        SeqSort = 11,
        /// <summary>Z3_RE_SORT</summary>
        ReSort = 12,
        /// <summary>Z3_CHAR_SORT</summary>
        CharSort = 13,
        /// <summary>Z3_TYPE_VAR</summary>
        TypeVar = 14,
        /// <summary>Z3_UNKNOWN_SORT</summary>
        UnknownSort = 1000,
    }

    /// <summary>
    /// The different kinds of symbol.
    /// In Z3, a symbol can be represented using integers and strings (See <see cref="GetSymbolKind"/>).
    /// </summary>
    /// <seealso cref="MkIntSymbol"/>
    /// <seealso cref="MkStringSymbol"/>
    internal enum SymbolKind
    {
        /// <summary>Z3_INT_SYMBOL</summary>
        IntSymbol = 0,
        /// <summary>Z3_STRING_SYMBOL</summary>
        StringSymbol = 1,
    }

}
