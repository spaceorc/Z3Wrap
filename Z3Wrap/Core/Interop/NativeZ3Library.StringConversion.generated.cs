// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / String conversion
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void SetAstPrintModeDelegate(IntPtr c, int mode);

    /// <summary>
    /// Select mode for the format used for pretty-printing AST nodes.
    /// The default mode for pretty printing AST nodes is to produce
    /// SMT-LIB style output where common subexpressions are printed
    /// at each occurrence. The mode is called Z3_PRINT_SMTLIB_FULL.
    /// To print shared common subexpressions only once,
    /// use the Z3_PRINT_LOW_LEVEL mode.
    /// To print in way that conforms to SMT-LIB standards and uses let
    /// expressions to share common sub-expressions use Z3_PRINT_SMTLIB2_COMPLIANT.
    /// </summary>
    /// <seealso cref="AstToString"/>
    /// <seealso cref="PatternToString"/>
    /// <seealso cref="FuncDeclToString"/>
    [Z3Function("Z3_set_ast_print_mode")]
    internal void SetAstPrintMode(IntPtr c, int mode)
    {
        var funcPtr = GetFunctionPointer("Z3_set_ast_print_mode");
        var func = Marshal.GetDelegateForFunctionPointer<SetAstPrintModeDelegate>(funcPtr);
        func(c, mode);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr AstToStringDelegate(IntPtr c, IntPtr a);

    /// <summary>
    /// Convert the given AST node into a string.
    /// </summary>
    /// <remarks>
    /// Warning: The result buffer is statically allocated by Z3. It will
    /// be automatically deallocated when <see cref="DelContext"/> is invoked.
    /// So, the buffer is invalidated in the next call to Z3_ast_to_string.
    /// </remarks>
    /// <seealso cref="PatternToString"/>
    /// <seealso cref="SortToString"/>
    [Z3Function("Z3_ast_to_string")]
    internal IntPtr AstToString(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_ast_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<AstToStringDelegate>(funcPtr);
        return func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr PatternToStringDelegate(IntPtr c, IntPtr p);

    [Z3Function("Z3_pattern_to_string")]
    internal IntPtr PatternToString(IntPtr c, IntPtr p)
    {
        var funcPtr = GetFunctionPointer("Z3_pattern_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<PatternToStringDelegate>(funcPtr);
        return func(c, p);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SortToStringDelegate(IntPtr c, IntPtr s);

    [Z3Function("Z3_sort_to_string")]
    internal IntPtr SortToString(IntPtr c, IntPtr s)
    {
        var funcPtr = GetFunctionPointer("Z3_sort_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<SortToStringDelegate>(funcPtr);
        return func(c, s);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr FuncDeclToStringDelegate(IntPtr c, IntPtr d);

    [Z3Function("Z3_func_decl_to_string")]
    internal IntPtr FuncDeclToString(IntPtr c, IntPtr d)
    {
        var funcPtr = GetFunctionPointer("Z3_func_decl_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<FuncDeclToStringDelegate>(funcPtr);
        return func(c, d);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr ModelToStringDelegate(IntPtr c, IntPtr m);

    /// <summary>
    /// Convert the given model into a string.
    /// </summary>
    /// <remarks>
    /// Warning: The result buffer is statically allocated by Z3. It will
    /// be automatically deallocated when <see cref="DelContext"/> is invoked.
    /// So, the buffer is invalidated in the next call to Z3_model_to_string.
    /// </remarks>
    [Z3Function("Z3_model_to_string")]
    internal IntPtr ModelToString(IntPtr c, IntPtr m)
    {
        var funcPtr = GetFunctionPointer("Z3_model_to_string");
        var func = Marshal.GetDelegateForFunctionPointer<ModelToStringDelegate>(funcPtr);
        return func(c, m);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr BenchmarkToSmtlibStringDelegate(IntPtr c, IntPtr name, IntPtr logic, IntPtr status, IntPtr attributes, uint numAssumptions, IntPtr[] assumptions, IntPtr formula);

    /// <summary>
    /// Convert the given benchmark into SMT-LIB formatted string.
    /// </summary>
    /// <param name="c">- context.</param>
    /// <param name="name">- name of benchmark. The argument is optional.</param>
    /// <param name="logic">- the benchmark logic.</param>
    /// <param name="status">- the status string (sat, unsat, or unknown)</param>
    /// <param name="attributes">- other attributes, such as source, difficulty or category.</param>
    /// <param name="numAssumptions">- number of assumptions.</param>
    /// <param name="assumptions">- auxiliary assumptions.</param>
    /// <param name="formula">- formula to be checked for consistency in conjunction with assumptions.</param>
    /// <remarks>
    /// Warning: The result buffer is statically allocated by Z3. It will
    /// be automatically deallocated when <see cref="DelContext"/> is invoked.
    /// So, the buffer is invalidated in the next call to Z3_benchmark_to_smtlib_string.
    /// </remarks>
    [Z3Function("Z3_benchmark_to_smtlib_string")]
    internal IntPtr BenchmarkToSmtlibString(IntPtr c, IntPtr name, IntPtr logic, IntPtr status, IntPtr attributes, uint numAssumptions, IntPtr[] assumptions, IntPtr formula)
    {
        var funcPtr = GetFunctionPointer("Z3_benchmark_to_smtlib_string");
        var func = Marshal.GetDelegateForFunctionPointer<BenchmarkToSmtlibStringDelegate>(funcPtr);
        return func(c, name, logic, status, attributes, numAssumptions, assumptions, formula);
    }

}
