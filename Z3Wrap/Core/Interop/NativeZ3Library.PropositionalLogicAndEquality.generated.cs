// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Propositional Logic and Equality
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkTrueDelegate(IntPtr c);

    /// <summary>
    ///  Create an AST node representing <c>true</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    [Z3Function("Z3_mk_true")]
    internal IntPtr MkTrue(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_true");
        var func = Marshal.GetDelegateForFunctionPointer<MkTrueDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkFalseDelegate(IntPtr c);

    /// <summary>
    ///  Create an AST node representing <c>false</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    [Z3Function("Z3_mk_false")]
    internal IntPtr MkFalse(IntPtr c)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_false");
        var func = Marshal.GetDelegateForFunctionPointer<MkFalseDelegate>(funcPtr);
        return func(c);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkEqDelegate(IntPtr c, IntPtr l, IntPtr r);

    /// <summary>
    ///  Create an AST node representing <c>l = r</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="l" ctype="Z3_ast">ast parameter</param>
    /// <param name="r" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>l</c> and <c>r</c> must have the same type.
    /// </remarks>
    [Z3Function("Z3_mk_eq")]
    internal IntPtr MkEq(IntPtr c, IntPtr l, IntPtr r)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_eq");
        var func = Marshal.GetDelegateForFunctionPointer<MkEqDelegate>(funcPtr);
        return func(c, l, r);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkDistinctDelegate(IntPtr c, uint numArgs, IntPtr[] args);

    /// <summary>
    ///  Create an AST node representing <c>distinct(args[0], ..., args[num_args-1])</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The <c>distinct</c> construct is used for declaring the arguments pairwise distinct. That is, <c>Forall 0 &lt;= i &lt; j &lt; num_args. not args[i] = args[j]</c> . All arguments must have the same sort.
    /// The number of arguments of a distinct construct must be greater than one. 
    /// </remarks>
    [Z3Function("Z3_mk_distinct")]
    internal IntPtr MkDistinct(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_distinct");
        var func = Marshal.GetDelegateForFunctionPointer<MkDistinctDelegate>(funcPtr);
        return func(c, numArgs, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkNotDelegate(IntPtr c, IntPtr a);

    /// <summary>
    ///  Create an AST node representing <c>not(a)</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>a</c> must have Boolean sort.
    /// </remarks>
    [Z3Function("Z3_mk_not")]
    internal IntPtr MkNot(IntPtr c, IntPtr a)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_not");
        var func = Marshal.GetDelegateForFunctionPointer<MkNotDelegate>(funcPtr);
        return func(c, a);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkIteDelegate(IntPtr c, IntPtr t1, IntPtr t2, IntPtr t3);

    /// <summary>
    ///  Create an AST node representing an if-then-else: <c>ite(t1, t2, t3)</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="t3" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have Boolean sort, <c>t2</c> and <c>t3</c> must have the same sort. The sort of the new node is equal to the sort of <c>t2</c> and <c>t3</c> .
    /// </remarks>
    [Z3Function("Z3_mk_ite")]
    internal IntPtr MkIte(IntPtr c, IntPtr t1, IntPtr t2, IntPtr t3)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_ite");
        var func = Marshal.GetDelegateForFunctionPointer<MkIteDelegate>(funcPtr);
        return func(c, t1, t2, t3);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkIffDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Create an AST node representing <c>t1 iff t2</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have Boolean sort.
    /// </remarks>
    [Z3Function("Z3_mk_iff")]
    internal IntPtr MkIff(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_iff");
        var func = Marshal.GetDelegateForFunctionPointer<MkIffDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkImpliesDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Create an AST node representing <c>t1 implies t2</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have Boolean sort.
    /// </remarks>
    [Z3Function("Z3_mk_implies")]
    internal IntPtr MkImplies(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_implies");
        var func = Marshal.GetDelegateForFunctionPointer<MkImpliesDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkXorDelegate(IntPtr c, IntPtr t1, IntPtr t2);

    /// <summary>
    ///  Create an AST node representing <c>t1 xor t2</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have Boolean sort.
    /// </remarks>
    [Z3Function("Z3_mk_xor")]
    internal IntPtr MkXor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_xor");
        var func = Marshal.GetDelegateForFunctionPointer<MkXorDelegate>(funcPtr);
        return func(c, t1, t2);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkAndDelegate(IntPtr c, uint numArgs, IntPtr[] args);

    /// <summary>
    ///  Create an AST node representing <c>args[0] and ... and args[num_args-1]</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The array <c>args</c> must have <c>num_args</c> elements. All arguments must have Boolean sort.
    /// The number of arguments must be greater than zero. 
    /// </remarks>
    [Z3Function("Z3_mk_and")]
    internal IntPtr MkAnd(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_and");
        var func = Marshal.GetDelegateForFunctionPointer<MkAndDelegate>(funcPtr);
        return func(c, numArgs, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr MkOrDelegate(IntPtr c, uint numArgs, IntPtr[] args);

    /// <summary>
    ///  Create an AST node representing <c>args[0] or ... or args[num_args-1]</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The array <c>args</c> must have <c>num_args</c> elements. All arguments must have Boolean sort.
    /// The number of arguments must be greater than zero. 
    /// </remarks>
    [Z3Function("Z3_mk_or")]
    internal IntPtr MkOr(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var funcPtr = GetFunctionPointer("Z3_mk_or");
        var func = Marshal.GetDelegateForFunctionPointer<MkOrDelegate>(funcPtr);
        return func(c, numArgs, args);
    }

}
