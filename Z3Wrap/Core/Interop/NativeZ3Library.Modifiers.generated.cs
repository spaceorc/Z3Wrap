// <auto-generated>
// This file was generated by scripts/generate_native_library.py
// Source: z3_api.h / Modifiers
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System;
using System.Runtime.InteropServices;

namespace Spaceorc.Z3Wrap.Core.Interop;

internal sealed partial class NativeZ3Library
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr UpdateTermDelegate(IntPtr c, IntPtr a, uint numArgs, IntPtr[] args);

    /// <summary>
    ///  Update the arguments of term <c>a</c> using the arguments <c>args</c> . The number of arguments <c>num_args</c> should coincide with the number of arguments to <c>a</c> . If <c>a</c> is a quantifier, then num_args has to be 1. 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    [Z3Function("Z3_update_term")]
    internal IntPtr UpdateTerm(IntPtr c, IntPtr a, uint numArgs, IntPtr[] args)
    {
        var funcPtr = GetFunctionPointer("Z3_update_term");
        var func = Marshal.GetDelegateForFunctionPointer<UpdateTermDelegate>(funcPtr);
        return func(c, a, numArgs, args);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SubstituteDelegate(IntPtr c, IntPtr a, uint numExprs, IntPtr[] from, IntPtr[] to);

    /// <summary>
    ///  Substitute every occurrence of <c>from[i]</c> in <c>a</c> with <c>to[i]</c> , for <c>i</c> smaller than <c>num_exprs</c> . The result is the new AST. The arrays <c>from</c> and <c>to</c> must have size <c>num_exprs</c> . For every <c>i</c> smaller than <c>num_exprs</c> , we must have that sort of <c>from[i]</c> must be equal to sort of <c>to[i]</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="numExprs" ctype="unsigned">unsigned parameter</param>
    /// <param name="from" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="to" ctype="Z3_ast const[]">ast parameter</param>
    [Z3Function("Z3_substitute")]
    internal IntPtr Substitute(IntPtr c, IntPtr a, uint numExprs, IntPtr[] from, IntPtr[] to)
    {
        var funcPtr = GetFunctionPointer("Z3_substitute");
        var func = Marshal.GetDelegateForFunctionPointer<SubstituteDelegate>(funcPtr);
        return func(c, a, numExprs, from, to);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SubstituteVarsDelegate(IntPtr c, IntPtr a, uint numExprs, IntPtr[] to);

    /// <summary>
    ///  Substitute the variables in <c>a</c> with the expressions in <c>to</c> . For every <c>i</c> smaller than <c>num_exprs</c> , the variable with de-Bruijn index <c>i</c> is replaced with term <c>to[i]</c> . Note that a variable is created using the function <see cref="Z3_mk_bound"/> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="numExprs" ctype="unsigned">unsigned parameter</param>
    /// <param name="to" ctype="Z3_ast const[]">ast parameter</param>
    [Z3Function("Z3_substitute_vars")]
    internal IntPtr SubstituteVars(IntPtr c, IntPtr a, uint numExprs, IntPtr[] to)
    {
        var funcPtr = GetFunctionPointer("Z3_substitute_vars");
        var func = Marshal.GetDelegateForFunctionPointer<SubstituteVarsDelegate>(funcPtr);
        return func(c, a, numExprs, to);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr SubstituteFunsDelegate(IntPtr c, IntPtr a, uint numFuns, IntPtr[] from, IntPtr[] to);

    /// <summary>
    ///  Substitute functions in <c>from</c> with new expressions in <c>to</c> . 
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="numFuns" ctype="unsigned">unsigned parameter</param>
    /// <param name="from" ctype="Z3_func_decl const[]">func_decl parameter</param>
    /// <param name="to" ctype="Z3_ast const[]">ast parameter</param>
    /// <remarks>
    /// The expressions in <c>to</c> can have free variables. The free variable in <c>to</c> at index 0 refers to the first argument of <c>from</c> , the free variable at index 1 corresponds to the second argument.
    /// </remarks>
    [Z3Function("Z3_substitute_funs")]
    internal IntPtr SubstituteFuns(IntPtr c, IntPtr a, uint numFuns, IntPtr[] from, IntPtr[] to)
    {
        var funcPtr = GetFunctionPointer("Z3_substitute_funs");
        var func = Marshal.GetDelegateForFunctionPointer<SubstituteFunsDelegate>(funcPtr);
        return func(c, a, numFuns, from, to);
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate IntPtr TranslateDelegate(IntPtr source, IntPtr a, IntPtr target);

    /// <summary>
    ///  Translate/Copy the AST <c>a</c> from context <c>source</c> to context <c>target</c> . AST <c>a</c> must have been created using context <c>source</c> . 
    /// </summary>
    /// <param name="source" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="target" ctype="Z3_context">context parameter</param>
    /// <remarks>
    /// Precondition: source != target 
    /// </remarks>
    [Z3Function("Z3_translate")]
    internal IntPtr Translate(IntPtr source, IntPtr a, IntPtr target)
    {
        var funcPtr = GetFunctionPointer("Z3_translate");
        var func = Marshal.GetDelegateForFunctionPointer<TranslateDelegate>(funcPtr);
        return func(source, a, target);
    }

}
