// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.StringConversion.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Select mode for the format used for pretty-printing AST nodes.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="mode" ctype="Z3_ast_print_mode">ast_print_mode parameter</param>
    /// <remarks>
    /// The default mode for pretty printing AST nodes is to produce SMT-LIB style output where common subexpressions are printed at each occurrence. The mode is called <c>Z3_PRINT_SMTLIB_FULL</c> . To print shared common subexpressions only once, use the <c>Z3_PRINT_LOW_LEVEL</c> mode. To print in way that conforms to SMT-LIB standards and uses let expressions to share common sub-expressions use <c>Z3_PRINT_SMTLIB2_COMPLIANT</c> .
    /// </remarks>
    /// <seealso cref="AstToString"/>
    /// <seealso cref="PatternToString"/>
    /// <seealso cref="FuncDeclToString"/>
    public void SetAstPrintMode(IntPtr c, AstPrintMode mode)
    {
        nativeLibrary.SetAstPrintMode(c, (NativeZ3Library.AstPrintMode)mode);
        CheckError(c);
    }

    /// <summary>
    ///  Convert the given AST node into a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Warning: The result buffer is statically allocated by Z3. It will be automatically deallocated when <see cref="DelContext"/> is invoked. So, the buffer is invalidated in the next call to <c>Z3_ast_to_string</c> .
    /// </remarks>
    /// <seealso cref="PatternToString"/>
    /// <seealso cref="SortToString"/>
    public string AstToString(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.AstToString(c, a);
        CheckError(c);
        result = CheckHandle(result, nameof(AstToString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>PatternToString</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="p" ctype="Z3_pattern">pattern parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    public string PatternToString(IntPtr c, IntPtr p)
    {
        var result = nativeLibrary.PatternToString(c, p);
        CheckError(c);
        result = CheckHandle(result, nameof(PatternToString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>SortToString</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    public string SortToString(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SortToString(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SortToString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>FuncDeclToString</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    public string FuncDeclToString(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.FuncDeclToString(c, d);
        CheckError(c);
        result = CheckHandle(result, nameof(FuncDeclToString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Convert the given model into a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Warning: The result buffer is statically allocated by Z3. It will be automatically deallocated when <see cref="DelContext"/> is invoked. So, the buffer is invalidated in the next call to <c>Z3_model_to_string</c> .
    /// </remarks>
    public string ModelToString(IntPtr c, IntPtr m)
    {
        var result = nativeLibrary.ModelToString(c, m);
        CheckError(c);
        result = CheckHandle(result, nameof(ModelToString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Convert the given benchmark into SMT-LIB formatted string.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context. </param>
    /// <param name="name" ctype="Z3_string"> - name of benchmark. The argument is optional. </param>
    /// <param name="logic" ctype="Z3_string"> - the benchmark logic. </param>
    /// <param name="status" ctype="Z3_string"> - the status string (sat, unsat, or unknown) </param>
    /// <param name="attributes" ctype="Z3_string"> - other attributes, such as source, difficulty or category. </param>
    /// <param name="numAssumptions" ctype="unsigned"> - number of assumptions. </param>
    /// <param name="assumptions" ctype="Z3_ast const[]"> - auxiliary assumptions. </param>
    /// <param name="formula" ctype="Z3_ast"> - formula to be checked for consistency in conjunction with assumptions. </param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Warning: The result buffer is statically allocated by Z3. It will be automatically deallocated when <see cref="DelContext"/> is invoked. So, the buffer is invalidated in the next call to <c>Z3_benchmark_to_smtlib_string</c> .
    /// </remarks>
    public string BenchmarkToSmtlibString(IntPtr c, string name, string logic, string status, string attributes, uint numAssumptions, IntPtr[] assumptions, IntPtr formula)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        using var logicAnsi = new AnsiStringPtr(logic);
        using var statusAnsi = new AnsiStringPtr(status);
        using var attributesAnsi = new AnsiStringPtr(attributes);
        var result = nativeLibrary.BenchmarkToSmtlibString(c, nameAnsi, logicAnsi, statusAnsi, attributesAnsi, numAssumptions, assumptions, formula);
        CheckError(c);
        result = CheckHandle(result, nameof(BenchmarkToSmtlibString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

}
