// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Arrays.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Array read. The argument <c>a</c> is the array and <c>i</c> is the index of the array that gets read.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>a</c> must have an array sort <c>[domain -&gt; range]</c> , and <c>i</c> must have the sort <c>domain</c> . The sort of the result is <c>range</c> .
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkStore"/>
    public IntPtr MkSelect(IntPtr c, IntPtr a, IntPtr i)
    {
        var result = nativeLibrary.MkSelect(c, a, i);
        CheckError(c);
        return CheckHandle(result, nameof(MkSelect));
    }

    /// <summary>
    ///  n-ary Array read. The argument <c>a</c> is the array and <c>idxs</c> are the indices of the array that gets read.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="idxs" ctype="Z3_ast const*">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSelectN(IntPtr c, IntPtr a, uint n, out IntPtr idxs)
    {
        var result = nativeLibrary.MkSelectN(c, a, n, out idxs);
        CheckError(c);
        return CheckHandle(result, nameof(MkSelectN));
    }

    /// <summary>
    ///  Array update.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="Z3_ast">ast parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>a</c> must have an array sort <c>[domain -&gt; range]</c> , <c>i</c> must have sort <c>domain</c> , <c>v</c> must have sort range. The sort of the result is <c>[domain -&gt; range]</c> . The semantics of this function is given by the theory of arrays described in the SMT-LIB standard. See http://smtlib.org for more details. The result of this function is an array that is equal to <c>a</c> (with respect to <c>select</c> ) on all indices except for <c>i</c> , where it maps to <c>v</c> (and the <c>select</c> of <c>a</c> with respect to <c>i</c> may be a different value).
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkSelect"/>
    public IntPtr MkStore(IntPtr c, IntPtr a, IntPtr i, IntPtr v)
    {
        var result = nativeLibrary.MkStore(c, a, i, v);
        CheckError(c);
        return CheckHandle(result, nameof(MkStore));
    }

    /// <summary>
    ///  n-ary Array update.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="idxs" ctype="Z3_ast const*">ast parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkStoreN(IntPtr c, IntPtr a, uint n, out IntPtr idxs, IntPtr v)
    {
        var result = nativeLibrary.MkStoreN(c, a, n, out idxs, v);
        CheckError(c);
        return CheckHandle(result, nameof(MkStoreN));
    }

    /// <summary>
    ///  Create the constant array.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="domain" ctype="Z3_sort"> domain sort for the array. </param>
    /// <param name="v" ctype="Z3_ast"> value that the array maps to. </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The resulting term is an array, such that a <c>select</c> on an arbitrary index produces the value <c>v</c> .
    /// </remarks>
    public IntPtr MkConstArray(IntPtr c, IntPtr domain, IntPtr v)
    {
        var result = nativeLibrary.MkConstArray(c, domain, v);
        CheckError(c);
        return CheckHandle(result, nameof(MkConstArray));
    }

    /// <summary>
    ///  Map f on the argument arrays.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const*">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The <c>n</c> nodes <c>args</c> must be of array sorts <c>[domain_i -&gt; range_i]</c> . The function declaration <c>f</c> must have type <c> range_1 .. range_n -&gt; range</c> . <c>v</c> must have sort range. The sort of the result is <c>[domain_i -&gt; range]</c> .
    /// </remarks>
    /// <seealso cref="MkArraySort"/>
    /// <seealso cref="MkStore"/>
    /// <seealso cref="MkSelect"/>
    public IntPtr MkMap(IntPtr c, IntPtr f, uint n, out IntPtr args)
    {
        var result = nativeLibrary.MkMap(c, f, n, out args);
        CheckError(c);
        return CheckHandle(result, nameof(MkMap));
    }

    /// <summary>
    ///  Access the array default value. Produces the default range value, for arrays that can be represented as finite maps with a default range value.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <param name="array" ctype="Z3_ast"> array value whose default range value is accessed. </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkArrayDefault(IntPtr c, IntPtr array)
    {
        var result = nativeLibrary.MkArrayDefault(c, array);
        CheckError(c);
        return CheckHandle(result, nameof(MkArrayDefault));
    }

    /// <summary>
    ///  Create array with the same interpretation as a function. The array satisfies the property (f x) = (select (_ as-array f) x) for every argument x.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_func_decl">func_decl parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkAsArray(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.MkAsArray(c, f);
        CheckError(c);
        return CheckHandle(result, nameof(MkAsArray));
    }

    /// <summary>
    ///  Create predicate that holds if Boolean array <c>set</c> has <c>k</c> elements set to true.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="set" ctype="Z3_ast">ast parameter</param>
    /// <param name="k" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSetHasSize(IntPtr c, IntPtr set, IntPtr k)
    {
        var result = nativeLibrary.MkSetHasSize(c, set, k);
        CheckError(c);
        return CheckHandle(result, nameof(MkSetHasSize));
    }

}
