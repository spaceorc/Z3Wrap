// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Modifiers.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Update the arguments of term a using the arguments args.
    /// The number of arguments num_args should coincide
    /// with the number of arguments to a.
    /// If a is a quantifier, then num_args has to be 1.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="numArgs" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    public IntPtr UpdateTerm(IntPtr c, IntPtr a, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.UpdateTerm(c, a, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(UpdateTerm));
    }

    /// <summary>
    /// Substitute every occurrence of
    /// <code>
    /// from[i]
    /// </code>
    /// in a with
    /// <code>
    /// to[i]
    /// </code>
    /// , for i smaller than num_exprs.
    /// The result is the new AST. The arrays from and to must have size num_exprs.
    /// For every i smaller than num_exprs, we must have that sort of
    /// <code>
    /// from[i]
    /// </code>
    /// must be equal to sort of
    /// <code>
    /// to[i]
    /// </code>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="numExprs" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="from" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <param name="to" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    public IntPtr Substitute(IntPtr c, IntPtr a, uint numExprs, IntPtr[] from, IntPtr[] to)
    {
        var result = nativeLibrary.Substitute(c, a, numExprs, from, to);
        CheckError(c);
        return CheckHandle(result, nameof(Substitute));
    }

    /// <summary>
    /// Substitute the variables in a with the expressions in to.
    /// For every i smaller than num_exprs, the variable with de-Bruijn index i is replaced with term
    /// <code>
    /// to[i]
    /// </code>
    /// .
    /// Note that a variable is created using the function \ref Z3_mk_bound.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="numExprs" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="to" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    public IntPtr SubstituteVars(IntPtr c, IntPtr a, uint numExprs, IntPtr[] to)
    {
        var result = nativeLibrary.SubstituteVars(c, a, numExprs, to);
        CheckError(c);
        return CheckHandle(result, nameof(SubstituteVars));
    }

    /// <summary>
    /// <para>
    /// Substitute functions in from with new expressions in to.
    /// </para>
    /// <para>
    /// The expressions in to can have free variables. The free variable in to at index 0
    /// refers to the first argument of from, the free variable at index 1 corresponds to the second argument.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="numFuns" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="from" ctype="Z3_func_decl const[]">
    /// func_decl parameter
    /// </param>
    /// <param name="to" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    public IntPtr SubstituteFuns(IntPtr c, IntPtr a, uint numFuns, IntPtr[] from, IntPtr[] to)
    {
        var result = nativeLibrary.SubstituteFuns(c, a, numFuns, from, to);
        CheckError(c);
        return CheckHandle(result, nameof(SubstituteFuns));
    }

    /// <summary>
    /// Translate/Copy the AST a from context source to context target.
    /// AST a must have been created using context source.
    /// </summary>
    /// <param name="source" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="target" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <remarks>
    /// Precondition: source != target
    /// </remarks>
    public IntPtr Translate(IntPtr source, IntPtr a, IntPtr target)
    {
        var result = nativeLibrary.Translate(source, a, target);
        CheckError(source);
        return CheckHandle(result, nameof(Translate));
    }

}
