// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Z3SpecificFloatingPointExtensions.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Retrieves the number of bits reserved for the exponent in a FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// FloatingPoint sort
    /// </param>
    /// <seealso cref="FpaGetSbits"/>
    public uint FpaGetEbits(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.FpaGetEbits(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Retrieves the number of bits reserved for the significand in a FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// FloatingPoint sort
    /// </param>
    /// <seealso cref="FpaGetEbits"/>
    public uint FpaGetSbits(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.FpaGetSbits(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Checks whether a given floating-point numeral is a NaN.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralNan(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralNan(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Checks whether a given floating-point numeral is a +oo or -oo.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralInf(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralInf(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Checks whether a given floating-point numeral is +zero or -zero.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    public bool FpaIsNumeralZero(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralZero(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Checks whether a given floating-point numeral is normal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralSubnormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralNormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralNormal(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Checks whether a given floating-point numeral is subnormal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <seealso cref="FpaIsNumeralInf"/>
    /// <seealso cref="FpaIsNumeralNan"/>
    /// <seealso cref="FpaIsNumeralNormal"/>
    /// <seealso cref="FpaIsNumeralZero"/>
    public bool FpaIsNumeralSubnormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralSubnormal(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Checks whether a given floating-point numeral is positive.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <seealso cref="FpaIsNumeralNegative"/>
    public bool FpaIsNumeralPositive(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralPositive(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Checks whether a given floating-point numeral is negative.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <seealso cref="FpaIsNumeralPositive"/>
    public bool FpaIsNumeralNegative(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaIsNumeralNegative(c, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Retrieves the sign of a floating-point literal as a bit-vector expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// a floating-point numeral
    /// </para>
    /// <para>
    /// Remarks: NaN is an invalid argument.
    /// </para>
    /// </param>
    public IntPtr FpaGetNumeralSignBv(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaGetNumeralSignBv(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralSignBv));
    }

    /// <summary>
    /// Retrieves the significand of a floating-point literal as a bit-vector expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// a floating-point numeral
    /// </para>
    /// <para>
    /// Remarks: NaN is an invalid argument.
    /// </para>
    /// </param>
    public IntPtr FpaGetNumeralSignificandBv(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaGetNumeralSignificandBv(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralSignificandBv));
    }

    /// <summary>
    /// Retrieves the sign of a floating-point literal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <param name="sgn" ctype="int *">
    /// the retrieved sign
    /// </param>
    /// <returns>
    /// <para>
    /// true if t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
    /// </para>
    /// <para>
    /// Remarks: sets sgn to 0 if `t' is positive and to 1 otherwise, except for
    /// NaN, which is an invalid argument.
    /// </para>
    /// </returns>
    public bool FpaGetNumeralSign(IntPtr c, IntPtr t, IntPtr sgn)
    {
        var result = nativeLibrary.FpaGetNumeralSign(c, t, sgn);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the significand value of a floating-point numeral as a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <returns>
    /// <para>
    /// true if t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
    /// </para>
    /// <para>
    /// Remarks: The significand s is always
    /// <code>
    /// 0.0 &lt;= s &lt; 2.0
    /// </code>
    /// ; the resulting string is long
    /// enough to represent the real significand precisely.
    /// </para>
    /// </returns>
    public IntPtr FpaGetNumeralSignificandString(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.FpaGetNumeralSignificandString(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralSignificandString));
    }

    /// <summary>
    /// Return the significand value of a floating-point numeral as a uint64.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <param name="n" ctype="uint64_t *">
    /// <para>
    /// pointer to output uint64
    /// </para>
    /// <para>
    /// Remarks: This function extracts the significand bits in `t`, without the
    /// hidden bit or normalization. Sets the Z3_INVALID_ARG error code if the
    /// significand does not fit into a uint64. NaN is an invalid argument.
    /// </para>
    /// </param>
    public bool FpaGetNumeralSignificandUint64(IntPtr c, IntPtr t, IntPtr n)
    {
        var result = nativeLibrary.FpaGetNumeralSignificandUint64(c, t, n);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the exponent value of a floating-point numeral as a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <param name="biased" ctype="bool">
    /// flag to indicate whether the result is in biased representation
    /// </param>
    /// <returns>
    /// <para>
    /// true if t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
    /// </para>
    /// <para>
    /// Remarks: This function extracts the exponent in `t`, without normalization.
    /// NaN is an invalid argument.
    /// </para>
    /// </returns>
    public IntPtr FpaGetNumeralExponentString(IntPtr c, IntPtr t, bool biased)
    {
        var result = nativeLibrary.FpaGetNumeralExponentString(c, t, biased);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralExponentString));
    }

    /// <summary>
    /// Return the exponent value of a floating-point numeral as a signed 64-bit integer
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <param name="n" ctype="int64_t *">
    /// exponent
    /// </param>
    /// <param name="biased" ctype="bool">
    /// flag to indicate whether the result is in biased representation
    /// </param>
    /// <returns>
    /// <para>
    /// true if t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
    /// </para>
    /// <para>
    /// Remarks: This function extracts the exponent in `t`, without normalization.
    /// NaN is an invalid argument.
    /// </para>
    /// </returns>
    public bool FpaGetNumeralExponentInt64(IntPtr c, IntPtr t, IntPtr n, bool biased)
    {
        var result = nativeLibrary.FpaGetNumeralExponentInt64(c, t, n, biased);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Retrieves the exponent of a floating-point literal as a bit-vector expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// a floating-point numeral
    /// </param>
    /// <param name="biased" ctype="bool">
    /// <para>
    /// flag to indicate whether the result is in biased representation
    /// </para>
    /// <para>
    /// Remarks: This function extracts the exponent in `t`, without normalization.
    /// NaN is an invalid arguments.
    /// </para>
    /// </param>
    public IntPtr FpaGetNumeralExponentBv(IntPtr c, IntPtr t, bool biased)
    {
        var result = nativeLibrary.FpaGetNumeralExponentBv(c, t, biased);
        CheckError(c);
        return CheckHandle(result, nameof(FpaGetNumeralExponentBv));
    }

    /// <summary>
    /// Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort. The size of the resulting bit-vector is automatically
    /// determined.
    /// </para>
    /// <para>
    /// Note that IEEE 754-2008 allows multiple different representations of NaN. This conversion
    /// knows only one NaN and it will always produce the same bit-vector representation of
    /// that NaN.
    /// </para>
    /// </param>
    public IntPtr MkFpaToIeeeBv(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaToIeeeBv(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToIeeeBv));
    }

    /// <summary>
    /// <para>
    /// Conversion of a real-sorted significand and an integer-sorted exponent into a term of FloatingPoint sort.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of
    /// <code>
    /// sig * 2^exp
    /// </code>
    /// into a
    /// floating-point term of sort s. If necessary, the result will be rounded
    /// according to rounding mode rm.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="exp" ctype="Z3_ast">
    /// exponent term of Int sort
    /// </param>
    /// <param name="sig" ctype="Z3_ast">
    /// significand term of Real sort
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// <para>
    /// FloatingPoint sort
    /// </para>
    /// <para>
    /// s must be a FloatingPoint sort, rm must be of RoundingMode sort, exp must be of int sort, sig must be of real sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaToFpIntReal(IntPtr c, IntPtr rm, IntPtr exp, IntPtr sig, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpIntReal(c, rm, exp, sig, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpIntReal));
    }

}
