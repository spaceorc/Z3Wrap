// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.FloatingPointArithmetic.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Create the RoundingMode sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundingModeSort(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundingModeSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundingModeSort));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRne"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundNearestTiesToEven(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundNearestTiesToEven(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundNearestTiesToEven));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRoundNearestTiesToEven"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtp"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRne(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRne(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRne));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRna"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundNearestTiesToAway(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundNearestTiesToAway(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundNearestTiesToAway));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRoundNearestTiesToAway"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtp"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRna(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRna(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRna));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRtp"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundTowardPositive(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundTowardPositive(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundTowardPositive));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRoundTowardPositive"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRtp(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRtp(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRtp));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRtn"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundTowardNegative(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundTowardNegative(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundTowardNegative));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRoundTowardNegative"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtp"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRtn(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRtn(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRtn));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRtz"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    public IntPtr MkFpaRoundTowardZero(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundTowardZero(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundTowardZero));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaRoundTowardZero"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtp"/>
    public IntPtr MkFpaRtz(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRtz(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRtz));
    }

    /// <summary>
    /// Create a FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="ebits" ctype="unsigned">
    /// number of exponent bits
    /// </param>
    /// <param name="sbits" ctype="unsigned">
    /// number of significand bits
    /// </param>
    /// <remarks>
    /// ebits must be larger than 1 and sbits must be larger than 2.
    /// </remarks>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSortDouble"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    public IntPtr MkFpaSort(IntPtr c, uint ebits, uint sbits)
    {
        var result = nativeLibrary.MkFpaSort(c, ebits, sbits);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort));
    }

    /// <summary>
    /// <para>
    /// Create the half-precision (16-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSort16"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSortDouble"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    public IntPtr MkFpaSortHalf(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortHalf(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortHalf));
    }

    /// <summary>
    /// <para>
    /// Create the half-precision (16-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSortHalf"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort32"/>
    /// <seealso cref="MkFpaSort64"/>
    /// <seealso cref="MkFpaSort128"/>
    public IntPtr MkFpaSort16(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort16(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort16));
    }

    /// <summary>
    /// <para>
    /// Create the single-precision (32-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSort32"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSortDouble"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    public IntPtr MkFpaSortSingle(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortSingle(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortSingle));
    }

    /// <summary>
    /// <para>
    /// Create the single-precision (32-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSortSingle"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort16"/>
    /// <seealso cref="MkFpaSort64"/>
    /// <seealso cref="MkFpaSort128"/>
    public IntPtr MkFpaSort32(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort32(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort32));
    }

    /// <summary>
    /// <para>
    /// Create the double-precision (64-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSort64"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    public IntPtr MkFpaSortDouble(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortDouble(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortDouble));
    }

    /// <summary>
    /// <para>
    /// Create the double-precision (64-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSortDouble"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort16"/>
    /// <seealso cref="MkFpaSort32"/>
    /// <seealso cref="MkFpaSort128"/>
    public IntPtr MkFpaSort64(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort64(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort64));
    }

    /// <summary>
    /// <para>
    /// Create the quadruple-precision (128-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSort128"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSortDouble"/>
    public IntPtr MkFpaSortQuadruple(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortQuadruple(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortQuadruple));
    }

    /// <summary>
    /// <para>
    /// Create the quadruple-precision (128-bit) FloatingPoint sort.
    /// </para>
    /// <para>
    /// This is the same as
    /// <see cref="MkFpaSortQuadruple"/>
    /// .
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort16"/>
    /// <seealso cref="MkFpaSort32"/>
    /// <seealso cref="MkFpaSort64"/>
    public IntPtr MkFpaSort128(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort128(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort128));
    }

    /// <summary>
    /// Create a floating-point NaN of sort s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// target sort
    /// </param>
    /// <seealso cref="MkFpaInf"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaZero"/>
    public IntPtr MkFpaNan(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkFpaNan(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNan));
    }

    /// <summary>
    /// Create a floating-point infinity of sort s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// target sort
    /// </param>
    /// <param name="negative" ctype="bool">
    /// <para>
    /// indicates whether the result should be negative
    /// </para>
    /// <para>
    /// When negative is true, -oo will be generated instead of +oo.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaNan"/>
    /// <seealso cref="MkFpaZero"/>
    public IntPtr MkFpaInf(IntPtr c, IntPtr s, bool negative)
    {
        var result = nativeLibrary.MkFpaInf(c, s, negative);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaInf));
    }

    /// <summary>
    /// Create a floating-point zero of sort s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// target sort
    /// </param>
    /// <param name="negative" ctype="bool">
    /// <para>
    /// indicates whether the result should be negative
    /// </para>
    /// <para>
    /// When negative is true, -zero will be generated instead of +zero.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaInf"/>
    /// <seealso cref="MkFpaIsZero"/>
    /// <seealso cref="MkFpaNan"/>
    public IntPtr MkFpaZero(IntPtr c, IntPtr s, bool negative)
    {
        var result = nativeLibrary.MkFpaZero(c, s, negative);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaZero));
    }

    /// <summary>
    /// <para>
    /// Create an expression of FloatingPoint sort from three bit-vector expressions.
    /// </para>
    /// <para>
    /// This is the operator named `fp' in the SMT FP theory definition.
    /// Note that sgn is required to be a bit-vector of size 1. Significand and exponent
    /// are required to be longer than 1 and 2 respectively. The FloatingPoint sort
    /// of the resulting expression is automatically determined from the bit-vector sizes
    /// of the arguments. The exponent is assumed to be in IEEE-754 biased representation.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="sgn" ctype="Z3_ast">
    /// sign
    /// </param>
    /// <param name="exp" ctype="Z3_ast">
    /// exponent
    /// </param>
    /// <param name="sig" ctype="Z3_ast">
    /// significand
    /// </param>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaFp(IntPtr c, IntPtr sgn, IntPtr exp, IntPtr sig)
    {
        var result = nativeLibrary.MkFpaFp(c, sgn, exp, sig);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaFp));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of FloatingPoint sort from a float.
    /// </para>
    /// <para>
    /// This function is used to create numerals that fit in a float value.
    /// It is slightly faster than
    /// <see cref="MkNumeral"/>
    /// since it is not necessary to parse a string.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="v" ctype="float">
    /// value
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// <para>
    /// sort
    /// </para>
    /// <para>
    /// ty must be a FloatingPoint sort
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralFloat(IntPtr c, float v, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralFloat(c, v, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralFloat));
    }

    /// <summary>
    /// <para>
    /// Create a numeral of FloatingPoint sort from a double.
    /// </para>
    /// <para>
    /// This function is used to create numerals that fit in a double value.
    /// It is slightly faster than
    /// <see cref="MkNumeral"/>
    /// since it is not necessary to parse a string.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="v" ctype="double">
    /// value
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// <para>
    /// sort
    /// </para>
    /// <para>
    /// ty must be a FloatingPoint sort
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralDouble(IntPtr c, double v, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralDouble(c, v, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralDouble));
    }

    /// <summary>
    /// Create a numeral of FloatingPoint sort from a signed integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="v" ctype="signed">
    /// value
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// <para>
    /// result sort
    /// </para>
    /// <para>
    /// ty must be a FloatingPoint sort
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralInt(IntPtr c, int v, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralInt(c, v, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralInt));
    }

    /// <summary>
    /// Create a numeral of FloatingPoint sort from a sign bit and two integers.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="sgn" ctype="bool">
    /// sign bit (true == negative)
    /// </param>
    /// <param name="exp" ctype="signed">
    /// exponent
    /// </param>
    /// <param name="sig" ctype="unsigned">
    /// significand
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// <para>
    /// result sort
    /// </para>
    /// <para>
    /// ty must be a FloatingPoint sort
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralIntUint(IntPtr c, bool sgn, int exp, uint sig, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralIntUint(c, sgn, exp, sig, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralIntUint));
    }

    /// <summary>
    /// Create a numeral of FloatingPoint sort from a sign bit and two 64-bit integers.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="sgn" ctype="bool">
    /// sign bit (true == negative)
    /// </param>
    /// <param name="exp" ctype="int64_t">
    /// exponent
    /// </param>
    /// <param name="sig" ctype="uint64_t">
    /// significand
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// <para>
    /// result sort
    /// </para>
    /// <para>
    /// ty must be a FloatingPoint sort
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralInt64Uint64(IntPtr c, bool sgn, long exp, ulong sig, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralInt64Uint64(c, sgn, exp, sig, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralInt64Uint64));
    }

    /// <summary>
    /// Floating-point absolute value
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <seealso cref="MkFpaIsNegative"/>
    /// <seealso cref="MkFpaIsPositive"/>
    /// <seealso cref="MkFpaNeg"/>
    public IntPtr MkFpaAbs(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaAbs(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaAbs));
    }

    /// <summary>
    /// Floating-point negation
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <seealso cref="MkFpaAbs"/>
    /// <seealso cref="MkFpaIsNegative"/>
    /// <seealso cref="MkFpaIsPositive"/>
    public IntPtr MkFpaNeg(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaNeg(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNeg));
    }

    /// <summary>
    /// Floating-point addition
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// rm must be of RoundingMode sort, t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaAdd(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaAdd(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaAdd));
    }

    /// <summary>
    /// Floating-point subtraction
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// rm must be of RoundingMode sort, t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaSub(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaSub(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSub));
    }

    /// <summary>
    /// Floating-point multiplication
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// rm must be of RoundingMode sort, t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaMul(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaMul(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaMul));
    }

    /// <summary>
    /// Floating-point division
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort.
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// The nodes rm must be of RoundingMode sort, t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaDiv(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaDiv(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaDiv));
    }

    /// <summary>
    /// Floating-point fused multiply-add.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t3" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// The result is
    /// <code>
    /// round((t1 * t2) + t3)
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// rm must be of RoundingMode sort, t1, t2, and t3 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaFma(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2, IntPtr t3)
    {
        var result = nativeLibrary.MkFpaFma(c, rm, t1, t2, t3);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaFma));
    }

    /// <summary>
    /// Floating-point square root
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// rm must be of RoundingMode sort, t must have FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaSqrt(IntPtr c, IntPtr rm, IntPtr t)
    {
        var result = nativeLibrary.MkFpaSqrt(c, rm, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSqrt));
    }

    /// <summary>
    /// Floating-point remainder
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaRem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaRem(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRem));
    }

    /// <summary>
    /// Floating-point roundToIntegral. Rounds a floating-point number to
    /// the closest integer, again represented as a floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must be of FloatingPoint sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaRoundToIntegral(IntPtr c, IntPtr rm, IntPtr t)
    {
        var result = nativeLibrary.MkFpaRoundToIntegral(c, rm, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundToIntegral));
    }

    /// <summary>
    /// Minimum of floating-point numbers.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t1, t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaMax"/>
    public IntPtr MkFpaMin(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaMin(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaMin));
    }

    /// <summary>
    /// Maximum of floating-point numbers.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t1, t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaMin"/>
    public IntPtr MkFpaMax(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaMax(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaMax));
    }

    /// <summary>
    /// Floating-point less than or equal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaLeq(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaLeq(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaLeq));
    }

    /// <summary>
    /// Floating-point less than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLeq"/>
    public IntPtr MkFpaLt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaLt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaLt));
    }

    /// <summary>
    /// Floating-point greater than or equal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLeq"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaGeq(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaGeq(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaGeq));
    }

    /// <summary>
    /// Floating-point greater than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaLeq"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaGt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaGt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaGt));
    }

    /// <summary>
    /// Floating-point equality.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// Note that this is IEEE 754 equality (as opposed to SMT-LIB
    /// <code>
    /// =
    /// </code>
    /// ).
    /// </para>
    /// <para>
    /// t1 and t2 must have the same FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLeq"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaEq(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaEq(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaEq));
    }

    /// <summary>
    /// Predicate indicating whether t is a normal floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    public IntPtr MkFpaIsNormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsNormal(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsNormal));
    }

    /// <summary>
    /// Predicate indicating whether t is a subnormal floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    public IntPtr MkFpaIsSubnormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsSubnormal(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsSubnormal));
    }

    /// <summary>
    /// Predicate indicating whether t is a floating-point number with zero value, i.e., +zero or -zero.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaZero"/>
    public IntPtr MkFpaIsZero(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsZero(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsZero));
    }

    /// <summary>
    /// Predicate indicating whether t is a floating-point number representing +oo or -oo.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaInf"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    public IntPtr MkFpaIsInfinite(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsInfinite(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsInfinite));
    }

    /// <summary>
    /// Predicate indicating whether t is a NaN.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    /// <seealso cref="MkFpaNan"/>
    public IntPtr MkFpaIsNan(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsNan(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsNan));
    }

    /// <summary>
    /// Predicate indicating whether t is a negative floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaAbs"/>
    /// <seealso cref="MkFpaIsPositive"/>
    /// <seealso cref="MkFpaNeg"/>
    public IntPtr MkFpaIsNegative(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsNegative(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsNegative));
    }

    /// <summary>
    /// Predicate indicating whether t is a positive floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// <para>
    /// term of FloatingPoint sort
    /// </para>
    /// <para>
    /// t must have FloatingPoint sort.
    /// </para>
    /// </param>
    /// <seealso cref="MkFpaAbs"/>
    /// <seealso cref="MkFpaIsNegative"/>
    /// <seealso cref="MkFpaNeg"/>
    public IntPtr MkFpaIsPositive(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsPositive(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsPositive));
    }

    /// <summary>
    /// <para>
    /// Conversion of a single IEEE 754-2008 bit-vector into a floating-point number.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of a bit-vector term bv to a
    /// floating-point term of sort s.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="bv" ctype="Z3_ast">
    /// a bit-vector term
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// <para>
    /// floating-point sort
    /// </para>
    /// <para>
    /// s must be a FloatingPoint sort, t must be of bit-vector sort, and the bit-vector
    /// size of bv must be equal to
    /// <code>
    /// ebits+sbits
    /// </code>
    /// of s. The format of the bit-vector is
    /// as defined by the IEEE 754-2008 interchange format.
    /// </para>
    /// </param>
    public IntPtr MkFpaToFpBv(IntPtr c, IntPtr bv, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpBv(c, bv, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpBv));
    }

    /// <summary>
    /// <para>
    /// Conversion of a FloatingPoint term into another term of different FloatingPoint sort.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of a floating-point term t to a
    /// floating-point term of sort s. If necessary, the result will be rounded according
    /// to rounding mode rm.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// <para>
    /// floating-point sort
    /// </para>
    /// <para>
    /// s must be a FloatingPoint sort, rm must be of RoundingMode sort, t must be of floating-point sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaToFpFloat(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpFloat(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpFloat));
    }

    /// <summary>
    /// <para>
    /// Conversion of a term of real sort into a term of FloatingPoint sort.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of term t of real sort into a
    /// floating-point term of sort s. If necessary, the result will be rounded according
    /// to rounding mode rm.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of Real sort
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// <para>
    /// floating-point sort
    /// </para>
    /// <para>
    /// s must be a FloatingPoint sort, rm must be of RoundingMode sort, t must be of real sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaToFpReal(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpReal(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpReal));
    }

    /// <summary>
    /// <para>
    /// Conversion of a 2's complement signed bit-vector term into a term of FloatingPoint sort.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of the bit-vector term t into a
    /// floating-point term of sort s. The bit-vector t is taken to be in signed
    /// 2's complement format. If necessary, the result will be rounded according
    /// to rounding mode rm.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of bit-vector sort
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// <para>
    /// floating-point sort
    /// </para>
    /// <para>
    /// s must be a FloatingPoint sort, rm must be of RoundingMode sort, t must be of bit-vector sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaToFpSigned(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpSigned(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpSigned));
    }

    /// <summary>
    /// <para>
    /// Conversion of a 2's complement unsigned bit-vector term into a term of FloatingPoint sort.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of the bit-vector term t into a
    /// floating-point term of sort s. The bit-vector t is taken to be in unsigned
    /// 2's complement format. If necessary, the result will be rounded according
    /// to rounding mode rm.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of bit-vector sort
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// <para>
    /// floating-point sort
    /// </para>
    /// <para>
    /// s must be a FloatingPoint sort, rm must be of RoundingMode sort, t must be of bit-vector sort.
    /// </para>
    /// </param>
    public IntPtr MkFpaToFpUnsigned(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpUnsigned(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpUnsigned));
    }

    /// <summary>
    /// <para>
    /// Conversion of a floating-point term into an unsigned bit-vector.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of the floating-point term t into a
    /// bit-vector term of size sz in unsigned 2's complement format. If necessary, the result
    /// will be rounded according to rounding mode rm.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="sz" ctype="unsigned">
    /// size of the resulting bit-vector
    /// </param>
    public IntPtr MkFpaToUbv(IntPtr c, IntPtr rm, IntPtr t, uint sz)
    {
        var result = nativeLibrary.MkFpaToUbv(c, rm, t, sz);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToUbv));
    }

    /// <summary>
    /// <para>
    /// Conversion of a floating-point term into a signed bit-vector.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of the floating-point term t into a
    /// bit-vector term of size sz in signed 2's complement format. If necessary, the result
    /// will be rounded according to rounding mode rm.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="rm" ctype="Z3_ast">
    /// term of RoundingMode sort
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    /// <param name="sz" ctype="unsigned">
    /// size of the resulting bit-vector
    /// </param>
    public IntPtr MkFpaToSbv(IntPtr c, IntPtr rm, IntPtr t, uint sz)
    {
        var result = nativeLibrary.MkFpaToSbv(c, rm, t, sz);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToSbv));
    }

    /// <summary>
    /// <para>
    /// Conversion of a floating-point term into a real-numbered term.
    /// </para>
    /// <para>
    /// Produces a term that represents the conversion of the floating-point term t into a
    /// real number. Note that this type of conversion will often result in non-linear
    /// constraints over real terms.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// term of FloatingPoint sort
    /// </param>
    public IntPtr MkFpaToReal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaToReal(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToReal));
    }

}
