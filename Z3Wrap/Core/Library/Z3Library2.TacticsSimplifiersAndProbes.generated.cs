// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.TacticsSimplifiersAndProbes.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Return a tactic associated with the given name. The complete list of tactics may be obtained using the procedures
    /// <see cref="GetNumTactics"/>
    /// and
    /// <see cref="GetTacticName"/>
    /// . It may also be obtained using the command
    /// <c>
    /// (help-tactic)
    /// </c>
    /// in the SMT 2.0 front-end.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_string">
    /// string parameter
    /// </param>
    /// <remarks>
    /// Tactics are the basic building block for creating custom solvers for specific problem domains.
    /// </remarks>
    public IntPtr MkTactic(IntPtr c, string name)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var result = nativeLibrary.MkTactic(c, nameAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(MkTactic));
    }

    /// <summary>
    /// Increment the reference counter of the given tactic.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public void TacticIncRef(IntPtr c, IntPtr t)
    {
        nativeLibrary.TacticIncRef(c, t);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given tactic.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="g" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public void TacticDecRef(IntPtr c, IntPtr g)
    {
        nativeLibrary.TacticDecRef(c, g);
        CheckError(c);
    }

    /// <summary>
    /// Return a probe associated with the given name. The complete list of probes may be obtained using the procedures
    /// <see cref="GetNumProbes"/>
    /// and
    /// <see cref="GetProbeName"/>
    /// . It may also be obtained using the command
    /// <c>
    /// (help-tactic)
    /// </c>
    /// in the SMT 2.0 front-end.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_string">
    /// string parameter
    /// </param>
    /// <remarks>
    /// Probes are used to inspect a goal (aka problem) and collect information that may be used to decide which solver and/or preprocessing step will be used.
    /// </remarks>
    public IntPtr MkProbe(IntPtr c, string name)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var result = nativeLibrary.MkProbe(c, nameAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(MkProbe));
    }

    /// <summary>
    /// Increment the reference counter of the given probe.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    public void ProbeIncRef(IntPtr c, IntPtr p)
    {
        nativeLibrary.ProbeIncRef(c, p);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given probe.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    public void ProbeDecRef(IntPtr c, IntPtr p)
    {
        nativeLibrary.ProbeDecRef(c, p);
        CheckError(c);
    }

    /// <summary>
    /// Return a tactic that applies
    /// <c>
    /// t1
    /// </c>
    /// to a given goal and
    /// <c>
    /// t2
    /// </c>
    /// to every subgoal produced by
    /// <c>
    /// t1
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="t2" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public IntPtr TacticAndThen(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.TacticAndThen(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(TacticAndThen));
    }

    /// <summary>
    /// Return a tactic that first applies
    /// <c>
    /// t1
    /// </c>
    /// to a given goal, if it fails then returns the result of
    /// <c>
    /// t2
    /// </c>
    /// applied to the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="t2" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public IntPtr TacticOrElse(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.TacticOrElse(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(TacticOrElse));
    }

    /// <summary>
    /// Return a tactic that applies the given tactics in parallel.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="num" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="ts" ctype="Z3_tactic const[]">
    /// tactic parameter
    /// </param>
    public IntPtr TacticParOr(IntPtr c, uint num, IntPtr[] ts)
    {
        var result = nativeLibrary.TacticParOr(c, num, ts);
        CheckError(c);
        return CheckHandle(result, nameof(TacticParOr));
    }

    /// <summary>
    /// Return a tactic that applies
    /// <c>
    /// t1
    /// </c>
    /// to a given goal and then
    /// <c>
    /// t2
    /// </c>
    /// to every subgoal produced by
    /// <c>
    /// t1
    /// </c>
    /// . The subgoals are processed in parallel.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="t2" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public IntPtr TacticParAndThen(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.TacticParAndThen(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(TacticParAndThen));
    }

    /// <summary>
    /// Return a tactic that applies
    /// <c>
    /// t
    /// </c>
    /// to a given goal for
    /// <c>
    /// ms
    /// </c>
    /// milliseconds. If
    /// <c>
    /// t
    /// </c>
    /// does not terminate in
    /// <c>
    /// ms
    /// </c>
    /// milliseconds, then it fails.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="ms" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    public IntPtr TacticTryFor(IntPtr c, IntPtr t, uint ms)
    {
        var result = nativeLibrary.TacticTryFor(c, t, ms);
        CheckError(c);
        return CheckHandle(result, nameof(TacticTryFor));
    }

    /// <summary>
    /// Return a tactic that applies
    /// <c>
    /// t
    /// </c>
    /// to a given goal is the probe
    /// <c>
    /// p
    /// </c>
    /// evaluates to true. If
    /// <c>
    /// p
    /// </c>
    /// evaluates to false, then the new tactic behaves like the skip tactic.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public IntPtr TacticWhen(IntPtr c, IntPtr p, IntPtr t)
    {
        var result = nativeLibrary.TacticWhen(c, p, t);
        CheckError(c);
        return CheckHandle(result, nameof(TacticWhen));
    }

    /// <summary>
    /// Return a tactic that applies
    /// <c>
    /// t1
    /// </c>
    /// to a given goal if the probe
    /// <c>
    /// p
    /// </c>
    /// evaluates to true, and
    /// <c>
    /// t2
    /// </c>
    /// if
    /// <c>
    /// p
    /// </c>
    /// evaluates to false.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="t1" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="t2" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public IntPtr TacticCond(IntPtr c, IntPtr p, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.TacticCond(c, p, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(TacticCond));
    }

    /// <summary>
    /// Return a tactic that keeps applying
    /// <c>
    /// t
    /// </c>
    /// until the goal is not modified anymore or the maximum number of iterations
    /// <c>
    /// max
    /// </c>
    /// is reached.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="max" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    public IntPtr TacticRepeat(IntPtr c, IntPtr t, uint max)
    {
        var result = nativeLibrary.TacticRepeat(c, t, max);
        CheckError(c);
        return CheckHandle(result, nameof(TacticRepeat));
    }

    /// <summary>
    /// Return a tactic that just return the given goal.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    public IntPtr TacticSkip(IntPtr c)
    {
        var result = nativeLibrary.TacticSkip(c);
        CheckError(c);
        return CheckHandle(result, nameof(TacticSkip));
    }

    /// <summary>
    /// Return a tactic that always fails.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    public IntPtr TacticFail(IntPtr c)
    {
        var result = nativeLibrary.TacticFail(c);
        CheckError(c);
        return CheckHandle(result, nameof(TacticFail));
    }

    /// <summary>
    /// Return a tactic that fails if the probe
    /// <c>
    /// p
    /// </c>
    /// evaluates to false.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    public IntPtr TacticFailIf(IntPtr c, IntPtr p)
    {
        var result = nativeLibrary.TacticFailIf(c, p);
        CheckError(c);
        return CheckHandle(result, nameof(TacticFailIf));
    }

    /// <summary>
    /// Return a tactic that fails if the goal is not trivially satisfiable (i.e., empty) or trivially unsatisfiable (i.e., contains false).
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    public IntPtr TacticFailIfNotDecided(IntPtr c)
    {
        var result = nativeLibrary.TacticFailIfNotDecided(c);
        CheckError(c);
        return CheckHandle(result, nameof(TacticFailIfNotDecided));
    }

    /// <summary>
    /// Return a tactic that applies
    /// <c>
    /// t
    /// </c>
    /// using the given set of parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="p" ctype="Z3_params">
    /// params parameter
    /// </param>
    public IntPtr TacticUsingParams(IntPtr c, IntPtr t, IntPtr p)
    {
        var result = nativeLibrary.TacticUsingParams(c, t, p);
        CheckError(c);
        return CheckHandle(result, nameof(TacticUsingParams));
    }

    /// <summary>
    /// Return a simplifier associated with the given name. The complete list of simplifiers may be obtained using the procedures
    /// <see cref="GetNumSimplifiers"/>
    /// and
    /// <see cref="GetSimplifierName"/>
    /// . It may also be obtained using the command
    /// <c>
    /// (help-simplifier)
    /// </c>
    /// in the SMT 2.0 front-end.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_string">
    /// string parameter
    /// </param>
    /// <remarks>
    /// Simplifiers are the basic building block for creating custom solvers for specific problem domains.
    /// </remarks>
    public IntPtr MkSimplifier(IntPtr c, string name)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var result = nativeLibrary.MkSimplifier(c, nameAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(MkSimplifier));
    }

    /// <summary>
    /// Increment the reference counter of the given simplifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    public void SimplifierIncRef(IntPtr c, IntPtr t)
    {
        nativeLibrary.SimplifierIncRef(c, t);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given simplifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="g" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    public void SimplifierDecRef(IntPtr c, IntPtr g)
    {
        nativeLibrary.SimplifierDecRef(c, g);
        CheckError(c);
    }

    /// <summary>
    /// Attach simplifier to a solver. The solver will use the simplifier for incremental pre-processing.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="solver" ctype="Z3_solver">
    /// solver parameter
    /// </param>
    /// <param name="simplifier" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    public IntPtr SolverAddSimplifier(IntPtr c, IntPtr solver, IntPtr simplifier)
    {
        var result = nativeLibrary.SolverAddSimplifier(c, solver, simplifier);
        CheckError(c);
        return CheckHandle(result, nameof(SolverAddSimplifier));
    }

    /// <summary>
    /// Return a simplifier that applies
    /// <c>
    /// t1
    /// </c>
    /// to a given goal and
    /// <c>
    /// t2
    /// </c>
    /// to every subgoal produced by
    /// <c>
    /// t1
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    /// <param name="t2" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    public IntPtr SimplifierAndThen(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.SimplifierAndThen(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(SimplifierAndThen));
    }

    /// <summary>
    /// Return a simplifier that applies
    /// <c>
    /// t
    /// </c>
    /// using the given set of parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    /// <param name="p" ctype="Z3_params">
    /// params parameter
    /// </param>
    public IntPtr SimplifierUsingParams(IntPtr c, IntPtr t, IntPtr p)
    {
        var result = nativeLibrary.SimplifierUsingParams(c, t, p);
        CheckError(c);
        return CheckHandle(result, nameof(SimplifierUsingParams));
    }

    /// <summary>
    /// Return the number of builtin simplifiers available in Z3.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <seealso cref="GetSimplifierName"/>
    public uint GetNumSimplifiers(IntPtr c)
    {
        var result = nativeLibrary.GetNumSimplifiers(c);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the name of the idx simplifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_get_num_simplifiers(c)
    /// </remarks>
    /// <seealso cref="GetNumSimplifiers"/>
    public IntPtr GetSimplifierName(IntPtr c, uint i)
    {
        var result = nativeLibrary.GetSimplifierName(c, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetSimplifierName));
    }

    /// <summary>
    /// Return a string containing a description of parameters accepted by the given simplifier.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    public IntPtr SimplifierGetHelp(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.SimplifierGetHelp(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(SimplifierGetHelp));
    }

    /// <summary>
    /// Return the parameter description set for the given simplifier object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_simplifier">
    /// simplifier parameter
    /// </param>
    public IntPtr SimplifierGetParamDescrs(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.SimplifierGetParamDescrs(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(SimplifierGetParamDescrs));
    }

    /// <summary>
    /// Return a string containing a description of the simplifier with the given name.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_string">
    /// string parameter
    /// </param>
    public IntPtr SimplifierGetDescr(IntPtr c, string name)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var result = nativeLibrary.SimplifierGetDescr(c, nameAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(SimplifierGetDescr));
    }

    /// <summary>
    /// Return a probe that always evaluates to val.
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="val" ctype="double">
    /// double parameter
    /// </param>
    public IntPtr ProbeConst(IntPtr x, double val)
    {
        var result = nativeLibrary.ProbeConst(x, val);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeConst));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when the value returned by
    /// <c>
    /// p1
    /// </c>
    /// is less than the value returned by
    /// <c>
    /// p2
    /// </c>
    /// .
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p1" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="p2" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeLt(IntPtr x, IntPtr p1, IntPtr p2)
    {
        var result = nativeLibrary.ProbeLt(x, p1, p2);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeLt));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when the value returned by
    /// <c>
    /// p1
    /// </c>
    /// is greater than the value returned by
    /// <c>
    /// p2
    /// </c>
    /// .
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p1" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="p2" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeGt(IntPtr x, IntPtr p1, IntPtr p2)
    {
        var result = nativeLibrary.ProbeGt(x, p1, p2);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeGt));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when the value returned by
    /// <c>
    /// p1
    /// </c>
    /// is less than or equal to the value returned by
    /// <c>
    /// p2
    /// </c>
    /// .
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p1" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="p2" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeLe(IntPtr x, IntPtr p1, IntPtr p2)
    {
        var result = nativeLibrary.ProbeLe(x, p1, p2);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeLe));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when the value returned by
    /// <c>
    /// p1
    /// </c>
    /// is greater than or equal to the value returned by
    /// <c>
    /// p2
    /// </c>
    /// .
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p1" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="p2" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeGe(IntPtr x, IntPtr p1, IntPtr p2)
    {
        var result = nativeLibrary.ProbeGe(x, p1, p2);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeGe));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when the value returned by
    /// <c>
    /// p1
    /// </c>
    /// is equal to the value returned by
    /// <c>
    /// p2
    /// </c>
    /// .
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p1" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="p2" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeEq(IntPtr x, IntPtr p1, IntPtr p2)
    {
        var result = nativeLibrary.ProbeEq(x, p1, p2);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeEq));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when
    /// <c>
    /// p1
    /// </c>
    /// and
    /// <c>
    /// p2
    /// </c>
    /// evaluates to true.
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p1" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="p2" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeAnd(IntPtr x, IntPtr p1, IntPtr p2)
    {
        var result = nativeLibrary.ProbeAnd(x, p1, p2);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeAnd));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when
    /// <c>
    /// p1
    /// </c>
    /// or
    /// <c>
    /// p2
    /// </c>
    /// evaluates to true.
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p1" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="p2" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeOr(IntPtr x, IntPtr p1, IntPtr p2)
    {
        var result = nativeLibrary.ProbeOr(x, p1, p2);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeOr));
    }

    /// <summary>
    /// Return a probe that evaluates to "true" when
    /// <c>
    /// p
    /// </c>
    /// does not evaluate to true.
    /// </summary>
    /// <param name="x" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <remarks>
    /// For probes, "true" is any value different from 0.0.
    /// </remarks>
    public IntPtr ProbeNot(IntPtr x, IntPtr p)
    {
        var result = nativeLibrary.ProbeNot(x, p);
        CheckError(x);
        return CheckHandle(result, nameof(ProbeNot));
    }

    /// <summary>
    /// Return the number of builtin tactics available in Z3.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <seealso cref="GetTacticName"/>
    public uint GetNumTactics(IntPtr c)
    {
        var result = nativeLibrary.GetNumTactics(c);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the name of the idx tactic.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_get_num_tactics(c)
    /// </remarks>
    /// <seealso cref="GetNumTactics"/>
    public IntPtr GetTacticName(IntPtr c, uint i)
    {
        var result = nativeLibrary.GetTacticName(c, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetTacticName));
    }

    /// <summary>
    /// Return the number of builtin probes available in Z3.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <seealso cref="GetProbeName"/>
    public uint GetNumProbes(IntPtr c)
    {
        var result = nativeLibrary.GetNumProbes(c);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the name of the
    /// <c>
    /// i
    /// </c>
    /// probe.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_get_num_probes(c)
    /// </remarks>
    /// <seealso cref="GetNumProbes"/>
    public IntPtr GetProbeName(IntPtr c, uint i)
    {
        var result = nativeLibrary.GetProbeName(c, i);
        CheckError(c);
        return CheckHandle(result, nameof(GetProbeName));
    }

    /// <summary>
    /// Return a string containing a description of parameters accepted by the given tactic.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public IntPtr TacticGetHelp(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.TacticGetHelp(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(TacticGetHelp));
    }

    /// <summary>
    /// Return the parameter description set for the given tactic object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    public IntPtr TacticGetParamDescrs(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.TacticGetParamDescrs(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(TacticGetParamDescrs));
    }

    /// <summary>
    /// Return a string containing a description of the tactic with the given name.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_string">
    /// string parameter
    /// </param>
    public IntPtr TacticGetDescr(IntPtr c, string name)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var result = nativeLibrary.TacticGetDescr(c, nameAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(TacticGetDescr));
    }

    /// <summary>
    /// Return a string containing a description of the probe with the given name.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_string">
    /// string parameter
    /// </param>
    public IntPtr ProbeGetDescr(IntPtr c, string name)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var result = nativeLibrary.ProbeGetDescr(c, nameAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(ProbeGetDescr));
    }

    /// <summary>
    /// Execute the probe over the goal. The probe always produce a double value. "Boolean" probes return 0.0 for false, and a value different from 0.0 for true.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="p" ctype="Z3_probe">
    /// probe parameter
    /// </param>
    /// <param name="g" ctype="Z3_goal">
    /// goal parameter
    /// </param>
    public double ProbeApply(IntPtr c, IntPtr p, IntPtr g)
    {
        var result = nativeLibrary.ProbeApply(c, p, g);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Apply tactic
    /// <c>
    /// t
    /// </c>
    /// to the goal
    /// <c>
    /// g
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="g" ctype="Z3_goal">
    /// goal parameter
    /// </param>
    /// <seealso cref="TacticApplyEx"/>
    public IntPtr TacticApply(IntPtr c, IntPtr t, IntPtr g)
    {
        var result = nativeLibrary.TacticApply(c, t, g);
        CheckError(c);
        return CheckHandle(result, nameof(TacticApply));
    }

    /// <summary>
    /// Apply tactic
    /// <c>
    /// t
    /// </c>
    /// to the goal
    /// <c>
    /// g
    /// </c>
    /// using the parameter set
    /// <c>
    /// p
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t" ctype="Z3_tactic">
    /// tactic parameter
    /// </param>
    /// <param name="g" ctype="Z3_goal">
    /// goal parameter
    /// </param>
    /// <param name="p" ctype="Z3_params">
    /// params parameter
    /// </param>
    /// <seealso cref="TacticApply"/>
    public IntPtr TacticApplyEx(IntPtr c, IntPtr t, IntPtr g, IntPtr p)
    {
        var result = nativeLibrary.TacticApplyEx(c, t, g, p);
        CheckError(c);
        return CheckHandle(result, nameof(TacticApplyEx));
    }

    /// <summary>
    /// Increment the reference counter of the given
    /// <c>
    /// Z3_apply_result
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="r" ctype="Z3_apply_result">
    /// apply_result parameter
    /// </param>
    public void ApplyResultIncRef(IntPtr c, IntPtr r)
    {
        nativeLibrary.ApplyResultIncRef(c, r);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given
    /// <c>
    /// Z3_apply_result
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="r" ctype="Z3_apply_result">
    /// apply_result parameter
    /// </param>
    public void ApplyResultDecRef(IntPtr c, IntPtr r)
    {
        nativeLibrary.ApplyResultDecRef(c, r);
        CheckError(c);
    }

    /// <summary>
    /// Convert the
    /// <c>
    /// Z3_apply_result
    /// </c>
    /// object returned by
    /// <see cref="TacticApply"/>
    /// into a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="r" ctype="Z3_apply_result">
    /// apply_result parameter
    /// </param>
    public IntPtr ApplyResultToString(IntPtr c, IntPtr r)
    {
        var result = nativeLibrary.ApplyResultToString(c, r);
        CheckError(c);
        return CheckHandle(result, nameof(ApplyResultToString));
    }

    /// <summary>
    /// Return the number of subgoals in the
    /// <c>
    /// Z3_apply_result
    /// </c>
    /// object returned by
    /// <see cref="TacticApply"/>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="r" ctype="Z3_apply_result">
    /// apply_result parameter
    /// </param>
    /// <seealso cref="ApplyResultGetSubgoal"/>
    public uint ApplyResultGetNumSubgoals(IntPtr c, IntPtr r)
    {
        var result = nativeLibrary.ApplyResultGetNumSubgoals(c, r);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return one of the subgoals in the
    /// <c>
    /// Z3_apply_result
    /// </c>
    /// object returned by
    /// <see cref="TacticApply"/>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="r" ctype="Z3_apply_result">
    /// apply_result parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_apply_result_get_num_subgoals(c, r)
    /// </remarks>
    /// <seealso cref="ApplyResultGetNumSubgoals"/>
    public IntPtr ApplyResultGetSubgoal(IntPtr c, IntPtr r, uint i)
    {
        var result = nativeLibrary.ApplyResultGetSubgoal(c, r, i);
        CheckError(c);
        return CheckHandle(result, nameof(ApplyResultGetSubgoal));
    }

}
