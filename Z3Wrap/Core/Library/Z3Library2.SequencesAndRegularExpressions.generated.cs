// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.SequencesAndRegularExpressions.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Create a sequence sort out of the sort for the elements.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public IntPtr MkSeqSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkSeqSort(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqSort));
    }

    /// <summary>
    /// Check if s is a sequence sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public bool IsSeqSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsSeqSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Retrieve basis sort for sequence sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public IntPtr GetSeqSortBasis(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetSeqSortBasis(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(GetSeqSortBasis));
    }

    /// <summary>
    /// Create a regular expression sort out of a sequence sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="seq" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public IntPtr MkReSort(IntPtr c, IntPtr seq)
    {
        var result = nativeLibrary.MkReSort(c, seq);
        CheckError(c);
        return CheckHandle(result, nameof(MkReSort));
    }

    /// <summary>
    /// Check if s is a regular expression sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public bool IsReSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsReSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Retrieve basis sort for regex sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public IntPtr GetReSortBasis(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetReSortBasis(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(GetReSortBasis));
    }

    /// <summary>
    /// <para>
    /// Create a sort for unicode strings.
    /// </para>
    /// <para>
    /// The sort for characters can be changed to ASCII by setting
    /// the global parameter encoding to ascii, or alternative
    /// to 16 bit characters by setting encoding to bmp.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    public IntPtr MkStringSort(IntPtr c)
    {
        var result = nativeLibrary.MkStringSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkStringSort));
    }

    /// <summary>
    /// <para>
    /// Create a sort for unicode characters.
    /// </para>
    /// <para>
    /// The sort for characters can be changed to ASCII by setting
    /// the global parameter encoding to ascii, or alternative
    /// to 16 bit characters by setting encoding to bmp.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    public IntPtr MkCharSort(IntPtr c)
    {
        var result = nativeLibrary.MkCharSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharSort));
    }

    /// <summary>
    /// Check if s is a string sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public bool IsStringSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsStringSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Check if s is a character sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public bool IsCharSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsCharSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Create a string constant out of the string that is passed in
    /// The string may contain escape encoding for non-printable characters
    /// or characters outside of the basic printable ASCII range. For example,
    /// the escape encoding \\u{0} represents the character 0 and the encoding
    /// \\u{100} represents the character 256.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_string">
    /// string parameter
    /// </param>
    public IntPtr MkString(IntPtr c, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var result = nativeLibrary.MkString(c, sAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(MkString));
    }

    /// <summary>
    /// Create a string constant out of the string that is passed in
    /// It takes the length of the string as well to take into account
    /// 0 characters. The string is treated as if it is unescaped so a sequence
    /// of characters \\u{0} is treated as 5 characters and not the character 0.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="len" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="s" ctype="Z3_string">
    /// string parameter
    /// </param>
    public IntPtr MkLstring(IntPtr c, uint len, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var result = nativeLibrary.MkLstring(c, len, sAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(MkLstring));
    }

    /// <summary>
    /// Create a string constant out of the string that is passed in
    /// It takes the length of the string as well to take into account
    /// 0 characters. The string is unescaped.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="len" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="chars" ctype="unsigned const[]">
    /// unsigned parameter
    /// </param>
    public IntPtr MkU32string(IntPtr c, uint len, uint[] chars)
    {
        var result = nativeLibrary.MkU32string(c, len, chars);
        CheckError(c);
        return CheckHandle(result, nameof(MkU32string));
    }

    /// <summary>
    /// Determine if s is a string constant.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public bool IsString(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsString(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Retrieve the string constant stored in s.
    /// Characters outside the basic printable ASCII range are escaped.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// </remarks>
    public IntPtr GetString(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetString(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(GetString));
    }

    /// <summary>
    /// Retrieve the string constant stored in s. The string can contain escape sequences.
    /// Characters in the range 1 to 255 are literal.
    /// Characters in the range 0, and 256 above are escaped.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="length" ctype="unsigned*">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// </remarks>
    public IntPtr GetLstring(IntPtr c, IntPtr s, IntPtr length)
    {
        var result = nativeLibrary.GetLstring(c, s, length);
        CheckError(c);
        return CheckHandle(result, nameof(GetLstring));
    }

    /// <summary>
    /// Retrieve the length of the unescaped string constant stored in s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// </remarks>
    public uint GetStringLength(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetStringLength(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Retrieve the unescaped string constant stored in s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="length" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="contents" ctype="unsigned[]">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// Precondition: length contains the number of characters in s
    /// </remarks>
    public void GetStringContents(IntPtr c, IntPtr s, uint length, uint[] contents)
    {
        nativeLibrary.GetStringContents(c, s, length, contents);
        CheckError(c);
    }

    /// <summary>
    /// Create an empty sequence of the sequence sort seq.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="seq" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <remarks>
    /// Precondition: s is a sequence sort.
    /// </remarks>
    public IntPtr MkSeqEmpty(IntPtr c, IntPtr seq)
    {
        var result = nativeLibrary.MkSeqEmpty(c, seq);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqEmpty));
    }

    /// <summary>
    /// Create a unit sequence of a.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqUnit(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.MkSeqUnit(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqUnit));
    }

    /// <summary>
    /// Concatenate sequences.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkSeqConcat(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkSeqConcat(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqConcat));
    }

    /// <summary>
    /// Check if prefix is a prefix of s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="prefix" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: prefix and s are the same sequence sorts.
    /// </remarks>
    public IntPtr MkSeqPrefix(IntPtr c, IntPtr prefix, IntPtr s)
    {
        var result = nativeLibrary.MkSeqPrefix(c, prefix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqPrefix));
    }

    /// <summary>
    /// Check if suffix is a suffix of s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="suffix" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: suffix and s are the same sequence sorts.
    /// </remarks>
    public IntPtr MkSeqSuffix(IntPtr c, IntPtr suffix, IntPtr s)
    {
        var result = nativeLibrary.MkSeqSuffix(c, suffix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqSuffix));
    }

    /// <summary>
    /// Check if container contains containee.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="container" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="containee" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: container and containee are the same sequence sorts.
    /// </remarks>
    public IntPtr MkSeqContains(IntPtr c, IntPtr container, IntPtr containee)
    {
        var result = nativeLibrary.MkSeqContains(c, container, containee);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqContains));
    }

    /// <summary>
    /// Check if s1 is lexicographically strictly less than s2.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="prefix" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: s1 and s2 are strings
    /// </remarks>
    public IntPtr MkStrLt(IntPtr c, IntPtr prefix, IntPtr s)
    {
        var result = nativeLibrary.MkStrLt(c, prefix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkStrLt));
    }

    /// <summary>
    /// Check if s1 is equal or lexicographically strictly less than s2.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="prefix" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: s1 and s2 are strings
    /// </remarks>
    public IntPtr MkStrLe(IntPtr c, IntPtr prefix, IntPtr s)
    {
        var result = nativeLibrary.MkStrLe(c, prefix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkStrLe));
    }

    /// <summary>
    /// Extract subsequence starting at offset of length.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="offset" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="length" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqExtract(IntPtr c, IntPtr s, IntPtr offset, IntPtr length)
    {
        var result = nativeLibrary.MkSeqExtract(c, s, offset, length);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqExtract));
    }

    /// <summary>
    /// Replace the first occurrence of src with dst in s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="src" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="dst" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqReplace(IntPtr c, IntPtr s, IntPtr src, IntPtr dst)
    {
        var result = nativeLibrary.MkSeqReplace(c, s, src, dst);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqReplace));
    }

    /// <summary>
    /// Retrieve from s the unit sequence positioned at position index.
    /// The sequence is empty if the index is out of bounds.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="index" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqAt(IntPtr c, IntPtr s, IntPtr index)
    {
        var result = nativeLibrary.MkSeqAt(c, s, index);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqAt));
    }

    /// <summary>
    /// Retrieve from s the element positioned at position index.
    /// The function is under-specified if the index is out of bounds.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="index" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqNth(IntPtr c, IntPtr s, IntPtr index)
    {
        var result = nativeLibrary.MkSeqNth(c, s, index);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqNth));
    }

    /// <summary>
    /// Return the length of the sequence s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqLength(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkSeqLength(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqLength));
    }

    /// <summary>
    /// Return index of the first occurrence of substr in s starting from offset offset.
    /// If s does not contain substr, then the value is -1, if offset is the length of s, then the value is -1 as well.
    /// The value is -1 if offset is negative or larger than the length of s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="substr" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="offset" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqIndex(IntPtr c, IntPtr s, IntPtr substr, IntPtr offset)
    {
        var result = nativeLibrary.MkSeqIndex(c, s, substr, offset);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqIndex));
    }

    /// <summary>
    /// Return index of the last occurrence of substr in s.
    /// If s does not contain substr, then the value is -1,
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="substr" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqLastIndex(IntPtr c, IntPtr s, IntPtr substr)
    {
        var result = nativeLibrary.MkSeqLastIndex(c, s, substr);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqLastIndex));
    }

    /// <summary>
    /// Create a map of the function f over the sequence s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqMap(IntPtr c, IntPtr f, IntPtr s)
    {
        var result = nativeLibrary.MkSeqMap(c, f, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqMap));
    }

    /// <summary>
    /// Create a map of the function f over the sequence s starting at index i.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="i" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqMapi(IntPtr c, IntPtr f, IntPtr i, IntPtr s)
    {
        var result = nativeLibrary.MkSeqMapi(c, f, i, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqMapi));
    }

    /// <summary>
    /// Create a fold of the function f over the sequence s with accumulator a.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqFoldl(IntPtr c, IntPtr f, IntPtr a, IntPtr s)
    {
        var result = nativeLibrary.MkSeqFoldl(c, f, a, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqFoldl));
    }

    /// <summary>
    /// Create a fold with index tracking of the function f over the sequence s with accumulator a starting at index i.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="i" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqFoldli(IntPtr c, IntPtr f, IntPtr i, IntPtr a, IntPtr s)
    {
        var result = nativeLibrary.MkSeqFoldli(c, f, i, a, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqFoldli));
    }

    /// <summary>
    /// Convert string to integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkStrToInt(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkStrToInt(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkStrToInt));
    }

    /// <summary>
    /// Integer to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkIntToStr(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkIntToStr(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkIntToStr));
    }

    /// <summary>
    /// String to code conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkStringToCode(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.MkStringToCode(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(MkStringToCode));
    }

    /// <summary>
    /// Code to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkStringFromCode(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.MkStringFromCode(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(MkStringFromCode));
    }

    /// <summary>
    /// Unsigned bit-vector to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkUbvToStr(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkUbvToStr(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkUbvToStr));
    }

    /// <summary>
    /// Signed bit-vector to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSbvToStr(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkSbvToStr(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSbvToStr));
    }

    /// <summary>
    /// Create a regular expression that accepts the sequence seq.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="seq" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqToRe(IntPtr c, IntPtr seq)
    {
        var result = nativeLibrary.MkSeqToRe(c, seq);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqToRe));
    }

    /// <summary>
    /// Check if seq is in the language generated by the regular expression re.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="seq" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="re" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSeqInRe(IntPtr c, IntPtr seq, IntPtr re)
    {
        var result = nativeLibrary.MkSeqInRe(c, seq, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqInRe));
    }

    /// <summary>
    /// Create the regular language re+.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkRePlus(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkRePlus(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkRePlus));
    }

    /// <summary>
    /// Create the regular language re*.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkReStar(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReStar(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReStar));
    }

    /// <summary>
    /// Create the regular language \c [re].
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkReOption(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReOption(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReOption));
    }

    /// <summary>
    /// Create the union of the regular languages.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkReUnion(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkReUnion(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkReUnion));
    }

    /// <summary>
    /// Create the concatenation of the regular languages.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkReConcat(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkReConcat(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkReConcat));
    }

    /// <summary>
    /// Create the range regular expression over two sequences of length 1.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="lo" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="hi" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkReRange(IntPtr c, IntPtr lo, IntPtr hi)
    {
        var result = nativeLibrary.MkReRange(c, lo, hi);
        CheckError(c);
        return CheckHandle(result, nameof(MkReRange));
    }

    /// <summary>
    /// Create a regular expression that accepts all singleton sequences of the regular expression sort
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="regexSort" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    public IntPtr MkReAllchar(IntPtr c, IntPtr regexSort)
    {
        var result = nativeLibrary.MkReAllchar(c, regexSort);
        CheckError(c);
        return CheckHandle(result, nameof(MkReAllchar));
    }

    /// <summary>
    /// Create a regular expression loop. The supplied regular expression r is repeated
    /// between lo and hi times. The lo should be below hi with one exception: when
    /// supplying the value hi as 0, the meaning is to repeat the argument r at least
    /// lo number of times, and with an unbounded upper bound.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="r" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="lo" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="hi" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    public IntPtr MkReLoop(IntPtr c, IntPtr r, uint lo, uint hi)
    {
        var result = nativeLibrary.MkReLoop(c, r, lo, hi);
        CheckError(c);
        return CheckHandle(result, nameof(MkReLoop));
    }

    /// <summary>
    /// Create a power regular expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    public IntPtr MkRePower(IntPtr c, IntPtr re, uint n)
    {
        var result = nativeLibrary.MkRePower(c, re, n);
        CheckError(c);
        return CheckHandle(result, nameof(MkRePower));
    }

    /// <summary>
    /// Create the intersection of the regular languages.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkReIntersect(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkReIntersect(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkReIntersect));
    }

    /// <summary>
    /// Create the complement of the regular language re.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkReComplement(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReComplement(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReComplement));
    }

    /// <summary>
    /// Create the difference of regular expressions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="re2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkReDiff(IntPtr c, IntPtr re1, IntPtr re2)
    {
        var result = nativeLibrary.MkReDiff(c, re1, re2);
        CheckError(c);
        return CheckHandle(result, nameof(MkReDiff));
    }

    /// <summary>
    /// Create an empty regular expression of sort re.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <remarks>
    /// Precondition: re is a regular expression sort.
    /// </remarks>
    public IntPtr MkReEmpty(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReEmpty(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReEmpty));
    }

    /// <summary>
    /// Create an universal regular expression of sort re.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="re" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <remarks>
    /// Precondition: re is a regular expression sort.
    /// </remarks>
    public IntPtr MkReFull(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReFull(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReFull));
    }

    /// <summary>
    /// Create a character literal
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="ch" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    public IntPtr MkChar(IntPtr c, uint ch)
    {
        var result = nativeLibrary.MkChar(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkChar));
    }

    /// <summary>
    /// Create less than or equal to between two characters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="ch1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="ch2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkCharLe(IntPtr c, IntPtr ch1, IntPtr ch2)
    {
        var result = nativeLibrary.MkCharLe(c, ch1, ch2);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharLe));
    }

    /// <summary>
    /// Create an integer (code point) from character.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="ch" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkCharToInt(IntPtr c, IntPtr ch)
    {
        var result = nativeLibrary.MkCharToInt(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharToInt));
    }

    /// <summary>
    /// Create a bit-vector (code point) from character.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="ch" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkCharToBv(IntPtr c, IntPtr ch)
    {
        var result = nativeLibrary.MkCharToBv(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharToBv));
    }

    /// <summary>
    /// Create a character from a bit-vector (code point).
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="bv" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkCharFromBv(IntPtr c, IntPtr bv)
    {
        var result = nativeLibrary.MkCharFromBv(c, bv);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharFromBv));
    }

    /// <summary>
    /// Create a check if the character is a digit.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="ch" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkCharIsDigit(IntPtr c, IntPtr ch)
    {
        var result = nativeLibrary.MkCharIsDigit(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharIsDigit));
    }

}
