// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Sorts.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Create a free (uninterpreted) type using the given name (symbol).
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s">
    /// symbol parameter
    /// </param>
    /// <remarks>
    /// Two free types are considered the same iff the have the same name.
    /// </remarks>
    public IntPtr MkUninterpretedSort(IntPtr c, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkUninterpretedSort(c, sSymbol);
        CheckError(c);
        return CheckHandle(result, nameof(MkUninterpretedSort));
    }

    /// <summary>
    /// Create a free (uninterpreted) type using the given name (symbol).
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_symbol">
    /// symbol parameter
    /// </param>
    /// <remarks>
    /// Two free types are considered the same iff the have the same name.
    /// </remarks>
    public IntPtr MkUninterpretedSortOriginal(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkUninterpretedSort(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkUninterpretedSort));
    }

    /// <summary>
    /// Create a type variable.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s">
    /// symbol parameter
    /// </param>
    /// <remarks>
    /// Functions using type variables can be applied to instantiations that match the signature of the function. Assertions using type variables correspond to assertions over all possible instantiations.
    /// </remarks>
    public IntPtr MkTypeVariable(IntPtr c, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkTypeVariable(c, sSymbol);
        CheckError(c);
        return CheckHandle(result, nameof(MkTypeVariable));
    }

    /// <summary>
    /// Create a type variable.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_symbol">
    /// symbol parameter
    /// </param>
    /// <remarks>
    /// Functions using type variables can be applied to instantiations that match the signature of the function. Assertions using type variables correspond to assertions over all possible instantiations.
    /// </remarks>
    public IntPtr MkTypeVariableOriginal(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkTypeVariable(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkTypeVariable));
    }

    /// <summary>
    /// Create the Boolean type.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <remarks>
    /// This type is used to create propositional variables and predicates.
    /// </remarks>
    public IntPtr MkBoolSort(IntPtr c)
    {
        var result = nativeLibrary.MkBoolSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkBoolSort));
    }

    /// <summary>
    /// Create the integer type.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <remarks>
    /// This type is not the int type found in programming languages. A machine integer can be represented using bit-vectors. The function
    /// <see cref="MkBvSort"/>
    /// creates a bit-vector type.
    /// </remarks>
    /// <seealso cref="MkBvSort"/>
    public IntPtr MkIntSort(IntPtr c)
    {
        var result = nativeLibrary.MkIntSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkIntSort));
    }

    /// <summary>
    /// Create the real type.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <remarks>
    /// Note that this type is not a floating point number.
    /// </remarks>
    public IntPtr MkRealSort(IntPtr c)
    {
        var result = nativeLibrary.MkRealSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkRealSort));
    }

    /// <summary>
    /// Create a bit-vector type of the given size.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="sz" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// This type can also be seen as a machine integer.
    /// The size of the bit-vector type must be greater than zero.
    /// </remarks>
    public IntPtr MkBvSort(IntPtr c, uint sz)
    {
        var result = nativeLibrary.MkBvSort(c, sz);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvSort));
    }

    /// <summary>
    /// Create a named finite domain sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name">
    /// symbol parameter
    /// </param>
    /// <param name="size" ctype="uint64_t">
    /// uint64_t parameter
    /// </param>
    /// <remarks>
    /// To create constants that belong to the finite domain, use the APIs for creating numerals and pass a numeric constant together with the sort returned by this call. The numeric constant should be between 0 and the less than the size of the domain.
    /// </remarks>
    /// <seealso cref="GetFiniteDomainSortSize"/>
    public IntPtr MkFiniteDomainSort(IntPtr c, string name, ulong size)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var nameSymbol = nativeLibrary.MkStringSymbol(c, nameAnsi);
        CheckError(c);
        var result = nativeLibrary.MkFiniteDomainSort(c, nameSymbol, size);
        CheckError(c);
        return CheckHandle(result, nameof(MkFiniteDomainSort));
    }

    /// <summary>
    /// Create a named finite domain sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_symbol">
    /// symbol parameter
    /// </param>
    /// <param name="size" ctype="uint64_t">
    /// uint64_t parameter
    /// </param>
    /// <remarks>
    /// To create constants that belong to the finite domain, use the APIs for creating numerals and pass a numeric constant together with the sort returned by this call. The numeric constant should be between 0 and the less than the size of the domain.
    /// </remarks>
    /// <seealso cref="GetFiniteDomainSortSize"/>
    public IntPtr MkFiniteDomainSortOriginal(IntPtr c, IntPtr name, ulong size)
    {
        var result = nativeLibrary.MkFiniteDomainSort(c, name, size);
        CheckError(c);
        return CheckHandle(result, nameof(MkFiniteDomainSort));
    }

    /// <summary>
    /// Create an array type.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="domain" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <param name="range" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <remarks>
    /// We usually represent the array type as:
    /// <c>
    /// [domain -&gt; range]
    /// </c>
    /// . Arrays are usually used to model the heap/memory in software verification.
    /// </remarks>
    /// <seealso cref="MkSelect"/>
    /// <seealso cref="MkStore"/>
    public IntPtr MkArraySort(IntPtr c, IntPtr domain, IntPtr range)
    {
        var result = nativeLibrary.MkArraySort(c, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkArraySort));
    }

    /// <summary>
    /// Create an array type with N arguments.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="domain" ctype="Z3_sort const *">
    /// sort parameter
    /// </param>
    /// <param name="range" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <seealso cref="MkSelectN"/>
    /// <seealso cref="MkStoreN"/>
    public IntPtr MkArraySortN(IntPtr c, uint n, IntPtr domain, IntPtr range)
    {
        var result = nativeLibrary.MkArraySortN(c, n, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkArraySortN));
    }

    /// <summary>
    /// Create a tuple type.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="mkTupleName">
    /// name of the constructor function associated with the tuple type.
    /// </param>
    /// <param name="numFields" ctype="unsigned">
    /// number of fields in the tuple type.
    /// </param>
    /// <param name="fieldNames" ctype="Z3_symbol const[]">
    /// name of the projection functions.
    /// </param>
    /// <param name="fieldSorts" ctype="Z3_sort const[]">
    /// type of the tuple fields.
    /// </param>
    /// <param name="mkTupleDecl" ctype="Z3_func_decl *">
    /// output parameter that will contain the constructor declaration.
    /// </param>
    /// <param name="projDecl" ctype="Z3_func_decl[]">
    /// output parameter that will contain the projection function declarations. This field must be a buffer of size
    /// <c>
    /// num_fields
    /// </c>
    /// allocated by the user.
    /// </param>
    /// <remarks>
    /// A tuple with
    /// <c>
    /// n
    /// </c>
    /// fields has a constructor and
    /// <c>
    /// n
    /// </c>
    /// projections. This function will also declare the constructor and projection functions.
    /// </remarks>
    public IntPtr MkTupleSort(IntPtr c, string mkTupleName, uint numFields, IntPtr[] fieldNames, IntPtr[] fieldSorts, IntPtr mkTupleDecl, IntPtr[] projDecl)
    {
        using var mkTupleNameAnsi = new AnsiStringPtr(mkTupleName);
        var mkTupleNameSymbol = nativeLibrary.MkStringSymbol(c, mkTupleNameAnsi);
        CheckError(c);
        var result = nativeLibrary.MkTupleSort(c, mkTupleNameSymbol, numFields, fieldNames, fieldSorts, mkTupleDecl, projDecl);
        CheckError(c);
        return CheckHandle(result, nameof(MkTupleSort));
    }

    /// <summary>
    /// Create a tuple type.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="mkTupleName" ctype="Z3_symbol">
    /// name of the constructor function associated with the tuple type.
    /// </param>
    /// <param name="numFields" ctype="unsigned">
    /// number of fields in the tuple type.
    /// </param>
    /// <param name="fieldNames" ctype="Z3_symbol const[]">
    /// name of the projection functions.
    /// </param>
    /// <param name="fieldSorts" ctype="Z3_sort const[]">
    /// type of the tuple fields.
    /// </param>
    /// <param name="mkTupleDecl" ctype="Z3_func_decl *">
    /// output parameter that will contain the constructor declaration.
    /// </param>
    /// <param name="projDecl" ctype="Z3_func_decl[]">
    /// output parameter that will contain the projection function declarations. This field must be a buffer of size
    /// <c>
    /// num_fields
    /// </c>
    /// allocated by the user.
    /// </param>
    /// <remarks>
    /// A tuple with
    /// <c>
    /// n
    /// </c>
    /// fields has a constructor and
    /// <c>
    /// n
    /// </c>
    /// projections. This function will also declare the constructor and projection functions.
    /// </remarks>
    public IntPtr MkTupleSortOriginal(IntPtr c, IntPtr mkTupleName, uint numFields, IntPtr[] fieldNames, IntPtr[] fieldSorts, IntPtr mkTupleDecl, IntPtr[] projDecl)
    {
        var result = nativeLibrary.MkTupleSort(c, mkTupleName, numFields, fieldNames, fieldSorts, mkTupleDecl, projDecl);
        CheckError(c);
        return CheckHandle(result, nameof(MkTupleSort));
    }

    /// <summary>
    /// Create a enumeration sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="name">
    /// name of the enumeration sort.
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// number of elements in enumeration sort.
    /// </param>
    /// <param name="enumNames" ctype="Z3_symbol  const[]">
    /// names of the enumerated elements.
    /// </param>
    /// <param name="enumConsts" ctype="Z3_func_decl[]">
    /// constants corresponding to the enumerated elements.
    /// </param>
    /// <param name="enumTesters" ctype="Z3_func_decl[]">
    /// predicates testing if terms of the enumeration sort correspond to an enumeration.
    /// </param>
    /// <remarks>
    /// An enumeration sort with
    /// <c>
    /// n
    /// </c>
    /// elements. This function will also declare the functions corresponding to the enumerations. For example, if this function is called with three symbols A, B, C and the name S, then
    /// <c>
    /// s
    /// </c>
    /// is a sort whose name is S, and the function returns three terms corresponding to A, B, C in
    /// <c>
    /// enum_consts
    /// </c>
    /// . The array
    /// <c>
    /// enum_testers
    /// </c>
    /// has three predicates of type
    /// <c>
    /// (s -&gt; Bool)
    /// </c>
    /// . The first predicate (corresponding to A) is true when applied to A, and false otherwise. Similarly for the other predicates.
    /// </remarks>
    public IntPtr MkEnumerationSort(IntPtr c, string name, uint n, IntPtr[] enumNames, IntPtr[] enumConsts, IntPtr[] enumTesters)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var nameSymbol = nativeLibrary.MkStringSymbol(c, nameAnsi);
        CheckError(c);
        var result = nativeLibrary.MkEnumerationSort(c, nameSymbol, n, enumNames, enumConsts, enumTesters);
        CheckError(c);
        return CheckHandle(result, nameof(MkEnumerationSort));
    }

    /// <summary>
    /// Create a enumeration sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="name" ctype="Z3_symbol">
    /// name of the enumeration sort.
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// number of elements in enumeration sort.
    /// </param>
    /// <param name="enumNames" ctype="Z3_symbol  const[]">
    /// names of the enumerated elements.
    /// </param>
    /// <param name="enumConsts" ctype="Z3_func_decl[]">
    /// constants corresponding to the enumerated elements.
    /// </param>
    /// <param name="enumTesters" ctype="Z3_func_decl[]">
    /// predicates testing if terms of the enumeration sort correspond to an enumeration.
    /// </param>
    /// <remarks>
    /// An enumeration sort with
    /// <c>
    /// n
    /// </c>
    /// elements. This function will also declare the functions corresponding to the enumerations. For example, if this function is called with three symbols A, B, C and the name S, then
    /// <c>
    /// s
    /// </c>
    /// is a sort whose name is S, and the function returns three terms corresponding to A, B, C in
    /// <c>
    /// enum_consts
    /// </c>
    /// . The array
    /// <c>
    /// enum_testers
    /// </c>
    /// has three predicates of type
    /// <c>
    /// (s -&gt; Bool)
    /// </c>
    /// . The first predicate (corresponding to A) is true when applied to A, and false otherwise. Similarly for the other predicates.
    /// </remarks>
    public IntPtr MkEnumerationSortOriginal(IntPtr c, IntPtr name, uint n, IntPtr[] enumNames, IntPtr[] enumConsts, IntPtr[] enumTesters)
    {
        var result = nativeLibrary.MkEnumerationSort(c, name, n, enumNames, enumConsts, enumTesters);
        CheckError(c);
        return CheckHandle(result, nameof(MkEnumerationSort));
    }

    /// <summary>
    /// Create a list sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="name">
    /// name of the list sort.
    /// </param>
    /// <param name="elemSort" ctype="Z3_sort">
    /// sort of list elements.
    /// </param>
    /// <param name="nilDecl" ctype="Z3_func_decl*">
    /// declaration for the empty list.
    /// </param>
    /// <param name="isNilDecl" ctype="Z3_func_decl*">
    /// test for the empty list.
    /// </param>
    /// <param name="consDecl" ctype="Z3_func_decl*">
    /// declaration for a cons cell.
    /// </param>
    /// <param name="isConsDecl" ctype="Z3_func_decl*">
    /// cons cell test.
    /// </param>
    /// <param name="headDecl" ctype="Z3_func_decl*">
    /// list head.
    /// </param>
    /// <param name="tailDecl" ctype="Z3_func_decl*">
    /// list tail.
    /// </param>
    /// <remarks>
    /// A list sort over
    /// <c>
    /// elem_sort
    /// </c>
    /// This function declares the corresponding constructors and testers for lists.
    /// </remarks>
    public IntPtr MkListSort(IntPtr c, string name, IntPtr elemSort, IntPtr nilDecl, IntPtr isNilDecl, IntPtr consDecl, IntPtr isConsDecl, IntPtr headDecl, IntPtr tailDecl)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var nameSymbol = nativeLibrary.MkStringSymbol(c, nameAnsi);
        CheckError(c);
        var result = nativeLibrary.MkListSort(c, nameSymbol, elemSort, nilDecl, isNilDecl, consDecl, isConsDecl, headDecl, tailDecl);
        CheckError(c);
        return CheckHandle(result, nameof(MkListSort));
    }

    /// <summary>
    /// Create a list sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="name" ctype="Z3_symbol">
    /// name of the list sort.
    /// </param>
    /// <param name="elemSort" ctype="Z3_sort">
    /// sort of list elements.
    /// </param>
    /// <param name="nilDecl" ctype="Z3_func_decl*">
    /// declaration for the empty list.
    /// </param>
    /// <param name="isNilDecl" ctype="Z3_func_decl*">
    /// test for the empty list.
    /// </param>
    /// <param name="consDecl" ctype="Z3_func_decl*">
    /// declaration for a cons cell.
    /// </param>
    /// <param name="isConsDecl" ctype="Z3_func_decl*">
    /// cons cell test.
    /// </param>
    /// <param name="headDecl" ctype="Z3_func_decl*">
    /// list head.
    /// </param>
    /// <param name="tailDecl" ctype="Z3_func_decl*">
    /// list tail.
    /// </param>
    /// <remarks>
    /// A list sort over
    /// <c>
    /// elem_sort
    /// </c>
    /// This function declares the corresponding constructors and testers for lists.
    /// </remarks>
    public IntPtr MkListSortOriginal(IntPtr c, IntPtr name, IntPtr elemSort, IntPtr nilDecl, IntPtr isNilDecl, IntPtr consDecl, IntPtr isConsDecl, IntPtr headDecl, IntPtr tailDecl)
    {
        var result = nativeLibrary.MkListSort(c, name, elemSort, nilDecl, isNilDecl, consDecl, isConsDecl, headDecl, tailDecl);
        CheckError(c);
        return CheckHandle(result, nameof(MkListSort));
    }

    /// <summary>
    /// Create a constructor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="name">
    /// constructor name.
    /// </param>
    /// <param name="recognizer">
    /// name of recognizer function.
    /// </param>
    /// <param name="numFields" ctype="unsigned">
    /// number of fields in constructor.
    /// </param>
    /// <param name="fieldNames" ctype="Z3_symbol const[]">
    /// names of the constructor fields.
    /// </param>
    /// <param name="sorts" ctype="Z3_sort const[]">
    /// field sorts, 0 if the field sort refers to a recursive sort.
    /// </param>
    /// <param name="sortRefs" ctype="unsigned[]">
    /// reference to datatype sort that is an argument to the constructor; if the corresponding sort reference is 0, then the value in sort_refs should be an index referring to one of the recursive datatypes that is declared.
    /// </param>
    /// <seealso cref="DelConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="QueryConstructor"/>
    public IntPtr MkConstructor(IntPtr c, string name, string recognizer, uint numFields, IntPtr[] fieldNames, IntPtr[] sorts, uint[] sortRefs)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var nameSymbol = nativeLibrary.MkStringSymbol(c, nameAnsi);
        CheckError(c);
        using var recognizerAnsi = new AnsiStringPtr(recognizer);
        var recognizerSymbol = nativeLibrary.MkStringSymbol(c, recognizerAnsi);
        CheckError(c);
        var result = nativeLibrary.MkConstructor(c, nameSymbol, recognizerSymbol, numFields, fieldNames, sorts, sortRefs);
        CheckError(c);
        return CheckHandle(result, nameof(MkConstructor));
    }

    /// <summary>
    /// Create a constructor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="name" ctype="Z3_symbol">
    /// constructor name.
    /// </param>
    /// <param name="recognizer" ctype="Z3_symbol">
    /// name of recognizer function.
    /// </param>
    /// <param name="numFields" ctype="unsigned">
    /// number of fields in constructor.
    /// </param>
    /// <param name="fieldNames" ctype="Z3_symbol const[]">
    /// names of the constructor fields.
    /// </param>
    /// <param name="sorts" ctype="Z3_sort const[]">
    /// field sorts, 0 if the field sort refers to a recursive sort.
    /// </param>
    /// <param name="sortRefs" ctype="unsigned[]">
    /// reference to datatype sort that is an argument to the constructor; if the corresponding sort reference is 0, then the value in sort_refs should be an index referring to one of the recursive datatypes that is declared.
    /// </param>
    /// <seealso cref="DelConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="QueryConstructor"/>
    public IntPtr MkConstructorOriginal(IntPtr c, IntPtr name, IntPtr recognizer, uint numFields, IntPtr[] fieldNames, IntPtr[] sorts, uint[] sortRefs)
    {
        var result = nativeLibrary.MkConstructor(c, name, recognizer, numFields, fieldNames, sorts, sortRefs);
        CheckError(c);
        return CheckHandle(result, nameof(MkConstructor));
    }

    /// <summary>
    /// Retrieve the number of fields of a constructor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="constr" ctype="Z3_constructor">
    /// constructor.
    /// </param>
    public uint ConstructorNumFields(IntPtr c, IntPtr constr)
    {
        var result = nativeLibrary.ConstructorNumFields(c, constr);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Reclaim memory allocated to constructor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="constr" ctype="Z3_constructor">
    /// constructor.
    /// </param>
    /// <seealso cref="MkConstructor"/>
    public void DelConstructor(IntPtr c, IntPtr constr)
    {
        nativeLibrary.DelConstructor(c, constr);
        CheckError(c);
    }

    /// <summary>
    /// Create datatype, such as lists, trees, records, enumerations or unions of records. The datatype may be recursive. Return the datatype sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="name">
    /// name of datatype.
    /// </param>
    /// <param name="numConstructors" ctype="unsigned">
    /// number of constructors passed in.
    /// </param>
    /// <param name="constructors" ctype="Z3_constructor[]">
    /// array of constructor containers.
    /// </param>
    /// <seealso cref="MkConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="MkDatatypes"/>
    public IntPtr MkDatatype(IntPtr c, string name, uint numConstructors, IntPtr[] constructors)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var nameSymbol = nativeLibrary.MkStringSymbol(c, nameAnsi);
        CheckError(c);
        var result = nativeLibrary.MkDatatype(c, nameSymbol, numConstructors, constructors);
        CheckError(c);
        return CheckHandle(result, nameof(MkDatatype));
    }

    /// <summary>
    /// Create datatype, such as lists, trees, records, enumerations or unions of records. The datatype may be recursive. Return the datatype sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="name" ctype="Z3_symbol">
    /// name of datatype.
    /// </param>
    /// <param name="numConstructors" ctype="unsigned">
    /// number of constructors passed in.
    /// </param>
    /// <param name="constructors" ctype="Z3_constructor[]">
    /// array of constructor containers.
    /// </param>
    /// <seealso cref="MkConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="MkDatatypes"/>
    public IntPtr MkDatatypeOriginal(IntPtr c, IntPtr name, uint numConstructors, IntPtr[] constructors)
    {
        var result = nativeLibrary.MkDatatype(c, name, numConstructors, constructors);
        CheckError(c);
        return CheckHandle(result, nameof(MkDatatype));
    }

    /// <summary>
    /// create a forward reference to a recursive datatype being declared. The forward reference can be used in a nested occurrence: the range of an array or as element sort of a sequence. The forward reference should only be used when used in an accessor for a recursive datatype that gets declared.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name">
    /// symbol parameter
    /// </param>
    /// <remarks>
    /// Forward references can replace the use sort references, that are unsigned integers in the
    /// <c>
    /// Z3_mk_constructor
    /// </c>
    /// call
    /// </remarks>
    public IntPtr MkDatatypeSort(IntPtr c, string name)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var nameSymbol = nativeLibrary.MkStringSymbol(c, nameAnsi);
        CheckError(c);
        var result = nativeLibrary.MkDatatypeSort(c, nameSymbol);
        CheckError(c);
        return CheckHandle(result, nameof(MkDatatypeSort));
    }

    /// <summary>
    /// create a forward reference to a recursive datatype being declared. The forward reference can be used in a nested occurrence: the range of an array or as element sort of a sequence. The forward reference should only be used when used in an accessor for a recursive datatype that gets declared.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="name" ctype="Z3_symbol">
    /// symbol parameter
    /// </param>
    /// <remarks>
    /// Forward references can replace the use sort references, that are unsigned integers in the
    /// <c>
    /// Z3_mk_constructor
    /// </c>
    /// call
    /// </remarks>
    public IntPtr MkDatatypeSortOriginal(IntPtr c, IntPtr name)
    {
        var result = nativeLibrary.MkDatatypeSort(c, name);
        CheckError(c);
        return CheckHandle(result, nameof(MkDatatypeSort));
    }

    /// <summary>
    /// Create list of constructors.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="numConstructors" ctype="unsigned">
    /// number of constructors in list.
    /// </param>
    /// <param name="constructors" ctype="Z3_constructor const[]">
    /// list of constructors.
    /// </param>
    /// <seealso cref="DelConstructorList"/>
    /// <seealso cref="MkConstructor"/>
    public IntPtr MkConstructorList(IntPtr c, uint numConstructors, IntPtr[] constructors)
    {
        var result = nativeLibrary.MkConstructorList(c, numConstructors, constructors);
        CheckError(c);
        return CheckHandle(result, nameof(MkConstructorList));
    }

    /// <summary>
    /// Reclaim memory allocated for constructor list.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="clist" ctype="Z3_constructor_list">
    /// constructor list container.
    /// </param>
    /// <remarks>
    /// Each constructor inside the constructor list must be independently reclaimed using
    /// <see cref="DelConstructor"/>
    /// .
    /// </remarks>
    /// <seealso cref="MkConstructorList"/>
    public void DelConstructorList(IntPtr c, IntPtr clist)
    {
        nativeLibrary.DelConstructorList(c, clist);
        CheckError(c);
    }

    /// <summary>
    /// Create mutually recursive datatypes.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="numSorts" ctype="unsigned">
    /// number of datatype sorts.
    /// </param>
    /// <param name="sortNames" ctype="Z3_symbol const[]">
    /// names of datatype sorts.
    /// </param>
    /// <param name="sorts" ctype="Z3_sort[]">
    /// array of datatype sorts.
    /// </param>
    /// <param name="constructorLists" ctype="Z3_constructor_list[]">
    /// list of constructors, one list per sort.
    /// </param>
    /// <seealso cref="MkConstructor"/>
    /// <seealso cref="MkConstructorList"/>
    /// <seealso cref="MkDatatype"/>
    public void MkDatatypes(IntPtr c, uint numSorts, IntPtr[] sortNames, IntPtr[] sorts, IntPtr[] constructorLists)
    {
        nativeLibrary.MkDatatypes(c, numSorts, sortNames, sorts, constructorLists);
        CheckError(c);
    }

    /// <summary>
    /// Query constructor for declared functions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="constr" ctype="Z3_constructor">
    /// constructor container. The container must have been passed into a
    /// <see cref="MkDatatype"/>
    /// call.
    /// </param>
    /// <param name="numFields" ctype="unsigned">
    /// number of accessor fields in the constructor.
    /// </param>
    /// <param name="constructor" ctype="Z3_func_decl*">
    /// constructor function declaration, allocated by user.
    /// </param>
    /// <param name="tester" ctype="Z3_func_decl*">
    /// constructor test function declaration, allocated by user.
    /// </param>
    /// <param name="accessors" ctype="Z3_func_decl[]">
    /// array of accessor function declarations allocated by user. The array must contain num_fields elements.
    /// </param>
    /// <seealso cref="MkConstructor"/>
    public void QueryConstructor(IntPtr c, IntPtr constr, uint numFields, IntPtr constructor, IntPtr tester, IntPtr[] accessors)
    {
        nativeLibrary.QueryConstructor(c, constr, numFields, constructor, tester, accessors);
        CheckError(c);
    }

}
