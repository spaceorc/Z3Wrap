// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.ConstantsAndApplications.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Declare a constant or function.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="s">
    /// name of the constant or function.
    /// </param>
    /// <param name="domainSize" ctype="unsigned">
    /// number of arguments. It is 0 when declaring a constant.
    /// </param>
    /// <param name="domain" ctype="Z3_sort const[]">
    /// array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant.
    /// </param>
    /// <param name="range" ctype="Z3_sort">
    /// <para>
    /// sort of the constant or the return sort of the function.
    /// </para>
    /// <para>
    /// After declaring a constant or function, the function
    /// <see cref="MkApp"/>
    /// can be used to create a constant or function
    /// application.
    /// </para>
    /// </param>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    public IntPtr MkFuncDecl(IntPtr c, string s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkFuncDecl(c, sSymbol, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkFuncDecl));
    }

    /// <summary>
    /// Declare a constant or function.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="s" ctype="Z3_symbol">
    /// name of the constant or function.
    /// </param>
    /// <param name="domainSize" ctype="unsigned">
    /// number of arguments. It is 0 when declaring a constant.
    /// </param>
    /// <param name="domain" ctype="Z3_sort const[]">
    /// array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant.
    /// </param>
    /// <param name="range" ctype="Z3_sort">
    /// <para>
    /// sort of the constant or the return sort of the function.
    /// </para>
    /// <para>
    /// After declaring a constant or function, the function
    /// <see cref="MkApp"/>
    /// can be used to create a constant or function
    /// application.
    /// </para>
    /// </param>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    public IntPtr MkFuncDecl(IntPtr c, IntPtr s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        var result = nativeLibrary.MkFuncDecl(c, s, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkFuncDecl));
    }

    /// <summary>
    /// Create a constant or function application.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="d" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    /// <param name="numArgs" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkFuncDecl"/>
    /// <seealso cref="MkRecFuncDecl"/>
    public IntPtr MkApp(IntPtr c, IntPtr d, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkApp(c, d, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkApp));
    }

    /// <summary>
    /// <para>
    /// Declare and create a constant.
    /// </para>
    /// <para>
    /// This function is a shorthand for:
    /// <code>
    /// Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
    /// Z3_ast n            = Z3_mk_app(c, d, 0, 0);
    /// </code>
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s">
    /// symbol parameter
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshConst"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkConst(IntPtr c, string s, IntPtr ty)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkConst(c, sSymbol, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkConst));
    }

    /// <summary>
    /// <para>
    /// Declare and create a constant.
    /// </para>
    /// <para>
    /// This function is a shorthand for:
    /// <code>
    /// Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
    /// Z3_ast n            = Z3_mk_app(c, d, 0, 0);
    /// </code>
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="s" ctype="Z3_symbol">
    /// symbol parameter
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFreshConst"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkConst(IntPtr c, IntPtr s, IntPtr ty)
    {
        var result = nativeLibrary.MkConst(c, s, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkConst));
    }

    /// <summary>
    /// <para>
    /// Declare a fresh constant or function.
    /// </para>
    /// <para>
    /// Z3 will generate an unique name for this function declaration.
    /// If prefix is different from NULL, then the name generate by Z3 will start with prefix.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="prefix" ctype="Z3_string">
    /// string parameter
    /// </param>
    /// <param name="domainSize" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="domain" ctype="Z3_sort const[]">
    /// sort parameter
    /// </param>
    /// <param name="range" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <remarks>
    /// If prefix is NULL, then it is assumed to be the empty string.
    /// </remarks>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkFreshFuncDecl(IntPtr c, string prefix, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        using var prefixAnsi = new AnsiStringPtr(prefix);
        var result = nativeLibrary.MkFreshFuncDecl(c, prefixAnsi, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkFreshFuncDecl));
    }

    /// <summary>
    /// <para>
    /// Declare and create a fresh constant.
    /// </para>
    /// <para>
    /// This function is a shorthand for:
    /// <code>
    /// Z3_func_decl d = Z3_mk_fresh_func_decl(c, prefix, 0, 0, ty); Z3_ast n = Z3_mk_app(c, d, 0, 0);
    /// </code>
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="prefix" ctype="Z3_string">
    /// string parameter
    /// </param>
    /// <param name="ty" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <remarks>
    /// If prefix is NULL, then it is assumed to be the empty string.
    /// </remarks>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkConst"/>
    /// <seealso cref="MkFreshFuncDecl"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkFreshConst(IntPtr c, string prefix, IntPtr ty)
    {
        using var prefixAnsi = new AnsiStringPtr(prefix);
        var result = nativeLibrary.MkFreshConst(c, prefixAnsi, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFreshConst));
    }

    /// <summary>
    /// Declare a recursive function
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="s">
    /// name of the function.
    /// </param>
    /// <param name="domainSize" ctype="unsigned">
    /// number of arguments. It should be greater than 0.
    /// </param>
    /// <param name="domain" ctype="Z3_sort const[]">
    /// array containing the sort of each argument. The array must contain domain_size elements.
    /// </param>
    /// <param name="range" ctype="Z3_sort">
    /// <para>
    /// sort of the constant or the return sort of the function.
    /// </para>
    /// <para>
    /// After declaring recursive function, it should be associated with a recursive definition
    /// <see cref="AddRecDef"/>
    /// .
    /// The function
    /// <see cref="MkApp"/>
    /// can be used to create a constant or function
    /// application.
    /// </para>
    /// </param>
    /// <seealso cref="AddRecDef"/>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkRecFuncDecl(IntPtr c, string s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var sSymbol = nativeLibrary.MkStringSymbol(c, sAnsi);
        CheckError(c);
        var result = nativeLibrary.MkRecFuncDecl(c, sSymbol, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkRecFuncDecl));
    }

    /// <summary>
    /// Declare a recursive function
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="s" ctype="Z3_symbol">
    /// name of the function.
    /// </param>
    /// <param name="domainSize" ctype="unsigned">
    /// number of arguments. It should be greater than 0.
    /// </param>
    /// <param name="domain" ctype="Z3_sort const[]">
    /// array containing the sort of each argument. The array must contain domain_size elements.
    /// </param>
    /// <param name="range" ctype="Z3_sort">
    /// <para>
    /// sort of the constant or the return sort of the function.
    /// </para>
    /// <para>
    /// After declaring recursive function, it should be associated with a recursive definition
    /// <see cref="AddRecDef"/>
    /// .
    /// The function
    /// <see cref="MkApp"/>
    /// can be used to create a constant or function
    /// application.
    /// </para>
    /// </param>
    /// <seealso cref="AddRecDef"/>
    /// <seealso cref="MkApp"/>
    /// <seealso cref="MkFuncDecl"/>
    public IntPtr MkRecFuncDecl(IntPtr c, IntPtr s, uint domainSize, IntPtr[] domain, IntPtr range)
    {
        var result = nativeLibrary.MkRecFuncDecl(c, s, domainSize, domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(MkRecFuncDecl));
    }

    /// <summary>
    /// Define the body of a recursive function.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context.
    /// </param>
    /// <param name="f" ctype="Z3_func_decl">
    /// function declaration.
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// number of arguments to the function
    /// </param>
    /// <param name="args" ctype="Z3_ast[]">
    /// constants that are used as arguments to the recursive function in the definition.
    /// </param>
    /// <param name="body" ctype="Z3_ast">
    /// <para>
    /// body of the recursive function
    /// </para>
    /// <para>
    /// After declaring a recursive function or a collection of mutually recursive functions, use
    /// this function to provide the definition for the recursive function.
    /// </para>
    /// </param>
    /// <seealso cref="MkRecFuncDecl"/>
    public void AddRecDef(IntPtr c, IntPtr f, uint n, IntPtr[] args, IntPtr body)
    {
        nativeLibrary.AddRecDef(c, f, n, args, body);
        CheckError(c);
    }

}
