// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.IntegersAndReals.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// args[0] + ... + args[num_args-1]
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The array args must have num_args elements.
    /// All arguments must have int or real sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="numArgs" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkAdd(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkAdd(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkAdd));
    }

    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// args[0] * ... * args[num_args-1]
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The array args must have num_args elements.
    /// All arguments must have int or real sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="numArgs" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Z3 has limited support for non-linear arithmetic.
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkMul(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkMul(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkMul));
    }

    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// args[0] - ... - args[num_args - 1]
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The array args must have num_args elements.
    /// All arguments must have int or real sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="numArgs" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="args" ctype="Z3_ast const[]">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkSub(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkSub(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkSub));
    }

    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// - arg
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The arguments must have int or real type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="arg" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkUnaryMinus(IntPtr c, IntPtr arg)
    {
        var result = nativeLibrary.MkUnaryMinus(c, arg);
        CheckError(c);
        return CheckHandle(result, nameof(MkUnaryMinus));
    }

    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// arg1 div arg2
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The arguments must either both have int type or both have real type.
    /// If the arguments have int type, then the result type is an int type, otherwise the
    /// the result type is real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="arg1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="arg2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkDiv(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkDiv(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkDiv));
    }

    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// arg1 mod arg2
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The arguments must have int type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="arg1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="arg2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkMod(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkMod(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkMod));
    }

    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// arg1 rem arg2
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The arguments must have int type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="arg1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="arg2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkRem(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkRem(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkRem));
    }

    /// <summary>
    /// <para>
    /// Create an AST node representing
    /// <code>
    /// arg1 ^ arg2
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The arguments must have int or real type.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="arg1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="arg2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkPower(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkPower(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkPower));
    }

    /// <summary>
    /// Take the absolute value of an integer
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="arg" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkAbs(IntPtr c, IntPtr arg)
    {
        var result = nativeLibrary.MkAbs(c, arg);
        CheckError(c);
        return CheckHandle(result, nameof(MkAbs));
    }

    /// <summary>
    /// <para>
    /// Create less than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkLt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkLt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkLt));
    }

    /// <summary>
    /// <para>
    /// Create less than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkLe(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkLe(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkLe));
    }

    /// <summary>
    /// <para>
    /// Create greater than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkGt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkGt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkGt));
    }

    /// <summary>
    /// <para>
    /// Create greater than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same sort, and must be int or real.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkGe(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkGe(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkGe));
    }

    /// <summary>
    /// <para>
    /// Create division predicate.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must be of integer sort.
    /// The predicate is true when t1 divides t2. For the predicate to be part of
    /// linear integer arithmetic, the first argument t1 must be a non-zero integer.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkDivides(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkDivides(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkDivides));
    }

    /// <summary>
    /// <para>
    /// Coerce an integer to a real.
    /// </para>
    /// <para>
    /// There is also a converse operation exposed.
    /// It follows the semantics prescribed by the SMT-LIB standard.
    /// </para>
    /// <para>
    /// You can take the floor of a real by
    /// creating an auxiliary integer constant k and
    /// and asserting
    /// <code>
    /// mk_int2real(k) &lt;= t1 &lt; mk_int2real(k)+1
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The node t1 must have sort integer.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="MkReal2int"/>
    /// <seealso cref="MkIsInt"/>
    public IntPtr MkInt2real(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkInt2real(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkInt2real));
    }

    /// <summary>
    /// <para>
    /// Coerce a real to an integer.
    /// </para>
    /// <para>
    /// The semantics of this function follows the SMT-LIB standard
    /// for the function to_int
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="MkInt2real"/>
    /// <seealso cref="MkIsInt"/>
    public IntPtr MkReal2int(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkReal2int(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkReal2int));
    }

    /// <summary>
    /// Check if a real number is an integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="MkInt2real"/>
    /// <seealso cref="MkReal2int"/>
    public IntPtr MkIsInt(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkIsInt(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkIsInt));
    }

}
