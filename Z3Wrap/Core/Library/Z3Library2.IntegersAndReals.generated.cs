// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.IntegersAndReals.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    ///  Create an AST node representing <c>args[0] + ... + args[num_args-1]</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <remarks>
    /// The array <c>args</c> must have <c>num_args</c> elements. All arguments must have int or real sort.
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkAdd(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkAdd(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkAdd));
    }

    /// <summary>
    ///  Create an AST node representing <c>args[0] * ... * args[num_args-1]</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <remarks>
    /// The array <c>args</c> must have <c>num_args</c> elements. All arguments must have int or real sort.
    /// Z3 has limited support for non-linear arithmetic.
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkMul(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkMul(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkMul));
    }

    /// <summary>
    ///  Create an AST node representing <c>args[0] - ... - args[num_args - 1]</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <remarks>
    /// The array <c>args</c> must have <c>num_args</c> elements. All arguments must have int or real sort.
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkSub(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkSub(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkSub));
    }

    /// <summary>
    ///  Create an AST node representing <c>- arg</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The arguments must have int or real type.
    /// </remarks>
    public IntPtr MkUnaryMinus(IntPtr c, IntPtr arg)
    {
        var result = nativeLibrary.MkUnaryMinus(c, arg);
        CheckError(c);
        return CheckHandle(result, nameof(MkUnaryMinus));
    }

    /// <summary>
    ///  Create an AST node representing <c>arg1 div arg2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The arguments must either both have int type or both have real type. If the arguments have int type, then the result type is an int type, otherwise the the result type is real.
    /// </remarks>
    public IntPtr MkDiv(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkDiv(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkDiv));
    }

    /// <summary>
    ///  Create an AST node representing <c>arg1 mod arg2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The arguments must have int type.
    /// </remarks>
    public IntPtr MkMod(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkMod(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkMod));
    }

    /// <summary>
    ///  Create an AST node representing <c>arg1 rem arg2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The arguments must have int type.
    /// </remarks>
    public IntPtr MkRem(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkRem(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkRem));
    }

    /// <summary>
    ///  Create an AST node representing <c>arg1 ^ arg2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg1" ctype="Z3_ast">ast parameter</param>
    /// <param name="arg2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The arguments must have int or real type.
    /// </remarks>
    public IntPtr MkPower(IntPtr c, IntPtr arg1, IntPtr arg2)
    {
        var result = nativeLibrary.MkPower(c, arg1, arg2);
        CheckError(c);
        return CheckHandle(result, nameof(MkPower));
    }

    /// <summary>
    ///  Take the absolute value of an integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="arg" ctype="Z3_ast">ast parameter</param>
    public IntPtr MkAbs(IntPtr c, IntPtr arg)
    {
        var result = nativeLibrary.MkAbs(c, arg);
        CheckError(c);
        return CheckHandle(result, nameof(MkAbs));
    }

    /// <summary>
    ///  Create less than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same sort, and must be int or real.
    /// </remarks>
    public IntPtr MkLt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkLt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkLt));
    }

    /// <summary>
    ///  Create less than or equal to.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same sort, and must be int or real.
    /// </remarks>
    public IntPtr MkLe(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkLe(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkLe));
    }

    /// <summary>
    ///  Create greater than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same sort, and must be int or real.
    /// </remarks>
    public IntPtr MkGt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkGt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkGt));
    }

    /// <summary>
    ///  Create greater than or equal to.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same sort, and must be int or real.
    /// </remarks>
    public IntPtr MkGe(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkGe(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkGe));
    }

    /// <summary>
    ///  Create division predicate.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must be of integer sort. The predicate is true when <c>t1</c> divides <c>t2</c> . For the predicate to be part of linear integer arithmetic, the first argument <c>t1</c> must be a non-zero integer.
    /// </remarks>
    public IntPtr MkDivides(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkDivides(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkDivides));
    }

    /// <summary>
    ///  Coerce an integer to a real.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// There is also a converse operation exposed. It follows the semantics prescribed by the SMT-LIB standard. You can take the floor of a real by creating an auxiliary integer constant <c>k</c> and and asserting <c>mk_int2real(k) &lt;= t1 &lt; mk_int2real(k)+1</c> . The node <c>t1</c> must have sort integer.
    /// </remarks>
    /// <seealso cref="MkReal2int"/>
    /// <seealso cref="MkIsInt"/>
    public IntPtr MkInt2real(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkInt2real(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkInt2real));
    }

    /// <summary>
    ///  Coerce a real to an integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The semantics of this function follows the SMT-LIB standard for the function to_int
    /// </remarks>
    /// <seealso cref="MkInt2real"/>
    /// <seealso cref="MkIsInt"/>
    public IntPtr MkReal2int(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkReal2int(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkReal2int));
    }

    /// <summary>
    ///  Check if a real number is an integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="MkInt2real"/>
    /// <seealso cref="MkReal2int"/>
    public IntPtr MkIsInt(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkIsInt(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkIsInt));
    }

}
