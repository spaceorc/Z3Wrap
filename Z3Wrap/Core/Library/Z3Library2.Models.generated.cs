// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Models.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Create a fresh model object. It has reference count 0.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    public IntPtr MkModel(IntPtr c)
    {
        var result = nativeLibrary.MkModel(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkModel));
    }

    /// <summary>
    /// Increment the reference counter of the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    public void ModelIncRef(IntPtr c, IntPtr m)
    {
        nativeLibrary.ModelIncRef(c, m);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    public void ModelDecRef(IntPtr c, IntPtr m)
    {
        nativeLibrary.ModelDecRef(c, m);
        CheckError(c);
    }

    /// <summary>
    /// Evaluate the AST node
    /// <c>
    /// t
    /// </c>
    /// in the given model. Return
    /// <c>
    /// true
    /// </c>
    /// if succeeded, and store the result in
    /// <c>
    /// v
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="modelCompletion" ctype="bool">
    /// bool parameter
    /// </param>
    /// <param name="v" ctype="Z3_ast *">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// If
    /// <c>
    /// model_completion
    /// </c>
    /// is
    /// <c>
    /// true
    /// </c>
    /// , then Z3 will assign an interpretation for any constant or function that does not have an interpretation in
    /// <c>
    /// m
    /// </c>
    /// . These constants and functions were essentially don't cares. If
    /// <c>
    /// model_completion
    /// </c>
    /// is
    /// <c>
    /// false
    /// </c>
    /// , then Z3 will not assign interpretations to constants for functions that do not have interpretations in
    /// <c>
    /// m
    /// </c>
    /// . Evaluation behaves as the identify function in this case. The evaluation may fail for the following reasons:
    /// <c>
    /// t
    /// </c>
    /// contains a quantifier.  the model
    /// <c>
    /// m
    /// </c>
    /// is partial, that is, it doesn't have a complete interpretation for uninterpreted functions. That is, the option
    /// <c>
    /// MODEL_PARTIAL=true
    /// </c>
    /// was used.
    /// <c>
    /// t
    /// </c>
    /// is type incorrect.
    /// <c>
    /// Z3_interrupt
    /// </c>
    /// was invoked during evaluation.
    /// </remarks>
    public bool ModelEval(IntPtr c, IntPtr m, IntPtr t, bool modelCompletion, IntPtr v)
    {
        var result = nativeLibrary.ModelEval(c, m, t, modelCompletion, v);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the interpretation (i.e., assignment) of constant
    /// <c>
    /// a
    /// </c>
    /// in the model
    /// <c>
    /// m
    /// </c>
    /// . Return
    /// <c>
    /// NULL
    /// </c>
    /// , if the model does not assign an interpretation for
    /// <c>
    /// a
    /// </c>
    /// . That should be interpreted as: the value of
    /// <c>
    /// a
    /// </c>
    /// does not matter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="a" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, a) == 0
    /// </remarks>
    public IntPtr ModelGetConstInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var result = nativeLibrary.ModelGetConstInterp(c, m, a);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetConstInterp));
    }

    /// <summary>
    /// Test if there exists an interpretation (i.e., assignment) for
    /// <c>
    /// a
    /// </c>
    /// in the model
    /// <c>
    /// m
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="a" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    public bool ModelHasInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var result = nativeLibrary.ModelHasInterp(c, m, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the interpretation of the function
    /// <c>
    /// f
    /// </c>
    /// in the model
    /// <c>
    /// m
    /// </c>
    /// . Return
    /// <c>
    /// NULL
    /// </c>
    /// , if the model does not assign an interpretation for
    /// <c>
    /// f
    /// </c>
    /// . That should be interpreted as: the
    /// <c>
    /// f
    /// </c>
    /// does not matter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, f) &gt; 0
    /// Reference counting must be used to manage Z3_func_interp objects, even when the Z3_context was created using
    /// MkContext
    /// instead of
    /// <see cref="MkContextRc"/>
    /// .
    /// </remarks>
    public IntPtr ModelGetFuncInterp(IntPtr c, IntPtr m, IntPtr f)
    {
        var result = nativeLibrary.ModelGetFuncInterp(c, m, f);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetFuncInterp));
    }

    /// <summary>
    /// Return the number of constants assigned by the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <seealso cref="ModelGetConstDecl"/>
    public uint ModelGetNumConsts(IntPtr c, IntPtr m)
    {
        var result = nativeLibrary.ModelGetNumConsts(c, m);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the i-th constant in the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_consts(c, m)
    /// </remarks>
    /// <seealso cref="ModelEval"/>
    /// <seealso cref="ModelGetNumConsts"/>
    public IntPtr ModelGetConstDecl(IntPtr c, IntPtr m, uint i)
    {
        var result = nativeLibrary.ModelGetConstDecl(c, m, i);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetConstDecl));
    }

    /// <summary>
    /// Return the number of function interpretations in the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. Each entry in the finite map represents the value of a function given a set of arguments.
    /// </remarks>
    /// <seealso cref="ModelGetFuncDecl"/>
    public uint ModelGetNumFuncs(IntPtr c, IntPtr m)
    {
        var result = nativeLibrary.ModelGetNumFuncs(c, m);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the declaration of the i-th function in the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_funcs(c, m)
    /// </remarks>
    /// <seealso cref="ModelGetNumFuncs"/>
    public IntPtr ModelGetFuncDecl(IntPtr c, IntPtr m, uint i)
    {
        var result = nativeLibrary.ModelGetFuncDecl(c, m, i);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetFuncDecl));
    }

    /// <summary>
    /// Return the number of uninterpreted sorts that
    /// <c>
    /// m
    /// </c>
    /// assigns an interpretation to.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <remarks>
    /// Z3 also provides an interpretation for uninterpreted sorts used in a formula. The interpretation for a sort
    /// <c>
    /// s
    /// </c>
    /// is a finite set of distinct values. We say this finite set is the "universe" of
    /// <c>
    /// s
    /// </c>
    /// .
    /// </remarks>
    /// <seealso cref="ModelGetSort"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    public uint ModelGetNumSorts(IntPtr c, IntPtr m)
    {
        var result = nativeLibrary.ModelGetNumSorts(c, m);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return a uninterpreted sort that
    /// <c>
    /// m
    /// </c>
    /// assigns an interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_sorts(c, m)
    /// </remarks>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    public IntPtr ModelGetSort(IntPtr c, IntPtr m, uint i)
    {
        var result = nativeLibrary.ModelGetSort(c, m, i);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetSort));
    }

    /// <summary>
    /// Return the finite set of distinct values that represent the interpretation for sort
    /// <c>
    /// s
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSort"/>
    public IntPtr ModelGetSortUniverse(IntPtr c, IntPtr m, IntPtr s)
    {
        var result = nativeLibrary.ModelGetSortUniverse(c, m, s);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetSortUniverse));
    }

    /// <summary>
    /// translate model from context
    /// <c>
    /// c
    /// </c>
    /// to context
    /// <c>
    /// dst
    /// </c>
    /// .
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="dst" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <remarks>
    /// Use this method for cloning state between contexts. Note that operations on contexts are not thread safe and therefore all operations that related to a given context have to be synchronized (or run in the same thread).
    /// </remarks>
    public IntPtr ModelTranslate(IntPtr c, IntPtr m, IntPtr dst)
    {
        var result = nativeLibrary.ModelTranslate(c, m, dst);
        CheckError(c);
        return CheckHandle(result, nameof(ModelTranslate));
    }

    /// <summary>
    /// The
    /// <c>
    /// (_ as-array f)
    /// </c>
    /// AST node is a construct for assigning interpretations for arrays in Z3. It is the array such that forall indices
    /// <c>
    /// i
    /// </c>
    /// we have that
    /// <c>
    /// (select (_ as-array f) i)
    /// </c>
    /// is equal to
    /// <c>
    /// (f i)
    /// </c>
    /// . This procedure returns
    /// <c>
    /// true
    /// </c>
    /// if the
    /// <c>
    /// a
    /// </c>
    /// is an
    /// <c>
    /// as-array
    /// </c>
    /// AST node.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// Z3 current solvers have minimal support for
    /// <c>
    /// as_array
    /// </c>
    /// nodes.
    /// </remarks>
    /// <seealso cref="GetAsArrayFuncDecl"/>
    public bool IsAsArray(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsAsArray(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the function declaration
    /// <c>
    /// f
    /// </c>
    /// associated with a
    /// <c>
    /// (_ as_array f)
    /// </c>
    /// node.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="IsAsArray"/>
    public IntPtr GetAsArrayFuncDecl(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetAsArrayFuncDecl(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetAsArrayFuncDecl));
    }

    /// <summary>
    /// Create a fresh func_interp object, add it to a model for a specified function. It has reference count 0.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model
    /// </param>
    /// <param name="f" ctype="Z3_func_decl">
    /// function declaration
    /// </param>
    /// <param name="defaultValue" ctype="Z3_ast">
    /// default value for function interpretation
    /// </param>
    public IntPtr AddFuncInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr defaultValue)
    {
        var result = nativeLibrary.AddFuncInterp(c, m, f, defaultValue);
        CheckError(c);
        return CheckHandle(result, nameof(AddFuncInterp));
    }

    /// <summary>
    /// Add a constant interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public void AddConstInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr a)
    {
        nativeLibrary.AddConstInterp(c, m, f, a);
        CheckError(c);
    }

    /// <summary>
    /// Increment the reference counter of the given
    /// <c>
    /// Z3_func_interp
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    public void FuncInterpIncRef(IntPtr c, IntPtr f)
    {
        nativeLibrary.FuncInterpIncRef(c, f);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given
    /// <c>
    /// Z3_func_interp
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    public void FuncInterpDecRef(IntPtr c, IntPtr f)
    {
        nativeLibrary.FuncInterpDecRef(c, f);
        CheckError(c);
    }

    /// <summary>
    /// Return the number of entries in the given function interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. Each entry in the finite map represents the value of a function given a set of arguments. This procedure return the number of element in the finite map of
    /// <c>
    /// f
    /// </c>
    /// .
    /// </remarks>
    /// <seealso cref="FuncInterpGetEntry"/>
    public uint FuncInterpGetNumEntries(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.FuncInterpGetNumEntries(c, f);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return a "point" of the given function interpretation. It represents the value of
    /// <c>
    /// f
    /// </c>
    /// in a particular point.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_interp_get_num_entries(c, f)
    /// </remarks>
    /// <seealso cref="FuncInterpGetNumEntries"/>
    public IntPtr FuncInterpGetEntry(IntPtr c, IntPtr f, uint i)
    {
        var result = nativeLibrary.FuncInterpGetEntry(c, f, i);
        CheckError(c);
        return CheckHandle(result, nameof(FuncInterpGetEntry));
    }

    /// <summary>
    /// Return the 'else' value of the given function interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. This procedure returns the 'else' value.
    /// </remarks>
    public IntPtr FuncInterpGetElse(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.FuncInterpGetElse(c, f);
        CheckError(c);
        return CheckHandle(result, nameof(FuncInterpGetElse));
    }

    /// <summary>
    /// Return the 'else' value of the given function interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    /// <param name="elseValue" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <remarks>
    /// A function interpretation is represented as a finite map and an 'else' value. This procedure can be used to update the 'else' value.
    /// </remarks>
    public void FuncInterpSetElse(IntPtr c, IntPtr f, IntPtr elseValue)
    {
        nativeLibrary.FuncInterpSetElse(c, f, elseValue);
        CheckError(c);
    }

    /// <summary>
    /// Return the arity (number of arguments) of the given function interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    public uint FuncInterpGetArity(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.FuncInterpGetArity(c, f);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// add a function entry to a function interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="fi" ctype="Z3_func_interp">
    /// a function interpretation to be updated.
    /// </param>
    /// <param name="args" ctype="Z3_ast_vector">
    /// list of arguments. They should be constant values (such as integers) and be of the same types as the domain of the function.
    /// </param>
    /// <param name="value" ctype="Z3_ast">
    /// value of the function when the parameters match args.
    /// </param>
    /// <remarks>
    /// It is assumed that entries added to a function cover disjoint arguments. If an two entries are added with the same arguments, only the second insertion survives and the first inserted entry is removed.
    /// </remarks>
    public void FuncInterpAddEntry(IntPtr c, IntPtr fi, IntPtr args, IntPtr value)
    {
        nativeLibrary.FuncInterpAddEntry(c, fi, args, value);
        CheckError(c);
    }

    /// <summary>
    /// Increment the reference counter of the given
    /// <c>
    /// Z3_func_entry
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    public void FuncEntryIncRef(IntPtr c, IntPtr e)
    {
        nativeLibrary.FuncEntryIncRef(c, e);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given
    /// <c>
    /// Z3_func_entry
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    public void FuncEntryDecRef(IntPtr c, IntPtr e)
    {
        nativeLibrary.FuncEntryDecRef(c, e);
        CheckError(c);
    }

    /// <summary>
    /// Return the value of this point.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    /// <remarks>
    /// A
    /// <c>
    /// Z3_func_entry
    /// </c>
    /// object represents an element in the finite map used to encode a function interpretation.
    /// </remarks>
    /// <seealso cref="FuncInterpGetEntry"/>
    public IntPtr FuncEntryGetValue(IntPtr c, IntPtr e)
    {
        var result = nativeLibrary.FuncEntryGetValue(c, e);
        CheckError(c);
        return CheckHandle(result, nameof(FuncEntryGetValue));
    }

    /// <summary>
    /// Return the number of arguments in a
    /// <c>
    /// Z3_func_entry
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    /// <seealso cref="FuncEntryGetArg"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    public uint FuncEntryGetNumArgs(IntPtr c, IntPtr e)
    {
        var result = nativeLibrary.FuncEntryGetNumArgs(c, e);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return an argument of a
    /// <c>
    /// Z3_func_entry
    /// </c>
    /// object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_entry_get_num_args(c, e)
    /// </remarks>
    /// <seealso cref="FuncEntryGetNumArgs"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    public IntPtr FuncEntryGetArg(IntPtr c, IntPtr e, uint i)
    {
        var result = nativeLibrary.FuncEntryGetArg(c, e, i);
        CheckError(c);
        return CheckHandle(result, nameof(FuncEntryGetArg));
    }

}
