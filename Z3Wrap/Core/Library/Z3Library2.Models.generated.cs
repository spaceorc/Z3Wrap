// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Models.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// Create a fresh model object. It has reference count 0.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    public IntPtr MkModel(IntPtr c)
    {
        var result = nativeLibrary.MkModel(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkModel));
    }

    /// <summary>
    /// Increment the reference counter of the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    public void ModelIncRef(IntPtr c, IntPtr m)
    {
        nativeLibrary.ModelIncRef(c, m);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    public void ModelDecRef(IntPtr c, IntPtr m)
    {
        nativeLibrary.ModelDecRef(c, m);
        CheckError(c);
    }

    /// <summary>
    /// <para>
    /// Evaluate the AST node t in the given model.
    /// Return true if succeeded, and store the result in v.
    /// </para>
    /// <para>
    /// If model_completion is true, then Z3 will assign an interpretation for any constant or function that does
    /// not have an interpretation in m. These constants and functions were essentially don't cares.
    /// </para>
    /// <para>
    /// If model_completion is false, then Z3 will not assign interpretations to constants for functions that do
    /// not have interpretations in m. Evaluation behaves as the identify function in this case.
    /// </para>
    /// <para>
    /// The evaluation may fail for the following reasons:
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item>
    /// <description>
    /// t contains a quantifier.
    /// </description>
    /// </item>
    /// </list>
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item>
    /// <description>
    /// the model m is partial, that is, it doesn't have a complete interpretation for uninterpreted functions. That is, the option
    /// <code>
    /// MODEL_PARTIAL=true
    /// </code>
    /// was used.
    /// </description>
    /// </item>
    /// </list>
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item>
    /// <description>
    /// t is type incorrect.
    /// </description>
    /// </item>
    /// </list>
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item>
    /// <description>
    /// Z3_interrupt was invoked during evaluation.
    /// </description>
    /// </item>
    /// </list>
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="t" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="modelCompletion" ctype="bool">
    /// bool parameter
    /// </param>
    /// <param name="v" ctype="Z3_ast *">
    /// ast parameter
    /// </param>
    public bool ModelEval(IntPtr c, IntPtr m, IntPtr t, bool modelCompletion, IntPtr v)
    {
        var result = nativeLibrary.ModelEval(c, m, t, modelCompletion, v);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the interpretation (i.e., assignment) of constant a in the model m.
    /// Return NULL, if the model does not assign an interpretation for a.
    /// That should be interpreted as: the value of a does not matter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="a" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, a) == 0
    /// </remarks>
    public IntPtr ModelGetConstInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var result = nativeLibrary.ModelGetConstInterp(c, m, a);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetConstInterp));
    }

    /// <summary>
    /// Test if there exists an interpretation (i.e., assignment) for a in the model m.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="a" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    public bool ModelHasInterp(IntPtr c, IntPtr m, IntPtr a)
    {
        var result = nativeLibrary.ModelHasInterp(c, m, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the interpretation of the function f in the model m.
    /// Return NULL, if the model does not assign an interpretation for f.
    /// That should be interpreted as: the f does not matter.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    /// <remarks>
    /// Precondition: Z3_get_arity(c, f) &gt; 0
    /// Reference counting must be used to manage Z3_func_interp objects, even when the Z3_context was
    /// created using
    /// <see cref="MkContext"/>
    /// instead of
    /// <see cref="MkContextRc"/>
    /// .
    /// </remarks>
    public IntPtr ModelGetFuncInterp(IntPtr c, IntPtr m, IntPtr f)
    {
        var result = nativeLibrary.ModelGetFuncInterp(c, m, f);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetFuncInterp));
    }

    /// <summary>
    /// Return the number of constants assigned by the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <seealso cref="ModelGetConstDecl"/>
    public uint ModelGetNumConsts(IntPtr c, IntPtr m)
    {
        var result = nativeLibrary.ModelGetNumConsts(c, m);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the i-th constant in the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_consts(c, m)
    /// </remarks>
    /// <seealso cref="ModelEval"/>
    /// <seealso cref="ModelGetNumConsts"/>
    public IntPtr ModelGetConstDecl(IntPtr c, IntPtr m, uint i)
    {
        var result = nativeLibrary.ModelGetConstDecl(c, m, i);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetConstDecl));
    }

    /// <summary>
    /// <para>
    /// Return the number of function interpretations in the given model.
    /// </para>
    /// <para>
    /// A function interpretation is represented as a finite map and an 'else' value.
    /// Each entry in the finite map represents the value of a function given a set of arguments.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <seealso cref="ModelGetFuncDecl"/>
    public uint ModelGetNumFuncs(IntPtr c, IntPtr m)
    {
        var result = nativeLibrary.ModelGetNumFuncs(c, m);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the declaration of the i-th function in the given model.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_funcs(c, m)
    /// </remarks>
    /// <seealso cref="ModelGetNumFuncs"/>
    public IntPtr ModelGetFuncDecl(IntPtr c, IntPtr m, uint i)
    {
        var result = nativeLibrary.ModelGetFuncDecl(c, m, i);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetFuncDecl));
    }

    /// <summary>
    /// <para>
    /// Return the number of uninterpreted sorts that m assigns an interpretation to.
    /// </para>
    /// <para>
    /// Z3 also provides an interpretation for uninterpreted sorts used in a formula.
    /// The interpretation for a sort s is a finite set of distinct values. We say this finite set is
    /// the "universe" of s.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <seealso cref="ModelGetSort"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    public uint ModelGetNumSorts(IntPtr c, IntPtr m)
    {
        var result = nativeLibrary.ModelGetNumSorts(c, m);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return a uninterpreted sort that m assigns an interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_model_get_num_sorts(c, m)
    /// </remarks>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSortUniverse"/>
    public IntPtr ModelGetSort(IntPtr c, IntPtr m, uint i)
    {
        var result = nativeLibrary.ModelGetSort(c, m, i);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetSort));
    }

    /// <summary>
    /// Return the finite set of distinct values that represent the interpretation for sort s.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="s" ctype="Z3_sort">
    /// sort parameter
    /// </param>
    /// <seealso cref="ModelGetNumSorts"/>
    /// <seealso cref="ModelGetSort"/>
    public IntPtr ModelGetSortUniverse(IntPtr c, IntPtr m, IntPtr s)
    {
        var result = nativeLibrary.ModelGetSortUniverse(c, m, s);
        CheckError(c);
        return CheckHandle(result, nameof(ModelGetSortUniverse));
    }

    /// <summary>
    /// translate model from context c to context dst.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="dst" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <remarks>
    /// Use this method for cloning state between contexts. Note that
    /// operations on contexts are not thread safe and therefore all operations
    /// that related to a given context have to be synchronized (or run in the same thread).
    /// </remarks>
    public IntPtr ModelTranslate(IntPtr c, IntPtr m, IntPtr dst)
    {
        var result = nativeLibrary.ModelTranslate(c, m, dst);
        CheckError(c);
        return CheckHandle(result, nameof(ModelTranslate));
    }

    /// <summary>
    /// <para>
    /// The
    /// <code>
    /// (_ as-array f)
    /// </code>
    /// AST node is a construct for assigning interpretations for arrays in Z3.
    /// It is the array such that forall indices i we have that
    /// <code>
    /// (select (_ as-array f) i)
    /// </code>
    /// is equal to
    /// <code>
    /// (f i)
    /// </code>
    /// .
    /// This procedure returns true if the a is an as-array AST node.
    /// </para>
    /// <para>
    /// Z3 current solvers have minimal support for as_array nodes.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="GetAsArrayFuncDecl"/>
    public bool IsAsArray(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.IsAsArray(c, a);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return the function declaration f associated with a
    /// <code>
    /// (_ as_array f)
    /// </code>
    /// node.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="IsAsArray"/>
    public IntPtr GetAsArrayFuncDecl(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.GetAsArrayFuncDecl(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(GetAsArrayFuncDecl));
    }

    /// <summary>
    /// Create a fresh func_interp object, add it to a model for a specified function.
    /// It has reference count 0.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model
    /// </param>
    /// <param name="f" ctype="Z3_func_decl">
    /// function declaration
    /// </param>
    /// <param name="defaultValue" ctype="Z3_ast">
    /// default value for function interpretation
    /// </param>
    public IntPtr AddFuncInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr defaultValue)
    {
        var result = nativeLibrary.AddFuncInterp(c, m, f, defaultValue);
        CheckError(c);
        return CheckHandle(result, nameof(AddFuncInterp));
    }

    /// <summary>
    /// Add a constant interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="m" ctype="Z3_model">
    /// model parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_decl">
    /// func_decl parameter
    /// </param>
    /// <param name="a" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public void AddConstInterp(IntPtr c, IntPtr m, IntPtr f, IntPtr a)
    {
        nativeLibrary.AddConstInterp(c, m, f, a);
        CheckError(c);
    }

    /// <summary>
    /// Increment the reference counter of the given Z3_func_interp object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    public void FuncInterpIncRef(IntPtr c, IntPtr f)
    {
        nativeLibrary.FuncInterpIncRef(c, f);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given Z3_func_interp object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    public void FuncInterpDecRef(IntPtr c, IntPtr f)
    {
        nativeLibrary.FuncInterpDecRef(c, f);
        CheckError(c);
    }

    /// <summary>
    /// <para>
    /// Return the number of entries in the given function interpretation.
    /// </para>
    /// <para>
    /// A function interpretation is represented as a finite map and an 'else' value.
    /// Each entry in the finite map represents the value of a function given a set of arguments.
    /// This procedure return the number of element in the finite map of f.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    /// <seealso cref="FuncInterpGetEntry"/>
    public uint FuncInterpGetNumEntries(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.FuncInterpGetNumEntries(c, f);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return a "point" of the given function interpretation. It represents the
    /// value of f in a particular point.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_interp_get_num_entries(c, f)
    /// </remarks>
    /// <seealso cref="FuncInterpGetNumEntries"/>
    public IntPtr FuncInterpGetEntry(IntPtr c, IntPtr f, uint i)
    {
        var result = nativeLibrary.FuncInterpGetEntry(c, f, i);
        CheckError(c);
        return CheckHandle(result, nameof(FuncInterpGetEntry));
    }

    /// <summary>
    /// <para>
    /// Return the 'else' value of the given function interpretation.
    /// </para>
    /// <para>
    /// A function interpretation is represented as a finite map and an 'else' value.
    /// This procedure returns the 'else' value.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    public IntPtr FuncInterpGetElse(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.FuncInterpGetElse(c, f);
        CheckError(c);
        return CheckHandle(result, nameof(FuncInterpGetElse));
    }

    /// <summary>
    /// <para>
    /// Return the 'else' value of the given function interpretation.
    /// </para>
    /// <para>
    /// A function interpretation is represented as a finite map and an 'else' value.
    /// This procedure can be used to update the 'else' value.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    /// <param name="elseValue" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public void FuncInterpSetElse(IntPtr c, IntPtr f, IntPtr elseValue)
    {
        nativeLibrary.FuncInterpSetElse(c, f, elseValue);
        CheckError(c);
    }

    /// <summary>
    /// Return the arity (number of arguments) of the given function interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="f" ctype="Z3_func_interp">
    /// func_interp parameter
    /// </param>
    public uint FuncInterpGetArity(IntPtr c, IntPtr f)
    {
        var result = nativeLibrary.FuncInterpGetArity(c, f);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// add a function entry to a function interpretation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// logical context
    /// </param>
    /// <param name="fi" ctype="Z3_func_interp">
    /// a function interpretation to be updated.
    /// </param>
    /// <param name="args" ctype="Z3_ast_vector">
    /// list of arguments. They should be constant values (such as integers) and be of the same types as the domain of the function.
    /// </param>
    /// <param name="value" ctype="Z3_ast">
    /// <para>
    /// value of the function when the parameters match args.
    /// </para>
    /// <para>
    /// It is assumed that entries added to a function cover disjoint arguments.
    /// If an two entries are added with the same arguments, only the second insertion survives and the
    /// first inserted entry is removed.
    /// </para>
    /// </param>
    public void FuncInterpAddEntry(IntPtr c, IntPtr fi, IntPtr args, IntPtr value)
    {
        nativeLibrary.FuncInterpAddEntry(c, fi, args, value);
        CheckError(c);
    }

    /// <summary>
    /// Increment the reference counter of the given Z3_func_entry object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    public void FuncEntryIncRef(IntPtr c, IntPtr e)
    {
        nativeLibrary.FuncEntryIncRef(c, e);
        CheckError(c);
    }

    /// <summary>
    /// Decrement the reference counter of the given Z3_func_entry object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    public void FuncEntryDecRef(IntPtr c, IntPtr e)
    {
        nativeLibrary.FuncEntryDecRef(c, e);
        CheckError(c);
    }

    /// <summary>
    /// <para>
    /// Return the value of this point.
    /// </para>
    /// <para>
    /// A Z3_func_entry object represents an element in the finite map used to encode
    /// a function interpretation.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    /// <seealso cref="FuncInterpGetEntry"/>
    public IntPtr FuncEntryGetValue(IntPtr c, IntPtr e)
    {
        var result = nativeLibrary.FuncEntryGetValue(c, e);
        CheckError(c);
        return CheckHandle(result, nameof(FuncEntryGetValue));
    }

    /// <summary>
    /// Return the number of arguments in a Z3_func_entry object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    /// <seealso cref="FuncEntryGetArg"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    public uint FuncEntryGetNumArgs(IntPtr c, IntPtr e)
    {
        var result = nativeLibrary.FuncEntryGetNumArgs(c, e);
        CheckError(c);
        return result;
    }

    /// <summary>
    /// Return an argument of a Z3_func_entry object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="e" ctype="Z3_func_entry">
    /// func_entry parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <remarks>
    /// Precondition: i &lt; Z3_func_entry_get_num_args(c, e)
    /// </remarks>
    /// <seealso cref="FuncEntryGetNumArgs"/>
    /// <seealso cref="FuncInterpGetEntry"/>
    public IntPtr FuncEntryGetArg(IntPtr c, IntPtr e, uint i)
    {
        var result = nativeLibrary.FuncEntryGetArg(c, e, i);
        CheckError(c);
        return CheckHandle(result, nameof(FuncEntryGetArg));
    }

}
