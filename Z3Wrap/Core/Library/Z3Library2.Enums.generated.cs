// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Enums.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// The different kinds of Z3 AST (abstract syntax trees). That is, terms, formulas and types.
    /// </summary>
    public enum AstKind
    {
        /// <summary>
        /// Z3_NUMERAL_AST
        /// </summary>
        /// <remarks>
        /// numeral constants
        /// </remarks>
        NumeralAst = 0,

        /// <summary>
        /// Z3_APP_AST
        /// </summary>
        /// <remarks>
        /// constant and applications
        /// </remarks>
        AppAst = 1,

        /// <summary>
        /// Z3_VAR_AST
        /// </summary>
        /// <remarks>
        /// bound variables
        /// </remarks>
        VarAst = 2,

        /// <summary>
        /// Z3_QUANTIFIER_AST
        /// </summary>
        /// <remarks>
        /// quantifiers
        /// </remarks>
        QuantifierAst = 3,

        /// <summary>
        /// Z3_SORT_AST
        /// </summary>
        /// <remarks>
        /// sort
        /// </remarks>
        SortAst = 4,

        /// <summary>
        /// Z3_FUNC_DECL_AST
        /// </summary>
        /// <remarks>
        /// function declaration
        /// </remarks>
        FuncDeclAst = 5,

        /// <summary>Z3_UNKNOWN_AST</summary>
        UnknownAst = 1000,
    }

    /// <summary>
    /// Z3 pretty printing modes (See <see cref="SetAstPrintMode"/>).
    /// </summary>
    public enum AstPrintMode
    {
        /// <summary>
        /// Z3_PRINT_SMTLIB_FULL
        /// </summary>
        /// <remarks>
        /// Print AST nodes in SMTLIB verbose format.
        /// </remarks>
        PrintSmtlibFull = 0,

        /// <summary>
        /// Z3_PRINT_LOW_LEVEL
        /// </summary>
        /// <remarks>
        /// Print AST nodes using a low-level format.
        /// </remarks>
        PrintLowLevel = 1,

        /// <summary>Z3_PRINT_SMTLIB2_COMPLIANT</summary>
        PrintSmtlib2Compliant = 2,
    }

    /// <summary>
    /// The different kinds of interpreted function kinds.
    /// </summary>
    /// <seealso cref="MkBvmulNoOverflow"/>
    /// <seealso cref="MkBvmulNoOverflow"/>
    public enum DeclKind
    {
        /// <summary>
        /// Z3_OP_TRUE
        /// </summary>
        /// <remarks>
        /// The constant true.
        /// </remarks>
        OpTrue = 0x100,

        /// <summary>
        /// Z3_OP_FALSE
        /// </summary>
        /// <remarks>
        /// The constant false.
        /// </remarks>
        OpFalse = 257,

        /// <summary>
        /// Z3_OP_EQ
        /// </summary>
        /// <remarks>
        /// The equality predicate.
        /// </remarks>
        OpEq = 258,

        /// <summary>
        /// Z3_OP_DISTINCT
        /// </summary>
        /// <remarks>
        /// The n-ary distinct predicate (every argument is mutually distinct).
        /// </remarks>
        OpDistinct = 259,

        /// <summary>
        /// Z3_OP_ITE
        /// </summary>
        /// <remarks>
        /// The ternary if-then-else term.
        /// </remarks>
        OpIte = 260,

        /// <summary>
        /// Z3_OP_AND
        /// </summary>
        /// <remarks>
        /// n-ary conjunction.
        /// </remarks>
        OpAnd = 261,

        /// <summary>
        /// Z3_OP_OR
        /// </summary>
        /// <remarks>
        /// n-ary disjunction.
        /// </remarks>
        OpOr = 262,

        /// <summary>
        /// Z3_OP_IFF
        /// </summary>
        /// <remarks>
        /// equivalence (binary).
        /// </remarks>
        OpIff = 263,

        /// <summary>
        /// Z3_OP_XOR
        /// </summary>
        /// <remarks>
        /// Exclusive or.
        /// </remarks>
        OpXor = 264,

        /// <summary>
        /// Z3_OP_NOT
        /// </summary>
        /// <remarks>
        /// Negation.
        /// </remarks>
        OpNot = 265,

        /// <summary>
        /// Z3_OP_IMPLIES
        /// </summary>
        /// <remarks>
        /// Implication.
        /// </remarks>
        OpImplies = 266,

        /// <summary>
        /// Z3_OP_OEQ
        /// </summary>
        /// <remarks>
        /// Binary equivalence modulo namings. This binary predicate is used in proof terms.
        /// It captures equisatisfiability and equivalence modulo renamings.
        /// </remarks>
        OpOeq = 267,

        /// <summary>
        /// Z3_OP_ANUM
        /// </summary>
        /// <remarks>
        /// Arithmetic numeral.
        /// </remarks>
        OpAnum = 0x200,

        /// <summary>
        /// Z3_OP_AGNUM
        /// </summary>
        /// <remarks>
        /// Arithmetic algebraic numeral. Algebraic numbers are used to represent irrational numbers in Z3.
        /// </remarks>
        OpAgnum = 513,

        /// <summary>
        /// Z3_OP_LE
        /// </summary>
        /// <remarks>
        /// &lt;=.
        /// </remarks>
        OpLe = 514,

        /// <summary>
        /// Z3_OP_GE
        /// </summary>
        /// <remarks>
        /// &gt;=.
        /// </remarks>
        OpGe = 515,

        /// <summary>
        /// Z3_OP_LT
        /// </summary>
        /// <remarks>
        /// &lt;.
        /// </remarks>
        OpLt = 516,

        /// <summary>
        /// Z3_OP_GT
        /// </summary>
        /// <remarks>
        /// &gt;.
        /// </remarks>
        OpGt = 517,

        /// <summary>
        /// Z3_OP_ADD
        /// </summary>
        /// <remarks>
        /// Addition - Binary.
        /// </remarks>
        OpAdd = 518,

        /// <summary>
        /// Z3_OP_SUB
        /// </summary>
        /// <remarks>
        /// Binary subtraction.
        /// </remarks>
        OpSub = 519,

        /// <summary>
        /// Z3_OP_UMINUS
        /// </summary>
        /// <remarks>
        /// Unary minus.
        /// </remarks>
        OpUminus = 520,

        /// <summary>
        /// Z3_OP_MUL
        /// </summary>
        /// <remarks>
        /// Multiplication - Binary.
        /// </remarks>
        OpMul = 521,

        /// <summary>
        /// Z3_OP_DIV
        /// </summary>
        /// <remarks>
        /// Division - Binary.
        /// </remarks>
        OpDiv = 522,

        /// <summary>
        /// Z3_OP_IDIV
        /// </summary>
        /// <remarks>
        /// Integer division - Binary.
        /// </remarks>
        OpIdiv = 523,

        /// <summary>
        /// Z3_OP_REM
        /// </summary>
        /// <remarks>
        /// Remainder - Binary.
        /// </remarks>
        OpRem = 524,

        /// <summary>
        /// Z3_OP_MOD
        /// </summary>
        /// <remarks>
        /// Modulus - Binary.
        /// </remarks>
        OpMod = 525,

        /// <summary>
        /// Z3_OP_TO_REAL
        /// </summary>
        /// <remarks>
        /// Coercion of integer to real - Unary.
        /// </remarks>
        OpToReal = 526,

        /// <summary>
        /// Z3_OP_TO_INT
        /// </summary>
        /// <remarks>
        /// Coercion of real to integer - Unary.
        /// </remarks>
        OpToInt = 527,

        /// <summary>
        /// Z3_OP_IS_INT
        /// </summary>
        /// <remarks>
        /// Check if real is also an integer - Unary.
        /// </remarks>
        OpIsInt = 528,

        /// <summary>
        /// Z3_OP_POWER
        /// </summary>
        /// <remarks>
        /// Power operator x^y.
        /// </remarks>
        OpPower = 529,

        /// <summary>Z3_OP_ABS</summary>
        OpAbs = 530,

        /// <summary>
        /// Z3_OP_STORE
        /// </summary>
        /// <remarks>
        /// Array store. It satisfies select(store(a,i,v),j) = if i = j then v else select(a,j).
        /// Array store takes at least 3 arguments.
        /// </remarks>
        OpStore = 0x300,

        /// <summary>
        /// Z3_OP_SELECT
        /// </summary>
        /// <remarks>
        /// Array select.
        /// </remarks>
        OpSelect = 769,

        /// <summary>
        /// Z3_OP_CONST_ARRAY
        /// </summary>
        /// <remarks>
        /// The constant array. For example, select(const(v),i) = v holds for every v and i. The function is unary.
        /// </remarks>
        OpConstArray = 770,

        /// <summary>
        /// Z3_OP_ARRAY_MAP
        /// </summary>
        /// <remarks>
        /// Array map operator.
        /// It satisfies map[f](a1,..,a_n)[i] = f(a1[i],...,a_n[i]) for every i.
        /// </remarks>
        OpArrayMap = 771,

        /// <summary>
        /// Z3_OP_ARRAY_DEFAULT
        /// </summary>
        /// <remarks>
        /// Default value of arrays. For example default(const(v)) = v. The function is unary.
        /// </remarks>
        OpArrayDefault = 772,

        /// <summary>
        /// Z3_OP_SET_UNION
        /// </summary>
        /// <remarks>
        /// Set union between two Boolean arrays (two arrays whose range type is Boolean). The function is binary.
        /// </remarks>
        OpSetUnion = 773,

        /// <summary>
        /// Z3_OP_SET_INTERSECT
        /// </summary>
        /// <remarks>
        /// Set intersection between two Boolean arrays. The function is binary.
        /// </remarks>
        OpSetIntersect = 774,

        /// <summary>
        /// Z3_OP_SET_DIFFERENCE
        /// </summary>
        /// <remarks>
        /// Set difference between two Boolean arrays. The function is binary.
        /// </remarks>
        OpSetDifference = 775,

        /// <summary>
        /// Z3_OP_SET_COMPLEMENT
        /// </summary>
        /// <remarks>
        /// Set complement of a Boolean array. The function is unary.
        /// </remarks>
        OpSetComplement = 776,

        /// <summary>
        /// Z3_OP_SET_SUBSET
        /// </summary>
        /// <remarks>
        /// Subset predicate between two Boolean arrays. The relation is binary.
        /// </remarks>
        OpSetSubset = 777,

        /// <summary>
        /// Z3_OP_AS_ARRAY
        /// </summary>
        /// <remarks>
        /// An array value that behaves as the function graph of the
        /// function passed as parameter.
        /// </remarks>
        OpAsArray = 778,

        /// <summary>
        /// Z3_OP_ARRAY_EXT
        /// </summary>
        /// <remarks>
        /// Array extensionality function. It takes two arrays as arguments and produces an index, such that the arrays
        /// are different if they are different on the index.
        /// </remarks>
        OpArrayExt = 779,

        /// <summary>Z3_OP_SET_HAS_SIZE</summary>
        OpSetHasSize = 780,

        /// <summary>Z3_OP_SET_CARD</summary>
        OpSetCard = 781,

        /// <summary>
        /// Z3_OP_BNUM
        /// </summary>
        /// <remarks>
        /// Bit-vector numeral.
        /// </remarks>
        OpBnum = 0x400,

        /// <summary>
        /// Z3_OP_BIT1
        /// </summary>
        /// <remarks>
        /// One bit bit-vector.
        /// </remarks>
        OpBit1 = 1025,

        /// <summary>
        /// Z3_OP_BIT0
        /// </summary>
        /// <remarks>
        /// Zero bit bit-vector.
        /// </remarks>
        OpBit0 = 1026,

        /// <summary>
        /// Z3_OP_BNEG
        /// </summary>
        /// <remarks>
        /// Unary minus.
        /// </remarks>
        OpBneg = 1027,

        /// <summary>
        /// Z3_OP_BADD
        /// </summary>
        /// <remarks>
        /// Binary addition.
        /// </remarks>
        OpBadd = 1028,

        /// <summary>
        /// Z3_OP_BSUB
        /// </summary>
        /// <remarks>
        /// Binary subtraction.
        /// </remarks>
        OpBsub = 1029,

        /// <summary>
        /// Z3_OP_BMUL
        /// </summary>
        /// <remarks>
        /// Binary multiplication.
        /// </remarks>
        OpBmul = 1030,

        /// <summary>
        /// Z3_OP_BSDIV
        /// </summary>
        /// <remarks>
        /// Binary signed division.
        /// </remarks>
        OpBsdiv = 1031,

        /// <summary>
        /// Z3_OP_BUDIV
        /// </summary>
        /// <remarks>
        /// Binary unsigned division.
        /// </remarks>
        OpBudiv = 1032,

        /// <summary>
        /// Z3_OP_BSREM
        /// </summary>
        /// <remarks>
        /// Binary signed remainder.
        /// </remarks>
        OpBsrem = 1033,

        /// <summary>
        /// Z3_OP_BUREM
        /// </summary>
        /// <remarks>
        /// Binary unsigned remainder.
        /// </remarks>
        OpBurem = 1034,

        /// <summary>
        /// Z3_OP_BSMOD
        /// </summary>
        /// <remarks>
        /// Binary signed modulus.
        /// </remarks>
        OpBsmod = 1035,

        /// <summary>
        /// Z3_OP_BSDIV0
        /// </summary>
        /// <remarks>
        /// Unary function. bsdiv(x,0) is congruent to bsdiv0(x).
        /// </remarks>
        OpBsdiv0 = 1036,

        /// <summary>
        /// Z3_OP_BUDIV0
        /// </summary>
        /// <remarks>
        /// Unary function. budiv(x,0) is congruent to budiv0(x).
        /// </remarks>
        OpBudiv0 = 1037,

        /// <summary>
        /// Z3_OP_BSREM0
        /// </summary>
        /// <remarks>
        /// Unary function. bsrem(x,0) is congruent to bsrem0(x).
        /// </remarks>
        OpBsrem0 = 1038,

        /// <summary>
        /// Z3_OP_BUREM0
        /// </summary>
        /// <remarks>
        /// Unary function. burem(x,0) is congruent to burem0(x).
        /// </remarks>
        OpBurem0 = 1039,

        /// <summary>
        /// Z3_OP_BSMOD0
        /// </summary>
        /// <remarks>
        /// Unary function. bsmod(x,0) is congruent to bsmod0(x).
        /// </remarks>
        OpBsmod0 = 1040,

        /// <summary>
        /// Z3_OP_ULEQ
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector &lt;= - Binary relation.
        /// </remarks>
        OpUleq = 1041,

        /// <summary>
        /// Z3_OP_SLEQ
        /// </summary>
        /// <remarks>
        /// Signed bit-vector  &lt;= - Binary relation.
        /// </remarks>
        OpSleq = 1042,

        /// <summary>
        /// Z3_OP_UGEQ
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector  &gt;= - Binary relation.
        /// </remarks>
        OpUgeq = 1043,

        /// <summary>
        /// Z3_OP_SGEQ
        /// </summary>
        /// <remarks>
        /// Signed bit-vector  &gt;= - Binary relation.
        /// </remarks>
        OpSgeq = 1044,

        /// <summary>
        /// Z3_OP_ULT
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector  &lt; - Binary relation.
        /// </remarks>
        OpUlt = 1045,

        /// <summary>
        /// Z3_OP_SLT
        /// </summary>
        /// <remarks>
        /// Signed bit-vector &lt; - Binary relation.
        /// </remarks>
        OpSlt = 1046,

        /// <summary>
        /// Z3_OP_UGT
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector &gt; - Binary relation.
        /// </remarks>
        OpUgt = 1047,

        /// <summary>
        /// Z3_OP_SGT
        /// </summary>
        /// <remarks>
        /// Signed bit-vector &gt; - Binary relation.
        /// </remarks>
        OpSgt = 1048,

        /// <summary>
        /// Z3_OP_BAND
        /// </summary>
        /// <remarks>
        /// Bit-wise and - Binary.
        /// </remarks>
        OpBand = 1049,

        /// <summary>
        /// Z3_OP_BOR
        /// </summary>
        /// <remarks>
        /// Bit-wise or - Binary.
        /// </remarks>
        OpBor = 1050,

        /// <summary>
        /// Z3_OP_BNOT
        /// </summary>
        /// <remarks>
        /// Bit-wise not - Unary.
        /// </remarks>
        OpBnot = 1051,

        /// <summary>
        /// Z3_OP_BXOR
        /// </summary>
        /// <remarks>
        /// Bit-wise xor - Binary.
        /// </remarks>
        OpBxor = 1052,

        /// <summary>
        /// Z3_OP_BNAND
        /// </summary>
        /// <remarks>
        /// Bit-wise nand - Binary.
        /// </remarks>
        OpBnand = 1053,

        /// <summary>
        /// Z3_OP_BNOR
        /// </summary>
        /// <remarks>
        /// Bit-wise nor - Binary.
        /// </remarks>
        OpBnor = 1054,

        /// <summary>
        /// Z3_OP_BXNOR
        /// </summary>
        /// <remarks>
        /// Bit-wise xnor - Binary.
        /// </remarks>
        OpBxnor = 1055,

        /// <summary>
        /// Z3_OP_CONCAT
        /// </summary>
        /// <remarks>
        /// Bit-vector concatenation - Binary.
        /// </remarks>
        OpConcat = 1056,

        /// <summary>
        /// Z3_OP_SIGN_EXT
        /// </summary>
        /// <remarks>
        /// Bit-vector sign extension.
        /// </remarks>
        OpSignExt = 1057,

        /// <summary>
        /// Z3_OP_ZERO_EXT
        /// </summary>
        /// <remarks>
        /// Bit-vector zero extension.
        /// </remarks>
        OpZeroExt = 1058,

        /// <summary>
        /// Z3_OP_EXTRACT
        /// </summary>
        /// <remarks>
        /// Bit-vector extraction.
        /// </remarks>
        OpExtract = 1059,

        /// <summary>
        /// Z3_OP_REPEAT
        /// </summary>
        /// <remarks>
        /// Repeat bit-vector n times.
        /// </remarks>
        OpRepeat = 1060,

        /// <summary>
        /// Z3_OP_BREDOR
        /// </summary>
        /// <remarks>
        /// Bit-vector reduce or - Unary.
        /// </remarks>
        OpBredor = 1061,

        /// <summary>
        /// Z3_OP_BREDAND
        /// </summary>
        /// <remarks>
        /// Bit-vector reduce and - Unary.
        /// </remarks>
        OpBredand = 1062,

        /// <summary>
        /// Z3_OP_BCOMP
        /// </summary>
        /// <remarks>
        /// .
        /// </remarks>
        OpBcomp = 1063,

        /// <summary>
        /// Z3_OP_BSHL
        /// </summary>
        /// <remarks>
        /// Shift left.
        /// </remarks>
        OpBshl = 1064,

        /// <summary>
        /// Z3_OP_BLSHR
        /// </summary>
        /// <remarks>
        /// Logical shift right.
        /// </remarks>
        OpBlshr = 1065,

        /// <summary>
        /// Z3_OP_BASHR
        /// </summary>
        /// <remarks>
        /// Arithmetical shift right.
        /// </remarks>
        OpBashr = 1066,

        /// <summary>
        /// Z3_OP_ROTATE_LEFT
        /// </summary>
        /// <remarks>
        /// Left rotation.
        /// </remarks>
        OpRotateLeft = 1067,

        /// <summary>
        /// Z3_OP_ROTATE_RIGHT
        /// </summary>
        /// <remarks>
        /// Right rotation.
        /// </remarks>
        OpRotateRight = 1068,

        /// <summary>
        /// Z3_OP_EXT_ROTATE_LEFT
        /// </summary>
        /// <remarks>
        /// (extended) Left rotation. Similar to Z3_OP_ROTATE_LEFT, but it is a binary operator instead of a parametric one.
        /// </remarks>
        OpExtRotateLeft = 1069,

        /// <summary>
        /// Z3_OP_EXT_ROTATE_RIGHT
        /// </summary>
        /// <remarks>
        /// (extended) Right rotation. Similar to Z3_OP_ROTATE_RIGHT, but it is a binary operator instead of a parametric one.
        /// </remarks>
        OpExtRotateRight = 1070,

        /// <summary>Z3_OP_BIT2BOOL</summary>
        OpBit2bool = 1071,

        /// <summary>
        /// Z3_OP_INT2BV
        /// </summary>
        /// <remarks>
        /// Coerce integer to bit-vector.
        /// </remarks>
        OpInt2bv = 1072,

        /// <summary>
        /// Z3_OP_BV2INT
        /// </summary>
        /// <remarks>
        /// Coerce bit-vector to integer.
        /// </remarks>
        OpBv2int = 1073,

        /// <summary>
        /// Z3_OP_SBV2INT
        /// </summary>
        /// <remarks>
        /// Coerce signed bit-vector to integer.
        /// </remarks>
        OpSbv2int = 1074,

        /// <summary>
        /// Z3_OP_CARRY
        /// </summary>
        /// <remarks>
        /// Compute the carry bit in a full-adder.
        /// The meaning is given by the equivalence
        /// (carry l1 l2 l3) &lt;=&gt; (or (and l1 l2) (and l1 l3) (and l2 l3)))
        /// </remarks>
        OpCarry = 1075,

        /// <summary>
        /// Z3_OP_XOR3
        /// </summary>
        /// <remarks>
        /// Compute ternary XOR.
        /// The meaning is given by the equivalence
        /// (xor3 l1 l2 l3) &lt;=&gt; (xor (xor l1 l2) l3)
        /// </remarks>
        OpXor3 = 1076,

        /// <summary>
        /// Z3_OP_BSMUL_NO_OVFL
        /// </summary>
        /// <remarks>
        /// a predicate to check that bit-wise signed multiplication does not overflow.
        /// Signed multiplication overflows if the operands have the same sign and the result of multiplication
        /// does not fit within the available bits. \sa Z3_mk_bvmul_no_overflow.
        /// </remarks>
        OpBsmulNoOvfl = 1077,

        /// <summary>
        /// Z3_OP_BUMUL_NO_OVFL
        /// </summary>
        /// <remarks>
        /// check that bit-wise unsigned multiplication does not overflow.
        /// Unsigned multiplication overflows if the result does not fit within the available bits.
        /// \sa Z3_mk_bvmul_no_overflow.
        /// </remarks>
        OpBumulNoOvfl = 1078,

        /// <summary>
        /// Z3_OP_BSMUL_NO_UDFL
        /// </summary>
        /// <remarks>
        /// check that bit-wise signed multiplication does not underflow.
        /// Signed multiplication underflows if the operands have opposite signs and the result of multiplication
        /// does not fit within the available bits. Z3_mk_bvmul_no_underflow.
        /// </remarks>
        OpBsmulNoUdfl = 1079,

        /// <summary>
        /// Z3_OP_BSDIV_I
        /// </summary>
        /// <remarks>
        /// Binary signed division.
        /// It has the same semantics as Z3_OP_BSDIV, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBsdivI = 1080,

        /// <summary>
        /// Z3_OP_BUDIV_I
        /// </summary>
        /// <remarks>
        /// Binary unsigned division.
        /// It has the same semantics as Z3_OP_BUDIV, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBudivI = 1081,

        /// <summary>
        /// Z3_OP_BSREM_I
        /// </summary>
        /// <remarks>
        /// Binary signed remainder.
        /// It has the same semantics as Z3_OP_BSREM, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBsremI = 1082,

        /// <summary>
        /// Z3_OP_BUREM_I
        /// </summary>
        /// <remarks>
        /// Binary unsigned remainder.
        /// It has the same semantics as Z3_OP_BUREM, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBuremI = 1083,

        /// <summary>
        /// Z3_OP_BSMOD_I
        /// </summary>
        /// <remarks>
        /// Binary signed modulus.
        /// It has the same semantics as Z3_OP_BSMOD, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        OpBsmodI = 1084,

        /// <summary>
        /// Z3_OP_PR_UNDEF
        /// </summary>
        /// <remarks>
        /// Undef/Null proof object.
        /// </remarks>
        OpPrUndef = 0x500,

        /// <summary>
        /// Z3_OP_PR_TRUE
        /// </summary>
        /// <remarks>
        /// Proof for the expression 'true'.
        /// </remarks>
        OpPrTrue = 1281,

        /// <summary>
        /// Z3_OP_PR_ASSERTED
        /// </summary>
        /// <remarks>
        /// Proof for a fact asserted by the user.
        /// </remarks>
        OpPrAsserted = 1282,

        /// <summary>
        /// Z3_OP_PR_GOAL
        /// </summary>
        /// <remarks>
        /// Proof for a fact (tagged as goal) asserted by the user.
        /// </remarks>
        OpPrGoal = 1283,

        /// <summary>
        /// Z3_OP_PR_MODUS_PONENS
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for p and a proof for (implies p q), produces a proof for q.
        /// </para>
        /// <para>
        /// T1: p
        /// T2: (implies p q)
        /// [mp T1 T2]: q
        /// </para>
        /// <para>
        /// The second antecedents may also be a proof for (iff p q).
        /// </para>
        /// </remarks>
        OpPrModusPonens = 1284,

        /// <summary>
        /// Z3_OP_PR_REFLEXIVITY
        /// </summary>
        /// <remarks>
        /// A proof for (R t t), where R is a reflexive relation. This proof object has no antecedents.
        /// The only reflexive relations that are used are
        /// equivalence modulo namings, equality and equivalence.
        /// That is, R is either '~', '=' or 'iff'.
        /// </remarks>
        OpPrReflexivity = 1285,

        /// <summary>
        /// Z3_OP_PR_SYMMETRY
        /// </summary>
        /// <remarks>
        /// Given an symmetric relation R and a proof for (R t s), produces a proof for (R s t).
        /// <code>
        /// ╔════════════════════════╗
        /// ║ T1: (R t s)            ║
        /// ║ [symmetry T1]: (R s t) ║
        /// ╚════════════════════════╝
        /// </code>
        /// T1 is the antecedent of this proof object.
        /// </remarks>
        OpPrSymmetry = 1286,

        /// <summary>
        /// Z3_OP_PR_TRANSITIVITY
        /// </summary>
        /// <remarks>
        /// Given a transitive relation R, and proofs for (R t s) and (R s u), produces a proof
        /// for (R t u).
        /// <code>
        /// ╔════════════════════════╗
        /// ║ T1: (R t s)            ║
        /// ║ T2: (R s u)            ║
        /// ║ [trans T1 T2]: (R t u) ║
        /// ╚════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrTransitivity = 1287,

        /// <summary>
        /// Z3_OP_PR_TRANSITIVITY_STAR
        /// </summary>
        /// <remarks>
        /// <para>
        /// Condensed transitivity proof.
        /// It combines several symmetry and transitivity proofs. Example:
        /// <code>
        /// ╔════════════════════════════╗
        /// ║ T1: (R a b)                ║
        /// ║ T2: (R c b)                ║
        /// ║ T3: (R c d)                ║
        /// ║ [trans* T1 T2 T3]: (R a d) ║
        /// ╚════════════════════════════╝
        /// </code>
        /// R must be a symmetric and transitive relation.
        /// </para>
        /// <para>
        /// Assuming that this proof object is a proof for (R s t), then
        /// a proof checker must check if it is possible to prove (R s t)
        /// using the antecedents, symmetry and transitivity.  That is,
        /// if there is a path from s to t, if we view every
        /// antecedent (R a b) as an edge between a and b.
        /// </para>
        /// </remarks>
        OpPrTransitivityStar = 1288,

        /// <summary>
        /// Z3_OP_PR_MONOTONICITY
        /// </summary>
        /// <remarks>
        /// <para>
        /// Monotonicity proof object.
        /// </para>
        /// <para>
        /// T1: (R t_1 s_1)
        /// ...
        /// Tn: (R t_n s_n)
        /// [monotonicity T1 ... Tn]: (R (f t_1 ... t_n) (f s_1 ... s_n))
        /// </para>
        /// <para>
        /// Remark: if t_i == s_i, then the antecedent Ti is suppressed.
        /// That is, reflexivity proofs are suppressed to save space.
        /// </para>
        /// </remarks>
        OpPrMonotonicity = 1289,

        /// <summary>
        /// Z3_OP_PR_QUANT_INTRO
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for (~ p q), produces a proof for (~ (forall (x) p) (forall (x) q)).
        /// </para>
        /// <para>
        /// T1: (~ p q)
        /// [quant-intro T1]: (~ (forall (x) p) (forall (x) q))
        /// </para>
        /// </remarks>
        OpPrQuantIntro = 1290,

        /// <summary>
        /// Z3_OP_PR_BIND
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof p, produces a proof of lambda x . p, where x are free variables in p.
        /// </para>
        /// <para>
        /// T1: f
        /// [proof-bind T1] forall (x) f
        /// </para>
        /// </remarks>
        OpPrBind = 1291,

        /// <summary>
        /// Z3_OP_PR_DISTRIBUTIVITY
        /// </summary>
        /// <remarks>
        /// <para>
        /// Distributivity proof object.
        /// Given that f (= or) distributes over g (= and), produces a proof for
        /// <code>
        /// ╔══════════════════════╗
        /// ║ (= (f a (g c d))     ║
        /// ║ (g (f a c) (f a d))) ║
        /// ╚══════════════════════╝
        /// </code>
        /// If f and g are associative, this proof also justifies the following equality:
        /// <code>
        /// ╔══════════════════════════════════════╗
        /// ║ (= (f (g a b) (g c d))               ║
        /// ║ (g (f a c) (f a d) (f b c) (f b d))) ║
        /// ╚══════════════════════════════════════╝
        /// </code>
        /// where each f and g can have arbitrary number of arguments.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// Remark. This rule is used by the CNF conversion pass and
        /// instantiated by f = or, and g = and.
        /// </para>
        /// </remarks>
        OpPrDistributivity = 1292,

        /// <summary>
        /// Z3_OP_PR_AND_ELIM
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for (and l_1 ... l_n), produces a proof for l_i
        /// </para>
        /// <para>
        /// T1: (and l_1 ... l_n)
        /// [and-elim T1]: l_i
        /// </para>
        /// </remarks>
        OpPrAndElim = 1293,

        /// <summary>
        /// Z3_OP_PR_NOT_OR_ELIM
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for (not (or l_1 ... l_n)), produces a proof for (not l_i).
        /// </para>
        /// <para>
        /// T1: (not (or l_1 ... l_n))
        /// [not-or-elim T1]: (not l_i)
        /// </para>
        /// </remarks>
        OpPrNotOrElim = 1294,

        /// <summary>
        /// Z3_OP_PR_REWRITE
        /// </summary>
        /// <remarks>
        /// <para>
        /// A proof for a local rewriting step (= t s).
        /// The head function symbol of t is interpreted.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// The conclusion of a rewrite rule is either an equality (= t s),
        /// an equivalence (iff t s), or equi-satisfiability (~ t s).
        /// Remark: if f is bool, then = is iff.
        /// Examples:
        /// <code>
        /// ╔═══════════════════════╗
        /// ║ (= (+ x 0) x)         ║
        /// ║ (= (+ x 1 2) (+ 3 x)) ║
        /// ║ (iff (or x false) x)  ║
        /// ╚═══════════════════════╝
        /// </code>
        /// </para>
        /// </remarks>
        OpPrRewrite = 1295,

        /// <summary>
        /// Z3_OP_PR_REWRITE_STAR
        /// </summary>
        /// <remarks>
        /// A proof for rewriting an expression t into an expression s.
        /// This proof object can have n antecedents.
        /// The antecedents are proofs for equalities used as substitution rules.
        /// The proof rule is used in a few cases. The cases are:
        /// <list type="bullet">
        /// <item><description>When applying contextual simplification (CONTEXT_SIMPLIFIER=true)</description></item>
        /// <item><description>When converting bit-vectors to Booleans (BIT2BOOL=true)</description></item>
        /// </list>
        /// </remarks>
        OpPrRewriteStar = 1296,

        /// <summary>
        /// Z3_OP_PR_PULL_QUANT
        /// </summary>
        /// <remarks>
        /// A proof for (iff (f (forall (x) q(x)) r) (forall (x) (f (q x) r))). This proof object has no antecedents.
        /// </remarks>
        OpPrPullQuant = 1297,

        /// <summary>
        /// Z3_OP_PR_PUSH_QUANT
        /// </summary>
        /// <remarks>
        /// A proof for:
        /// <code>
        /// ╔═════════════════════════════════════════════════════════════════════════╗
        /// ║ (iff (forall (x_1 ... x_m) (and p_1[x_1 ... x_m] ... p_n[x_1 ... x_m])) ║
        /// ║ (and (forall (x_1 ... x_m) p_1[x_1 ... x_m])                            ║
        /// ║ ...                                                                     ║
        /// ║ (forall (x_1 ... x_m) p_n[x_1 ... x_m])))                               ║
        /// ╚═════════════════════════════════════════════════════════════════════════╝
        /// </code>
        /// This proof object has no antecedents.
        /// </remarks>
        OpPrPushQuant = 1298,

        /// <summary>
        /// Z3_OP_PR_ELIM_UNUSED_VARS
        /// </summary>
        /// <remarks>
        /// <para>
        /// A proof for (iff (forall (x_1 ... x_n y_1 ... y_m) p[x_1 ... x_n])
        /// (forall (x_1 ... x_n) p[x_1 ... x_n]))
        /// </para>
        /// <para>
        /// It is used to justify the elimination of unused variables.
        /// This proof object has no antecedents.
        /// </para>
        /// </remarks>
        OpPrElimUnusedVars = 1299,

        /// <summary>
        /// Z3_OP_PR_DER
        /// </summary>
        /// <remarks>
        /// <para>
        /// A proof for destructive equality resolution:
        /// (iff (forall (x) (or (not (= x t)) P[x])) P[t])
        /// if x does not occur in t.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// </para>
        /// <para>
        /// Several variables can be eliminated simultaneously.
        /// </para>
        /// </remarks>
        OpPrDer = 1300,

        /// <summary>
        /// Z3_OP_PR_QUANT_INST
        /// </summary>
        /// <remarks>
        /// A proof of (or (not (forall (x) (P x))) (P a))
        /// </remarks>
        OpPrQuantInst = 1301,

        /// <summary>
        /// Z3_OP_PR_HYPOTHESIS
        /// </summary>
        /// <remarks>
        /// Mark a hypothesis in a natural deduction style proof.
        /// </remarks>
        OpPrHypothesis = 1302,

        /// <summary>
        /// Z3_OP_PR_LEMMA
        /// </summary>
        /// <remarks>
        /// <para>
        /// T1: false
        /// [lemma T1]: (or (not l_1) ... (not l_n))
        /// </para>
        /// <para>
        /// This proof object has one antecedent: a hypothetical proof for false.
        /// It converts the proof in a proof for (or (not l_1) ... (not l_n)),
        /// when T1 contains the open hypotheses: l_1, ..., l_n.
        /// The hypotheses are closed after an application of a lemma.
        /// Furthermore, there are no other open hypotheses in the subtree covered by
        /// the lemma.
        /// </para>
        /// </remarks>
        OpPrLemma = 1303,

        /// <summary>
        /// Z3_OP_PR_UNIT_RESOLUTION
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═════════════════════════════════════════════════════╗
        /// ║ T1:      (or l_1 ... l_n l_1' ... l_m')             ║
        /// ║ T2:      (not l_1)                                  ║
        /// ║ ...                                                 ║
        /// ║ T(n+1):  (not l_n)                                  ║
        /// ║ [unit-resolution T1 ... T(n+1)]: (or l_1' ... l_m') ║
        /// ╚═════════════════════════════════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrUnitResolution = 1304,

        /// <summary>
        /// Z3_OP_PR_IFF_TRUE
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═════════════════════════════╗
        /// ║ T1: p                       ║
        /// ║ [iff-true T1]: (iff p true) ║
        /// ╚═════════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrIffTrue = 1305,

        /// <summary>
        /// Z3_OP_PR_IFF_FALSE
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═══════════════════════════════╗
        /// ║ T1: (not p)                   ║
        /// ║ [iff-false T1]: (iff p false) ║
        /// ╚═══════════════════════════════╝
        /// </code>
        /// </remarks>
        OpPrIffFalse = 1306,

        /// <summary>
        /// Z3_OP_PR_COMMUTATIVITY
        /// </summary>
        /// <remarks>
        /// <para>
        /// [comm]: (= (f a b) (f b a))
        /// </para>
        /// <para>
        /// f is a commutative operator.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// Remark: if f is bool, then = is iff.
        /// </para>
        /// </remarks>
        OpPrCommutativity = 1307,

        /// <summary>
        /// Z3_OP_PR_DEF_AXIOM
        /// </summary>
        /// <remarks>
        /// Proof object used to justify Tseitin's like axioms:
        /// <code>
        /// ╔══════════════════════════════════╗
        /// ║ (or (not (and p q)) p)           ║
        /// ║ (or (not (and p q)) q)           ║
        /// ║ (or (not (and p q r)) p)         ║
        /// ║ (or (not (and p q r)) q)         ║
        /// ║ (or (not (and p q r)) r)         ║
        /// ║ ...                              ║
        /// ║ (or (and p q) (not p) (not q))   ║
        /// ║ (or (not (or p q)) p q)          ║
        /// ║ (or (or p q) (not p))            ║
        /// ║ (or (or p q) (not q))            ║
        /// ║ (or (not (iff p q)) (not p) q)   ║
        /// ║ (or (not (iff p q)) p (not q))   ║
        /// ║ (or (iff p q) (not p) (not q))   ║
        /// ║ (or (iff p q) p q)               ║
        /// ║ (or (not (ite a b c)) (not a) b) ║
        /// ║ (or (not (ite a b c)) a c)       ║
        /// ║ (or (ite a b c) (not a) (not b)) ║
        /// ║ (or (ite a b c) a (not c))       ║
        /// ║ (or (not (not a)) (not a))       ║
        /// ║ (or (not a) a)                   ║
        /// ╚══════════════════════════════════╝
        /// </code>
        /// This proof object has no antecedents.
        /// Note: all axioms are propositional tautologies.
        /// Note also that 'and' and 'or' can take multiple arguments.
        /// You can recover the propositional tautologies by
        /// unfolding the Boolean connectives in the axioms a small
        /// bounded number of steps (=3).
        /// </remarks>
        OpPrDefAxiom = 1308,

        /// <summary>
        /// Z3_OP_PR_ASSUMPTION_ADD
        /// </summary>
        /// <remarks>
        /// Clausal proof adding axiom
        /// </remarks>
        OpPrAssumptionAdd = 1309,

        /// <summary>
        /// Z3_OP_PR_LEMMA_ADD
        /// </summary>
        /// <remarks>
        /// Clausal proof lemma addition
        /// </remarks>
        OpPrLemmaAdd = 1310,

        /// <summary>
        /// Z3_OP_PR_REDUNDANT_DEL
        /// </summary>
        /// <remarks>
        /// Clausal proof lemma deletion
        /// </remarks>
        OpPrRedundantDel = 1311,

        /// <summary>Z3_OP_PR_CLAUSE_TRAIL</summary>
        OpPrClauseTrail = 1312,

        /// <summary>
        /// Z3_OP_PR_DEF_INTRO
        /// </summary>
        /// <remarks>
        /// <para>
        /// Introduces a name for a formula/term.
        /// Suppose e is an expression with free variables x, and def-intro
        /// introduces the name n(x). The possible cases are:
        /// </para>
        /// <para>
        /// When e is of Boolean type:
        /// [def-intro]: (and (or n (not e)) (or (not n) e))
        /// </para>
        /// <para>
        /// or:
        /// [def-intro]: (or (not n) e)
        /// when e only occurs positively.
        /// </para>
        /// <para>
        /// When e is of the form (ite cond th el):
        /// [def-intro]: (and (or (not cond) (= n th)) (or cond (= n el)))
        /// </para>
        /// <para>
        /// Otherwise:
        /// [def-intro]: (= n e)
        /// </para>
        /// </remarks>
        OpPrDefIntro = 1313,

        /// <summary>
        /// Z3_OP_PR_APPLY_DEF
        /// </summary>
        /// <remarks>
        /// <para>
        /// [apply-def T1]: F ~ n
        /// </para>
        /// <para>
        /// F is 'equivalent' to n, given that T1 is a proof that
        /// n is a name for F.
        /// </para>
        /// </remarks>
        OpPrApplyDef = 1314,

        /// <summary>
        /// Z3_OP_PR_IFF_OEQ
        /// </summary>
        /// <remarks>
        /// T1: (iff p q)
        /// [iff~ T1]: (~ p q)
        /// </remarks>
        OpPrIffOeq = 1315,

        /// <summary>
        /// Z3_OP_PR_NNF_POS
        /// </summary>
        /// <remarks>
        /// <para>
        /// Proof for a (positive) NNF step. Example:
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// T2: (not s_2) ~ r_2
        /// T3: s_1 ~ r_1'
        /// T4: s_2 ~ r_2'
        /// [nnf-pos T1 T2 T3 T4]: (~ (iff s_1 s_2) (and (or r_1 r_2') (or r_1' r_2)))
        /// </para>
        /// <para>
        /// The negation normal form steps NNF_POS and NNF_NEG are used in the following cases:
        /// (a) When creating the NNF of a positive force quantifier.
        /// The quantifier is retained (unless the bound variables are eliminated).
        /// Example
        /// </para>
        /// <para>
        /// T1: q ~ q_new
        /// [nnf-pos T1]: (~ (forall (x T) q) (forall (x T) q_new))
        /// </para>
        /// <para>
        /// (b) When recursively creating NNF over Boolean formulas, where the top-level
        /// connective is changed during NNF conversion. The relevant Boolean connectives
        /// for NNF_POS are 'implies', 'iff', 'xor', 'ite'.
        /// NNF_NEG furthermore handles the case where negation is pushed
        /// over Boolean connectives 'and' and 'or'.
        /// </para>
        /// </remarks>
        OpPrNnfPos = 1316,

        /// <summary>
        /// Z3_OP_PR_NNF_NEG
        /// </summary>
        /// <remarks>
        /// <para>
        /// Proof for a (negative) NNF step. Examples:
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// ...
        /// Tn: (not s_n) ~ r_n
        /// [nnf-neg T1 ... Tn]: (not (and s_1 ... s_n)) ~ (or r_1 ... r_n)
        /// </para>
        /// <para>
        /// and
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// ...
        /// Tn: (not s_n) ~ r_n
        /// [nnf-neg T1 ... Tn]: (not (or s_1 ... s_n)) ~ (and r_1 ... r_n)
        /// </para>
        /// <para>
        /// and
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// T2: (not s_2) ~ r_2
        /// T3: s_1 ~ r_1'
        /// T4: s_2 ~ r_2'
        /// [nnf-neg T1 T2 T3 T4]: (~ (not (iff s_1 s_2))
        /// (and (or r_1 r_2) (or r_1' r_2')))
        /// </para>
        /// </remarks>
        OpPrNnfNeg = 1317,

        /// <summary>
        /// Z3_OP_PR_SKOLEMIZE
        /// </summary>
        /// <remarks>
        /// <para>
        /// Proof for:
        /// </para>
        /// <para>
        /// [sk]: (~ (not (forall x (p x y))) (not (p (sk y) y)))
        /// [sk]: (~ (exists x (p x y)) (p (sk y) y))
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// </para>
        /// </remarks>
        OpPrSkolemize = 1318,

        /// <summary>
        /// Z3_OP_PR_MODUS_PONENS_OEQ
        /// </summary>
        /// <remarks>
        /// <para>
        /// Modus ponens style rule for equi-satisfiability.
        /// </para>
        /// <para>
        /// T1: p
        /// T2: (~ p q)
        /// [mp~ T1 T2]: q
        /// </para>
        /// </remarks>
        OpPrModusPonensOeq = 1319,

        /// <summary>
        /// Z3_OP_PR_TH_LEMMA
        /// </summary>
        /// <remarks>
        /// <para>
        /// Generic proof for theory lemmas.
        /// The theory lemma function comes with one or more parameters.
        /// The first parameter indicates the name of the theory.
        /// For the theory of arithmetic, additional parameters provide hints for
        /// checking the theory lemma.
        /// The hints for arithmetic are:
        /// </para>
        /// <para>
        /// <list type="bullet">
        /// <item><description>farkas - followed by rational coefficients. Multiply the coefficients to the inequalities in the lemma, add the (negated) inequalities and obtain a contradiction.</description></item>
        /// </list>
        /// </para>
        /// <para>
        /// <list type="bullet">
        /// <item><description>triangle-eq - Indicates a lemma related to the equivalence:</description></item>
        /// </list>
        /// </para>
        /// <para>
        /// (iff (= t1 t2) (and (&lt;= t1 t2) (&lt;= t2 t1)))
        /// </para>
        /// <para>
        /// <list type="bullet">
        /// <item><description>gcd-test - Indicates an integer linear arithmetic lemma that uses a gcd test.</description></item>
        /// </list>
        /// </para>
        /// </remarks>
        OpPrThLemma = 1320,

        /// <summary>
        /// Z3_OP_PR_HYPER_RESOLVE
        /// </summary>
        /// <remarks>
        /// <para>
        /// Hyper-resolution rule.
        /// </para>
        /// <para>
        /// The premises of the rules is a sequence of clauses.
        /// The first clause argument is the main clause of the rule.
        /// with a literal from the first (main) clause.
        /// </para>
        /// <para>
        /// Premises of the rules are of the form
        /// <code>
        /// ╔═════════════════════╗
        /// ║ (or l0 l1 l2 .. ln) ║
        /// ╚═════════════════════╝
        /// </code>
        /// or
        /// <code>
        /// ╔═══════════════════════════╗
        /// ║ (=> (and l1 l2 .. ln) l0) ║
        /// ╚═══════════════════════════╝
        /// </code>
        /// or in the most general (ground) form:
        /// <code>
        /// ╔═══════════════════════════════════════════════╗
        /// ║ (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln)) ║
        /// ╚═══════════════════════════════════════════════╝
        /// </code>
        /// In other words we use the following (Prolog style) convention for Horn
        /// implications:
        /// The head of a Horn implication is position 0,
        /// the first conjunct in the body of an implication is position 1
        /// the second conjunct in the body of an implication is position 2
        /// </para>
        /// <para>
        /// For general implications where the head is a disjunction, the
        /// first n positions correspond to the n disjuncts in the head.
        /// The next m positions correspond to the m conjuncts in the body.
        /// </para>
        /// <para>
        /// The premises can be universally quantified so that the most
        /// general non-ground form is:
        /// </para>
        /// <para>
        /// <code>
        /// ╔═══════════════════════════════════════════════════════════════╗
        /// ║ (forall (vars) (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln))) ║
        /// ╚═══════════════════════════════════════════════════════════════╝
        /// </code>
        /// </para>
        /// <para>
        /// The hyper-resolution rule takes a sequence of parameters.
        /// The parameters are substitutions of bound variables separated by pairs
        /// of literal positions from the main clause and side clause.
        /// </para>
        /// </remarks>
        OpPrHyperResolve = 1321,

        /// <summary>
        /// Z3_OP_RA_STORE
        /// </summary>
        /// <remarks>
        /// Insert a record into a relation.
        /// The function takes n+1 arguments, where the first argument is the relation and the remaining n elements
        /// correspond to the n columns of the relation.
        /// </remarks>
        OpRaStore = 0x600,

        /// <summary>
        /// Z3_OP_RA_EMPTY
        /// </summary>
        /// <remarks>
        /// Creates the empty relation.
        /// </remarks>
        OpRaEmpty = 1537,

        /// <summary>
        /// Z3_OP_RA_IS_EMPTY
        /// </summary>
        /// <remarks>
        /// Tests if the relation is empty.
        /// </remarks>
        OpRaIsEmpty = 1538,

        /// <summary>
        /// Z3_OP_RA_JOIN
        /// </summary>
        /// <remarks>
        /// Create the relational join.
        /// </remarks>
        OpRaJoin = 1539,

        /// <summary>
        /// Z3_OP_RA_UNION
        /// </summary>
        /// <remarks>
        /// Create the union or convex hull of two relations.
        /// The function takes two arguments.
        /// </remarks>
        OpRaUnion = 1540,

        /// <summary>
        /// Z3_OP_RA_WIDEN
        /// </summary>
        /// <remarks>
        /// Widen two relations.
        /// The function takes two arguments.
        /// </remarks>
        OpRaWiden = 1541,

        /// <summary>
        /// Z3_OP_RA_PROJECT
        /// </summary>
        /// <remarks>
        /// Project the columns (provided as numbers in the parameters).
        /// The function takes one argument.
        /// </remarks>
        OpRaProject = 1542,

        /// <summary>
        /// Z3_OP_RA_FILTER
        /// </summary>
        /// <remarks>
        /// Filter (restrict) a relation with respect to a predicate.
        /// The first argument is a relation.
        /// The second argument is a predicate with free de-Bruijn indices
        /// corresponding to the columns of the relation.
        /// So the first column in the relation has index 0.
        /// </remarks>
        OpRaFilter = 1543,

        /// <summary>
        /// Z3_OP_RA_NEGATION_FILTER
        /// </summary>
        /// <remarks>
        /// <para>
        /// Intersect the first relation with respect to negation
        /// of the second relation (the function takes two arguments).
        /// Logically, the specification can be described by a function
        /// </para>
        /// <para>
        /// target = filter_by_negation(pos, neg, columns)
        /// </para>
        /// <para>
        /// where columns are pairs c1, d1, .., cN, dN of columns from pos and neg, such that
        /// target are elements in x in pos, such that there is no y in neg that agrees with
        /// x on the columns c1, d1, .., cN, dN.
        /// </para>
        /// </remarks>
        OpRaNegationFilter = 1544,

        /// <summary>
        /// Z3_OP_RA_RENAME
        /// </summary>
        /// <remarks>
        /// rename columns in the relation.
        /// The function takes one argument.
        /// The parameters contain the renaming as a cycle.
        /// </remarks>
        OpRaRename = 1545,

        /// <summary>
        /// Z3_OP_RA_COMPLEMENT
        /// </summary>
        /// <remarks>
        /// Complement the relation.
        /// </remarks>
        OpRaComplement = 1546,

        /// <summary>
        /// Z3_OP_RA_SELECT
        /// </summary>
        /// <remarks>
        /// Check if a record is an element of the relation.
        /// The function takes n+1 arguments, where the first argument is a relation,
        /// and the remaining n arguments correspond to a record.
        /// </remarks>
        OpRaSelect = 1547,

        /// <summary>
        /// Z3_OP_RA_CLONE
        /// </summary>
        /// <remarks>
        /// Create a fresh copy (clone) of a relation.
        /// The function is logically the identity, but
        /// in the context of a register machine allows
        /// for <see cref="OpRaUnion"/> to perform destructive updates to the first argument.
        /// </remarks>
        OpRaClone = 1548,

        /// <summary>Z3_OP_FD_CONSTANT</summary>
        OpFdConstant = 1549,

        /// <summary>
        /// Z3_OP_FD_LT
        /// </summary>
        /// <remarks>
        /// A less than predicate over the finite domain Z3_FINITE_DOMAIN_SORT.
        /// </remarks>
        OpFdLt = 1550,

        /// <summary>Z3_OP_SEQ_UNIT</summary>
        OpSeqUnit = 1551,

        /// <summary>Z3_OP_SEQ_EMPTY</summary>
        OpSeqEmpty = 1552,

        /// <summary>Z3_OP_SEQ_CONCAT</summary>
        OpSeqConcat = 1553,

        /// <summary>Z3_OP_SEQ_PREFIX</summary>
        OpSeqPrefix = 1554,

        /// <summary>Z3_OP_SEQ_SUFFIX</summary>
        OpSeqSuffix = 1555,

        /// <summary>Z3_OP_SEQ_CONTAINS</summary>
        OpSeqContains = 1556,

        /// <summary>Z3_OP_SEQ_EXTRACT</summary>
        OpSeqExtract = 1557,

        /// <summary>Z3_OP_SEQ_REPLACE</summary>
        OpSeqReplace = 1558,

        /// <summary>Z3_OP_SEQ_REPLACE_RE</summary>
        OpSeqReplaceRe = 1559,

        /// <summary>Z3_OP_SEQ_REPLACE_RE_ALL</summary>
        OpSeqReplaceReAll = 1560,

        /// <summary>Z3_OP_SEQ_REPLACE_ALL</summary>
        OpSeqReplaceAll = 1561,

        /// <summary>Z3_OP_SEQ_AT</summary>
        OpSeqAt = 1562,

        /// <summary>Z3_OP_SEQ_NTH</summary>
        OpSeqNth = 1563,

        /// <summary>Z3_OP_SEQ_LENGTH</summary>
        OpSeqLength = 1564,

        /// <summary>Z3_OP_SEQ_INDEX</summary>
        OpSeqIndex = 1565,

        /// <summary>Z3_OP_SEQ_LAST_INDEX</summary>
        OpSeqLastIndex = 1566,

        /// <summary>Z3_OP_SEQ_TO_RE</summary>
        OpSeqToRe = 1567,

        /// <summary>Z3_OP_SEQ_IN_RE</summary>
        OpSeqInRe = 1568,

        /// <summary>Z3_OP_SEQ_MAP</summary>
        OpSeqMap = 1569,

        /// <summary>Z3_OP_SEQ_MAPI</summary>
        OpSeqMapi = 1570,

        /// <summary>Z3_OP_SEQ_FOLDL</summary>
        OpSeqFoldl = 1571,

        /// <summary>Z3_OP_SEQ_FOLDLI</summary>
        OpSeqFoldli = 1572,

        /// <summary>Z3_OP_STR_TO_INT</summary>
        OpStrToInt = 1573,

        /// <summary>Z3_OP_INT_TO_STR</summary>
        OpIntToStr = 1574,

        /// <summary>Z3_OP_UBV_TO_STR</summary>
        OpUbvToStr = 1575,

        /// <summary>Z3_OP_SBV_TO_STR</summary>
        OpSbvToStr = 1576,

        /// <summary>Z3_OP_STR_TO_CODE</summary>
        OpStrToCode = 1577,

        /// <summary>Z3_OP_STR_FROM_CODE</summary>
        OpStrFromCode = 1578,

        /// <summary>Z3_OP_STRING_LT</summary>
        OpStringLt = 1579,

        /// <summary>Z3_OP_STRING_LE</summary>
        OpStringLe = 1580,

        /// <summary>Z3_OP_RE_PLUS</summary>
        OpRePlus = 1581,

        /// <summary>Z3_OP_RE_STAR</summary>
        OpReStar = 1582,

        /// <summary>Z3_OP_RE_OPTION</summary>
        OpReOption = 1583,

        /// <summary>Z3_OP_RE_CONCAT</summary>
        OpReConcat = 1584,

        /// <summary>Z3_OP_RE_UNION</summary>
        OpReUnion = 1585,

        /// <summary>Z3_OP_RE_RANGE</summary>
        OpReRange = 1586,

        /// <summary>Z3_OP_RE_DIFF</summary>
        OpReDiff = 1587,

        /// <summary>Z3_OP_RE_INTERSECT</summary>
        OpReIntersect = 1588,

        /// <summary>Z3_OP_RE_LOOP</summary>
        OpReLoop = 1589,

        /// <summary>Z3_OP_RE_POWER</summary>
        OpRePower = 1590,

        /// <summary>Z3_OP_RE_COMPLEMENT</summary>
        OpReComplement = 1591,

        /// <summary>Z3_OP_RE_EMPTY_SET</summary>
        OpReEmptySet = 1592,

        /// <summary>Z3_OP_RE_FULL_SET</summary>
        OpReFullSet = 1593,

        /// <summary>Z3_OP_RE_FULL_CHAR_SET</summary>
        OpReFullCharSet = 1594,

        /// <summary>Z3_OP_RE_OF_PRED</summary>
        OpReOfPred = 1595,

        /// <summary>Z3_OP_RE_REVERSE</summary>
        OpReReverse = 1596,

        /// <summary>Z3_OP_RE_DERIVATIVE</summary>
        OpReDerivative = 1597,

        /// <summary>Z3_OP_CHAR_CONST</summary>
        OpCharConst = 1598,

        /// <summary>Z3_OP_CHAR_LE</summary>
        OpCharLe = 1599,

        /// <summary>Z3_OP_CHAR_TO_INT</summary>
        OpCharToInt = 1600,

        /// <summary>Z3_OP_CHAR_TO_BV</summary>
        OpCharToBv = 1601,

        /// <summary>Z3_OP_CHAR_FROM_BV</summary>
        OpCharFromBv = 1602,

        /// <summary>Z3_OP_CHAR_IS_DIGIT</summary>
        OpCharIsDigit = 1603,

        /// <summary>
        /// Z3_OP_LABEL
        /// </summary>
        /// <remarks>
        /// A label (used by the Boogie Verification condition generator).
        /// The label has two parameters, a string and a Boolean polarity.
        /// It takes one argument, a formula.
        /// </remarks>
        OpLabel = 0x700,

        /// <summary>
        /// Z3_OP_LABEL_LIT
        /// </summary>
        /// <remarks>
        /// A label literal (used by the Boogie Verification condition generator).
        /// A label literal has a set of string parameters. It takes no arguments.
        /// </remarks>
        OpLabelLit = 1793,

        /// <summary>
        /// Z3_OP_DT_CONSTRUCTOR
        /// </summary>
        /// <remarks>
        /// datatype constructor.
        /// </remarks>
        OpDtConstructor = 0x800,

        /// <summary>
        /// Z3_OP_DT_RECOGNISER
        /// </summary>
        /// <remarks>
        /// datatype recognizer.
        /// </remarks>
        OpDtRecogniser = 2049,

        /// <summary>
        /// Z3_OP_DT_IS
        /// </summary>
        /// <remarks>
        /// datatype recognizer.
        /// </remarks>
        OpDtIs = 2050,

        /// <summary>
        /// Z3_OP_DT_ACCESSOR
        /// </summary>
        /// <remarks>
        /// datatype accessor.
        /// </remarks>
        OpDtAccessor = 2051,

        /// <summary>
        /// Z3_OP_DT_UPDATE_FIELD
        /// </summary>
        /// <remarks>
        /// datatype field update.
        /// </remarks>
        OpDtUpdateField = 2052,

        /// <summary>
        /// Z3_OP_PB_AT_MOST
        /// </summary>
        /// <remarks>
        /// Cardinality constraint.
        /// E.g., x + y + z &lt;= 2
        /// </remarks>
        OpPbAtMost = 0x900,

        /// <summary>
        /// Z3_OP_PB_AT_LEAST
        /// </summary>
        /// <remarks>
        /// Cardinality constraint.
        /// E.g., x + y + z &gt;= 2
        /// </remarks>
        OpPbAtLeast = 2305,

        /// <summary>
        /// Z3_OP_PB_LE
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean cardinality constraint.
        /// Example  2*x + 3*y &lt;= 4
        /// </remarks>
        OpPbLe = 2306,

        /// <summary>
        /// Z3_OP_PB_GE
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean cardinality constraint.
        /// Example  2*x + 3*y + 2*z &gt;= 4
        /// </remarks>
        OpPbGe = 2307,

        /// <summary>
        /// Z3_OP_PB_EQ
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean equality constraint.
        /// Example  2*x + 1*y + 2*z + 1*u = 4
        /// </remarks>
        OpPbEq = 2308,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_LO
        /// </summary>
        /// <remarks>
        /// A relation that is a total linear order
        /// </remarks>
        OpSpecialRelationLo = 0xa000,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_PO
        /// </summary>
        /// <remarks>
        /// A relation that is a partial order
        /// </remarks>
        OpSpecialRelationPo = 40961,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_PLO
        /// </summary>
        /// <remarks>
        /// A relation that is a piecewise linear order
        /// </remarks>
        OpSpecialRelationPlo = 40962,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TO
        /// </summary>
        /// <remarks>
        /// A relation that is a tree order
        /// </remarks>
        OpSpecialRelationTo = 40963,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TC
        /// </summary>
        /// <remarks>
        /// Transitive closure of a relation
        /// </remarks>
        OpSpecialRelationTc = 40964,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TRC
        /// </summary>
        /// <remarks>
        /// Transitive reflexive closure of a relation
        /// </remarks>
        OpSpecialRelationTrc = 40965,

        /// <summary>
        /// Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RNE
        /// </remarks>
        OpFpaRmNearestTiesToEven = 0xb000,

        /// <summary>
        /// Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RNA
        /// </remarks>
        OpFpaRmNearestTiesToAway = 45057,

        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_POSITIVE
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTP
        /// </remarks>
        OpFpaRmTowardPositive = 45058,

        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_NEGATIVE
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTN
        /// </remarks>
        OpFpaRmTowardNegative = 45059,

        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTZ
        /// </remarks>
        OpFpaRmTowardZero = 45060,

        /// <summary>
        /// Z3_OP_FPA_NUM
        /// </summary>
        /// <remarks>
        /// Floating-point value
        /// </remarks>
        OpFpaNum = 45061,

        /// <summary>
        /// Z3_OP_FPA_PLUS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point +oo
        /// </remarks>
        OpFpaPlusInf = 45062,

        /// <summary>
        /// Z3_OP_FPA_MINUS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point -oo
        /// </remarks>
        OpFpaMinusInf = 45063,

        /// <summary>
        /// Z3_OP_FPA_NAN
        /// </summary>
        /// <remarks>
        /// Floating-point NaN
        /// </remarks>
        OpFpaNan = 45064,

        /// <summary>
        /// Z3_OP_FPA_PLUS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point +zero
        /// </remarks>
        OpFpaPlusZero = 45065,

        /// <summary>
        /// Z3_OP_FPA_MINUS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point -zero
        /// </remarks>
        OpFpaMinusZero = 45066,

        /// <summary>
        /// Z3_OP_FPA_ADD
        /// </summary>
        /// <remarks>
        /// Floating-point addition
        /// </remarks>
        OpFpaAdd = 45067,

        /// <summary>
        /// Z3_OP_FPA_SUB
        /// </summary>
        /// <remarks>
        /// Floating-point subtraction
        /// </remarks>
        OpFpaSub = 45068,

        /// <summary>
        /// Z3_OP_FPA_NEG
        /// </summary>
        /// <remarks>
        /// Floating-point negation
        /// </remarks>
        OpFpaNeg = 45069,

        /// <summary>
        /// Z3_OP_FPA_MUL
        /// </summary>
        /// <remarks>
        /// Floating-point multiplication
        /// </remarks>
        OpFpaMul = 45070,

        /// <summary>
        /// Z3_OP_FPA_DIV
        /// </summary>
        /// <remarks>
        /// Floating-point division
        /// </remarks>
        OpFpaDiv = 45071,

        /// <summary>
        /// Z3_OP_FPA_REM
        /// </summary>
        /// <remarks>
        /// Floating-point remainder
        /// </remarks>
        OpFpaRem = 45072,

        /// <summary>
        /// Z3_OP_FPA_ABS
        /// </summary>
        /// <remarks>
        /// Floating-point absolute value
        /// </remarks>
        OpFpaAbs = 45073,

        /// <summary>
        /// Z3_OP_FPA_MIN
        /// </summary>
        /// <remarks>
        /// Floating-point minimum
        /// </remarks>
        OpFpaMin = 45074,

        /// <summary>
        /// Z3_OP_FPA_MAX
        /// </summary>
        /// <remarks>
        /// Floating-point maximum
        /// </remarks>
        OpFpaMax = 45075,

        /// <summary>
        /// Z3_OP_FPA_FMA
        /// </summary>
        /// <remarks>
        /// Floating-point fused multiply-add
        /// </remarks>
        OpFpaFma = 45076,

        /// <summary>
        /// Z3_OP_FPA_SQRT
        /// </summary>
        /// <remarks>
        /// Floating-point square root
        /// </remarks>
        OpFpaSqrt = 45077,

        /// <summary>
        /// Z3_OP_FPA_ROUND_TO_INTEGRAL
        /// </summary>
        /// <remarks>
        /// Floating-point round to integral
        /// </remarks>
        OpFpaRoundToIntegral = 45078,

        /// <summary>
        /// Z3_OP_FPA_EQ
        /// </summary>
        /// <remarks>
        /// Floating-point equality
        /// </remarks>
        OpFpaEq = 45079,

        /// <summary>
        /// Z3_OP_FPA_LT
        /// </summary>
        /// <remarks>
        /// Floating-point less than
        /// </remarks>
        OpFpaLt = 45080,

        /// <summary>
        /// Z3_OP_FPA_GT
        /// </summary>
        /// <remarks>
        /// Floating-point greater than
        /// </remarks>
        OpFpaGt = 45081,

        /// <summary>
        /// Z3_OP_FPA_LE
        /// </summary>
        /// <remarks>
        /// Floating-point less than or equal
        /// </remarks>
        OpFpaLe = 45082,

        /// <summary>
        /// Z3_OP_FPA_GE
        /// </summary>
        /// <remarks>
        /// Floating-point greater than or equal
        /// </remarks>
        OpFpaGe = 45083,

        /// <summary>
        /// Z3_OP_FPA_IS_NAN
        /// </summary>
        /// <remarks>
        /// Floating-point isNaN
        /// </remarks>
        OpFpaIsNan = 45084,

        /// <summary>
        /// Z3_OP_FPA_IS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point isInfinite
        /// </remarks>
        OpFpaIsInf = 45085,

        /// <summary>
        /// Z3_OP_FPA_IS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point isZero
        /// </remarks>
        OpFpaIsZero = 45086,

        /// <summary>
        /// Z3_OP_FPA_IS_NORMAL
        /// </summary>
        /// <remarks>
        /// Floating-point isNormal
        /// </remarks>
        OpFpaIsNormal = 45087,

        /// <summary>
        /// Z3_OP_FPA_IS_SUBNORMAL
        /// </summary>
        /// <remarks>
        /// Floating-point isSubnormal
        /// </remarks>
        OpFpaIsSubnormal = 45088,

        /// <summary>
        /// Z3_OP_FPA_IS_NEGATIVE
        /// </summary>
        /// <remarks>
        /// Floating-point isNegative
        /// </remarks>
        OpFpaIsNegative = 45089,

        /// <summary>
        /// Z3_OP_FPA_IS_POSITIVE
        /// </summary>
        /// <remarks>
        /// Floating-point isPositive
        /// </remarks>
        OpFpaIsPositive = 45090,

        /// <summary>
        /// Z3_OP_FPA_FP
        /// </summary>
        /// <remarks>
        /// Floating-point constructor from 3 bit-vectors
        /// </remarks>
        OpFpaFp = 45091,

        /// <summary>
        /// Z3_OP_FPA_TO_FP
        /// </summary>
        /// <remarks>
        /// Floating-point conversion (various)
        /// </remarks>
        OpFpaToFp = 45092,

        /// <summary>
        /// Z3_OP_FPA_TO_FP_UNSIGNED
        /// </summary>
        /// <remarks>
        /// Floating-point conversion from unsigned bit-vector
        /// </remarks>
        OpFpaToFpUnsigned = 45093,

        /// <summary>
        /// Z3_OP_FPA_TO_UBV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to unsigned bit-vector
        /// </remarks>
        OpFpaToUbv = 45094,

        /// <summary>
        /// Z3_OP_FPA_TO_SBV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to signed bit-vector
        /// </remarks>
        OpFpaToSbv = 45095,

        /// <summary>
        /// Z3_OP_FPA_TO_REAL
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to real number
        /// </remarks>
        OpFpaToReal = 45096,

        /// <summary>
        /// Z3_OP_FPA_TO_IEEE_BV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to IEEE-754 bit-vector
        /// </remarks>
        OpFpaToIeeeBv = 45097,

        /// <summary>
        /// Z3_OP_FPA_BVWRAP
        /// </summary>
        /// <remarks>
        /// (Implicitly) represents the internal bitvector-
        /// representation of a floating-point term (used for the lazy encoding
        /// of non-relevant terms in theory_fpa)
        /// </remarks>
        OpFpaBvwrap = 45098,

        /// <summary>
        /// Z3_OP_FPA_BV2RM
        /// </summary>
        /// <remarks>
        /// <para>
        /// Conversion of a 3-bit bit-vector term to a
        /// floating-point rounding-mode term
        /// </para>
        /// <para>
        /// The conversion uses the following values:
        /// 0 = 000 = Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN,
        /// 1 = 001 = Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY,
        /// 2 = 010 = Z3_OP_FPA_RM_TOWARD_POSITIVE,
        /// 3 = 011 = Z3_OP_FPA_RM_TOWARD_NEGATIVE,
        /// 4 = 100 = Z3_OP_FPA_RM_TOWARD_ZERO.
        /// </para>
        /// </remarks>
        OpFpaBv2rm = 45099,

        /// <summary>
        /// Z3_OP_INTERNAL
        /// </summary>
        /// <remarks>
        /// internal (often interpreted) symbol, but no additional
        /// information is exposed. Tools may use the string representation of the
        /// function declaration to obtain more information.
        /// </remarks>
        OpInternal = 45100,

        /// <summary>
        /// Z3_OP_RECURSIVE
        /// </summary>
        /// <remarks>
        /// function declared as recursive
        /// </remarks>
        OpRecursive = 45101,

        /// <summary>Z3_OP_UNINTERPRETED</summary>
        OpUninterpreted = 45102,
    }

    /// <summary>
    /// Z3 error codes (See <see cref="GetErrorCode"/>).
    /// </summary>
    public enum ErrorCode
    {
        /// <summary>
        /// Z3_OK
        /// </summary>
        /// <remarks>
        /// No error.
        /// </remarks>
        Ok = 0,

        /// <summary>
        /// Z3_SORT_ERROR
        /// </summary>
        /// <remarks>
        /// User tried to build an invalid (type incorrect) AST.
        /// </remarks>
        SortError = 1,

        /// <summary>
        /// Z3_IOB
        /// </summary>
        /// <remarks>
        /// Index out of bounds.
        /// </remarks>
        Iob = 2,

        /// <summary>
        /// Z3_INVALID_ARG
        /// </summary>
        /// <remarks>
        /// Invalid argument was provided.
        /// </remarks>
        InvalidArg = 3,

        /// <summary>
        /// Z3_PARSER_ERROR
        /// </summary>
        /// <remarks>
        /// An error occurred when parsing a string or file.
        /// </remarks>
        ParserError = 4,

        /// <summary>
        /// Z3_NO_PARSER
        /// </summary>
        /// <remarks>
        /// Parser output is not available, that is, user didn't invoke <see cref="ParseSmtlib2String"/> or <see cref="ParseSmtlib2File"/>.
        /// </remarks>
        NoParser = 5,

        /// <summary>
        /// Z3_INVALID_PATTERN
        /// </summary>
        /// <remarks>
        /// Invalid pattern was used to build a quantifier.
        /// </remarks>
        InvalidPattern = 6,

        /// <summary>
        /// Z3_MEMOUT_FAIL
        /// </summary>
        /// <remarks>
        /// A memory allocation failure was encountered.
        /// </remarks>
        MemoutFail = 7,

        /// <summary>
        /// Z3_FILE_ACCESS_ERROR
        /// </summary>
        /// <remarks>
        /// A file could not be accessed.
        /// </remarks>
        FileAccessError = 8,

        /// <summary>
        /// Z3_INTERNAL_FATAL
        /// </summary>
        /// <remarks>
        /// An error internal to Z3 occurred.
        /// </remarks>
        InternalFatal = 9,

        /// <summary>
        /// Z3_INVALID_USAGE
        /// </summary>
        /// <remarks>
        /// API call is invalid in the current state.
        /// </remarks>
        InvalidUsage = 10,

        /// <summary>
        /// Z3_DEC_REF_ERROR
        /// </summary>
        /// <remarks>
        /// Trying to decrement the reference counter of an AST that was deleted or the reference counter was not initialized with <see cref="IncRef"/>.
        /// </remarks>
        DecRefError = 11,

        /// <summary>Z3_EXCEPTION</summary>
        Exception = 12,
    }

    /// <summary>
    /// A Goal is essentially a set of formulas.
    /// Z3 provide APIs for building strategies/tactics for solving and transforming Goals.
    /// Some of these transformations apply under/over approximations.
    /// </summary>
    public enum GoalPrec
    {
        /// <summary>
        /// Z3_GOAL_PRECISE
        /// </summary>
        /// <remarks>
        /// Approximations/Relaxations were not applied on the goal (sat and unsat answers were preserved).
        /// </remarks>
        GoalPrecise = 0,

        /// <summary>
        /// Z3_GOAL_UNDER
        /// </summary>
        /// <remarks>
        /// Goal is the product of a under-approximation (sat answers are preserved).
        /// </remarks>
        GoalUnder = 1,

        /// <summary>
        /// Z3_GOAL_OVER
        /// </summary>
        /// <remarks>
        /// Goal is the product of an over-approximation (unsat answers are preserved).
        /// </remarks>
        GoalOver = 2,

        /// <summary>Z3_GOAL_UNDER_OVER</summary>
        GoalUnderOver = 3,
    }

    /// <summary>
    /// Lifted Boolean type: false, undefined, true.
    /// </summary>
    public enum Lbool
    {
        /// <summary>Z3_L_FALSE</summary>
        False = -1,

        /// <summary>Z3_L_UNDEF</summary>
        Undef = 0,

        /// <summary>Z3_L_TRUE</summary>
        True = 1,
    }

    /// <summary>
    /// The different kinds of parameters that can be associated with parameter sets.
    /// (see <see cref="MkParams"/>).
    /// </summary>
    public enum ParamKind
    {
        /// <summary>
        /// Z3_PK_UINT
        /// </summary>
        /// <remarks>
        /// integer parameters.
        /// </remarks>
        Uint = 0,

        /// <summary>
        /// Z3_PK_BOOL
        /// </summary>
        /// <remarks>
        /// boolean parameters.
        /// </remarks>
        Bool = 1,

        /// <summary>
        /// Z3_PK_DOUBLE
        /// </summary>
        /// <remarks>
        /// double parameters.
        /// </remarks>
        Double = 2,

        /// <summary>
        /// Z3_PK_SYMBOL
        /// </summary>
        /// <remarks>
        /// symbol parameters.
        /// </remarks>
        Symbol = 3,

        /// <summary>
        /// Z3_PK_STRING
        /// </summary>
        /// <remarks>
        /// string parameters.
        /// </remarks>
        String = 4,

        /// <summary>
        /// Z3_PK_OTHER
        /// </summary>
        /// <remarks>
        /// all internal parameter kinds which are not exposed in the API.
        /// </remarks>
        Other = 5,

        /// <summary>Z3_PK_INVALID</summary>
        Invalid = 6,
    }

    /// <summary>
    /// The different kinds of parameters that can be associated with function symbols.
    /// </summary>
    /// <seealso cref="GetDeclNumParameters"/>
    /// <seealso cref="GetDeclParameterKind"/>
    public enum ParameterKind
    {
        /// <summary>
        /// Z3_PARAMETER_INT
        /// </summary>
        /// <remarks>
        /// is used for integer parameters.
        /// </remarks>
        ParameterInt = 0,

        /// <summary>
        /// Z3_PARAMETER_DOUBLE
        /// </summary>
        /// <remarks>
        /// is used for double parameters.
        /// </remarks>
        ParameterDouble = 1,

        /// <summary>
        /// Z3_PARAMETER_RATIONAL
        /// </summary>
        /// <remarks>
        /// is used for parameters that are rational numbers.
        /// </remarks>
        ParameterRational = 2,

        /// <summary>
        /// Z3_PARAMETER_SYMBOL
        /// </summary>
        /// <remarks>
        /// is used for parameters that are symbols.
        /// </remarks>
        ParameterSymbol = 3,

        /// <summary>
        /// Z3_PARAMETER_SORT
        /// </summary>
        /// <remarks>
        /// is used for sort parameters.
        /// </remarks>
        ParameterSort = 4,

        /// <summary>
        /// Z3_PARAMETER_AST
        /// </summary>
        /// <remarks>
        /// is used for expression parameters.
        /// </remarks>
        ParameterAst = 5,

        /// <summary>
        /// Z3_PARAMETER_FUNC_DECL
        /// </summary>
        /// <remarks>
        /// is used for function declaration parameters.
        /// </remarks>
        ParameterFuncDecl = 6,

        /// <summary>
        /// Z3_PARAMETER_INTERNAL
        /// </summary>
        /// <remarks>
        /// is used for parameters that are private to Z3. They cannot be accessed.
        /// </remarks>
        ParameterInternal = 7,

        /// <summary>Z3_PARAMETER_ZSTRING</summary>
        ParameterZstring = 8,
    }

    /// <summary>
    /// The different kinds of Z3 types (See <see cref="GetSortKind"/>).
    /// </summary>
    public enum SortKind
    {
        /// <summary>Z3_UNINTERPRETED_SORT</summary>
        UninterpretedSort = 0,

        /// <summary>Z3_BOOL_SORT</summary>
        BoolSort = 1,

        /// <summary>Z3_INT_SORT</summary>
        IntSort = 2,

        /// <summary>Z3_REAL_SORT</summary>
        RealSort = 3,

        /// <summary>Z3_BV_SORT</summary>
        BvSort = 4,

        /// <summary>Z3_ARRAY_SORT</summary>
        ArraySort = 5,

        /// <summary>Z3_DATATYPE_SORT</summary>
        DatatypeSort = 6,

        /// <summary>Z3_RELATION_SORT</summary>
        RelationSort = 7,

        /// <summary>Z3_FINITE_DOMAIN_SORT</summary>
        FiniteDomainSort = 8,

        /// <summary>Z3_FLOATING_POINT_SORT</summary>
        FloatingPointSort = 9,

        /// <summary>Z3_ROUNDING_MODE_SORT</summary>
        RoundingModeSort = 10,

        /// <summary>Z3_SEQ_SORT</summary>
        SeqSort = 11,

        /// <summary>Z3_RE_SORT</summary>
        ReSort = 12,

        /// <summary>Z3_CHAR_SORT</summary>
        CharSort = 13,

        /// <summary>Z3_TYPE_VAR</summary>
        TypeVar = 14,

        /// <summary>Z3_UNKNOWN_SORT</summary>
        UnknownSort = 1000,
    }

    /// <summary>
    /// The different kinds of symbol.
    /// In Z3, a symbol can be represented using integers and strings (See <see cref="GetSymbolKind"/>).
    /// </summary>
    /// <seealso cref="MkIntSymbol"/>
    /// <seealso cref="MkStringSymbol"/>
    public enum SymbolKind
    {
        /// <summary>Z3_INT_SYMBOL</summary>
        IntSymbol = 0,

        /// <summary>Z3_STRING_SYMBOL</summary>
        StringSymbol = 1,
    }
}
