// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Enums.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// The different kinds of Z3 AST (abstract syntax trees). That is, terms, formulas and types.
    /// </summary>
    public enum AstKind
    {
        /// <summary>
        /// Z3_NUMERAL_AST
        /// </summary>
        /// <remarks>
        /// numeral constants
        /// </remarks>
        Z3_NUMERAL_AST = 0,

        /// <summary>
        /// Z3_APP_AST
        /// </summary>
        /// <remarks>
        /// constant and applications
        /// </remarks>
        Z3_APP_AST = 1,

        /// <summary>
        /// Z3_VAR_AST
        /// </summary>
        /// <remarks>
        /// bound variables
        /// </remarks>
        Z3_VAR_AST = 2,

        /// <summary>
        /// Z3_QUANTIFIER_AST
        /// </summary>
        /// <remarks>
        /// quantifiers
        /// </remarks>
        Z3_QUANTIFIER_AST = 3,

        /// <summary>
        /// Z3_SORT_AST
        /// </summary>
        /// <remarks>
        /// sort
        /// </remarks>
        Z3_SORT_AST = 4,

        /// <summary>
        /// Z3_FUNC_DECL_AST
        /// </summary>
        /// <remarks>
        /// function declaration
        /// </remarks>
        Z3_FUNC_DECL_AST = 5,

        /// <summary>Z3_UNKNOWN_AST</summary>
        Z3_UNKNOWN_AST = 1000,
    }

    /// <summary>
    /// Z3 pretty printing modes (See <see cref="SetAstPrintMode"/>).
    /// </summary>
    public enum AstPrintMode
    {
        /// <summary>
        /// Z3_PRINT_SMTLIB_FULL
        /// </summary>
        /// <remarks>
        /// Print AST nodes in SMTLIB verbose format.
        /// </remarks>
        Z3_PRINT_SMTLIB_FULL = 0,

        /// <summary>
        /// Z3_PRINT_LOW_LEVEL
        /// </summary>
        /// <remarks>
        /// Print AST nodes using a low-level format.
        /// </remarks>
        Z3_PRINT_LOW_LEVEL = 1,

        /// <summary>Z3_PRINT_SMTLIB2_COMPLIANT</summary>
        Z3_PRINT_SMTLIB2_COMPLIANT = 2,
    }

    /// <summary>
    /// The different kinds of interpreted function kinds.
    /// </summary>
    /// <seealso cref="MkBvmulNoOverflow"/>
    /// <seealso cref="MkBvmulNoOverflow"/>
    public enum DeclKind
    {
        /// <summary>
        /// Z3_OP_TRUE
        /// </summary>
        /// <remarks>
        /// The constant true.
        /// </remarks>
        Z3_OP_TRUE = 0x100,

        /// <summary>
        /// Z3_OP_FALSE
        /// </summary>
        /// <remarks>
        /// The constant false.
        /// </remarks>
        Z3_OP_FALSE = 257,

        /// <summary>
        /// Z3_OP_EQ
        /// </summary>
        /// <remarks>
        /// The equality predicate.
        /// </remarks>
        Z3_OP_EQ = 258,

        /// <summary>
        /// Z3_OP_DISTINCT
        /// </summary>
        /// <remarks>
        /// The n-ary distinct predicate (every argument is mutually distinct).
        /// </remarks>
        Z3_OP_DISTINCT = 259,

        /// <summary>
        /// Z3_OP_ITE
        /// </summary>
        /// <remarks>
        /// The ternary if-then-else term.
        /// </remarks>
        Z3_OP_ITE = 260,

        /// <summary>
        /// Z3_OP_AND
        /// </summary>
        /// <remarks>
        /// n-ary conjunction.
        /// </remarks>
        Z3_OP_AND = 261,

        /// <summary>
        /// Z3_OP_OR
        /// </summary>
        /// <remarks>
        /// n-ary disjunction.
        /// </remarks>
        Z3_OP_OR = 262,

        /// <summary>
        /// Z3_OP_IFF
        /// </summary>
        /// <remarks>
        /// equivalence (binary).
        /// </remarks>
        Z3_OP_IFF = 263,

        /// <summary>
        /// Z3_OP_XOR
        /// </summary>
        /// <remarks>
        /// Exclusive or.
        /// </remarks>
        Z3_OP_XOR = 264,

        /// <summary>
        /// Z3_OP_NOT
        /// </summary>
        /// <remarks>
        /// Negation.
        /// </remarks>
        Z3_OP_NOT = 265,

        /// <summary>
        /// Z3_OP_IMPLIES
        /// </summary>
        /// <remarks>
        /// Implication.
        /// </remarks>
        Z3_OP_IMPLIES = 266,

        /// <summary>
        /// Z3_OP_OEQ
        /// </summary>
        /// <remarks>
        /// Binary equivalence modulo namings. This binary predicate is used in proof terms.
        /// It captures equisatisfiability and equivalence modulo renamings.
        /// </remarks>
        Z3_OP_OEQ = 267,

        /// <summary>
        /// Z3_OP_ANUM
        /// </summary>
        /// <remarks>
        /// Arithmetic numeral.
        /// </remarks>
        Z3_OP_ANUM = 0x200,

        /// <summary>
        /// Z3_OP_AGNUM
        /// </summary>
        /// <remarks>
        /// Arithmetic algebraic numeral. Algebraic numbers are used to represent irrational numbers in Z3.
        /// </remarks>
        Z3_OP_AGNUM = 513,

        /// <summary>
        /// Z3_OP_LE
        /// </summary>
        /// <remarks>
        /// &lt;=.
        /// </remarks>
        Z3_OP_LE = 514,

        /// <summary>
        /// Z3_OP_GE
        /// </summary>
        /// <remarks>
        /// &gt;=.
        /// </remarks>
        Z3_OP_GE = 515,

        /// <summary>
        /// Z3_OP_LT
        /// </summary>
        /// <remarks>
        /// &lt;.
        /// </remarks>
        Z3_OP_LT = 516,

        /// <summary>
        /// Z3_OP_GT
        /// </summary>
        /// <remarks>
        /// &gt;.
        /// </remarks>
        Z3_OP_GT = 517,

        /// <summary>
        /// Z3_OP_ADD
        /// </summary>
        /// <remarks>
        /// Addition - Binary.
        /// </remarks>
        Z3_OP_ADD = 518,

        /// <summary>
        /// Z3_OP_SUB
        /// </summary>
        /// <remarks>
        /// Binary subtraction.
        /// </remarks>
        Z3_OP_SUB = 519,

        /// <summary>
        /// Z3_OP_UMINUS
        /// </summary>
        /// <remarks>
        /// Unary minus.
        /// </remarks>
        Z3_OP_UMINUS = 520,

        /// <summary>
        /// Z3_OP_MUL
        /// </summary>
        /// <remarks>
        /// Multiplication - Binary.
        /// </remarks>
        Z3_OP_MUL = 521,

        /// <summary>
        /// Z3_OP_DIV
        /// </summary>
        /// <remarks>
        /// Division - Binary.
        /// </remarks>
        Z3_OP_DIV = 522,

        /// <summary>
        /// Z3_OP_IDIV
        /// </summary>
        /// <remarks>
        /// Integer division - Binary.
        /// </remarks>
        Z3_OP_IDIV = 523,

        /// <summary>
        /// Z3_OP_REM
        /// </summary>
        /// <remarks>
        /// Remainder - Binary.
        /// </remarks>
        Z3_OP_REM = 524,

        /// <summary>
        /// Z3_OP_MOD
        /// </summary>
        /// <remarks>
        /// Modulus - Binary.
        /// </remarks>
        Z3_OP_MOD = 525,

        /// <summary>
        /// Z3_OP_TO_REAL
        /// </summary>
        /// <remarks>
        /// Coercion of integer to real - Unary.
        /// </remarks>
        Z3_OP_TO_REAL = 526,

        /// <summary>
        /// Z3_OP_TO_INT
        /// </summary>
        /// <remarks>
        /// Coercion of real to integer - Unary.
        /// </remarks>
        Z3_OP_TO_INT = 527,

        /// <summary>
        /// Z3_OP_IS_INT
        /// </summary>
        /// <remarks>
        /// Check if real is also an integer - Unary.
        /// </remarks>
        Z3_OP_IS_INT = 528,

        /// <summary>
        /// Z3_OP_POWER
        /// </summary>
        /// <remarks>
        /// Power operator x^y.
        /// </remarks>
        Z3_OP_POWER = 529,

        /// <summary>Z3_OP_ABS</summary>
        Z3_OP_ABS = 530,

        /// <summary>
        /// Z3_OP_STORE
        /// </summary>
        /// <remarks>
        /// Array store. It satisfies select(store(a,i,v),j) = if i = j then v else select(a,j).
        /// Array store takes at least 3 arguments.
        /// </remarks>
        Z3_OP_STORE = 0x300,

        /// <summary>
        /// Z3_OP_SELECT
        /// </summary>
        /// <remarks>
        /// Array select.
        /// </remarks>
        Z3_OP_SELECT = 769,

        /// <summary>
        /// Z3_OP_CONST_ARRAY
        /// </summary>
        /// <remarks>
        /// The constant array. For example, select(const(v),i) = v holds for every v and i. The function is unary.
        /// </remarks>
        Z3_OP_CONST_ARRAY = 770,

        /// <summary>
        /// Z3_OP_ARRAY_MAP
        /// </summary>
        /// <remarks>
        /// Array map operator.
        /// It satisfies map[f](a1,..,a_n)[i] = f(a1[i],...,a_n[i]) for every i.
        /// </remarks>
        Z3_OP_ARRAY_MAP = 771,

        /// <summary>
        /// Z3_OP_ARRAY_DEFAULT
        /// </summary>
        /// <remarks>
        /// Default value of arrays. For example default(const(v)) = v. The function is unary.
        /// </remarks>
        Z3_OP_ARRAY_DEFAULT = 772,

        /// <summary>
        /// Z3_OP_SET_UNION
        /// </summary>
        /// <remarks>
        /// Set union between two Boolean arrays (two arrays whose range type is Boolean). The function is binary.
        /// </remarks>
        Z3_OP_SET_UNION = 773,

        /// <summary>
        /// Z3_OP_SET_INTERSECT
        /// </summary>
        /// <remarks>
        /// Set intersection between two Boolean arrays. The function is binary.
        /// </remarks>
        Z3_OP_SET_INTERSECT = 774,

        /// <summary>
        /// Z3_OP_SET_DIFFERENCE
        /// </summary>
        /// <remarks>
        /// Set difference between two Boolean arrays. The function is binary.
        /// </remarks>
        Z3_OP_SET_DIFFERENCE = 775,

        /// <summary>
        /// Z3_OP_SET_COMPLEMENT
        /// </summary>
        /// <remarks>
        /// Set complement of a Boolean array. The function is unary.
        /// </remarks>
        Z3_OP_SET_COMPLEMENT = 776,

        /// <summary>
        /// Z3_OP_SET_SUBSET
        /// </summary>
        /// <remarks>
        /// Subset predicate between two Boolean arrays. The relation is binary.
        /// </remarks>
        Z3_OP_SET_SUBSET = 777,

        /// <summary>
        /// Z3_OP_AS_ARRAY
        /// </summary>
        /// <remarks>
        /// An array value that behaves as the function graph of the
        /// function passed as parameter.
        /// </remarks>
        Z3_OP_AS_ARRAY = 778,

        /// <summary>
        /// Z3_OP_ARRAY_EXT
        /// </summary>
        /// <remarks>
        /// Array extensionality function. It takes two arrays as arguments and produces an index, such that the arrays
        /// are different if they are different on the index.
        /// </remarks>
        Z3_OP_ARRAY_EXT = 779,

        /// <summary>Z3_OP_SET_HAS_SIZE</summary>
        Z3_OP_SET_HAS_SIZE = 780,

        /// <summary>Z3_OP_SET_CARD</summary>
        Z3_OP_SET_CARD = 781,

        /// <summary>
        /// Z3_OP_BNUM
        /// </summary>
        /// <remarks>
        /// Bit-vector numeral.
        /// </remarks>
        Z3_OP_BNUM = 0x400,

        /// <summary>
        /// Z3_OP_BIT1
        /// </summary>
        /// <remarks>
        /// One bit bit-vector.
        /// </remarks>
        Z3_OP_BIT1 = 1025,

        /// <summary>
        /// Z3_OP_BIT0
        /// </summary>
        /// <remarks>
        /// Zero bit bit-vector.
        /// </remarks>
        Z3_OP_BIT0 = 1026,

        /// <summary>
        /// Z3_OP_BNEG
        /// </summary>
        /// <remarks>
        /// Unary minus.
        /// </remarks>
        Z3_OP_BNEG = 1027,

        /// <summary>
        /// Z3_OP_BADD
        /// </summary>
        /// <remarks>
        /// Binary addition.
        /// </remarks>
        Z3_OP_BADD = 1028,

        /// <summary>
        /// Z3_OP_BSUB
        /// </summary>
        /// <remarks>
        /// Binary subtraction.
        /// </remarks>
        Z3_OP_BSUB = 1029,

        /// <summary>
        /// Z3_OP_BMUL
        /// </summary>
        /// <remarks>
        /// Binary multiplication.
        /// </remarks>
        Z3_OP_BMUL = 1030,

        /// <summary>
        /// Z3_OP_BSDIV
        /// </summary>
        /// <remarks>
        /// Binary signed division.
        /// </remarks>
        Z3_OP_BSDIV = 1031,

        /// <summary>
        /// Z3_OP_BUDIV
        /// </summary>
        /// <remarks>
        /// Binary unsigned division.
        /// </remarks>
        Z3_OP_BUDIV = 1032,

        /// <summary>
        /// Z3_OP_BSREM
        /// </summary>
        /// <remarks>
        /// Binary signed remainder.
        /// </remarks>
        Z3_OP_BSREM = 1033,

        /// <summary>
        /// Z3_OP_BUREM
        /// </summary>
        /// <remarks>
        /// Binary unsigned remainder.
        /// </remarks>
        Z3_OP_BUREM = 1034,

        /// <summary>
        /// Z3_OP_BSMOD
        /// </summary>
        /// <remarks>
        /// Binary signed modulus.
        /// </remarks>
        Z3_OP_BSMOD = 1035,

        /// <summary>
        /// Z3_OP_BSDIV0
        /// </summary>
        /// <remarks>
        /// Unary function. bsdiv(x,0) is congruent to bsdiv0(x).
        /// </remarks>
        Z3_OP_BSDIV0 = 1036,

        /// <summary>
        /// Z3_OP_BUDIV0
        /// </summary>
        /// <remarks>
        /// Unary function. budiv(x,0) is congruent to budiv0(x).
        /// </remarks>
        Z3_OP_BUDIV0 = 1037,

        /// <summary>
        /// Z3_OP_BSREM0
        /// </summary>
        /// <remarks>
        /// Unary function. bsrem(x,0) is congruent to bsrem0(x).
        /// </remarks>
        Z3_OP_BSREM0 = 1038,

        /// <summary>
        /// Z3_OP_BUREM0
        /// </summary>
        /// <remarks>
        /// Unary function. burem(x,0) is congruent to burem0(x).
        /// </remarks>
        Z3_OP_BUREM0 = 1039,

        /// <summary>
        /// Z3_OP_BSMOD0
        /// </summary>
        /// <remarks>
        /// Unary function. bsmod(x,0) is congruent to bsmod0(x).
        /// </remarks>
        Z3_OP_BSMOD0 = 1040,

        /// <summary>
        /// Z3_OP_ULEQ
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector &lt;= - Binary relation.
        /// </remarks>
        Z3_OP_ULEQ = 1041,

        /// <summary>
        /// Z3_OP_SLEQ
        /// </summary>
        /// <remarks>
        /// Signed bit-vector  &lt;= - Binary relation.
        /// </remarks>
        Z3_OP_SLEQ = 1042,

        /// <summary>
        /// Z3_OP_UGEQ
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector  &gt;= - Binary relation.
        /// </remarks>
        Z3_OP_UGEQ = 1043,

        /// <summary>
        /// Z3_OP_SGEQ
        /// </summary>
        /// <remarks>
        /// Signed bit-vector  &gt;= - Binary relation.
        /// </remarks>
        Z3_OP_SGEQ = 1044,

        /// <summary>
        /// Z3_OP_ULT
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector  &lt; - Binary relation.
        /// </remarks>
        Z3_OP_ULT = 1045,

        /// <summary>
        /// Z3_OP_SLT
        /// </summary>
        /// <remarks>
        /// Signed bit-vector &lt; - Binary relation.
        /// </remarks>
        Z3_OP_SLT = 1046,

        /// <summary>
        /// Z3_OP_UGT
        /// </summary>
        /// <remarks>
        /// Unsigned bit-vector &gt; - Binary relation.
        /// </remarks>
        Z3_OP_UGT = 1047,

        /// <summary>
        /// Z3_OP_SGT
        /// </summary>
        /// <remarks>
        /// Signed bit-vector &gt; - Binary relation.
        /// </remarks>
        Z3_OP_SGT = 1048,

        /// <summary>
        /// Z3_OP_BAND
        /// </summary>
        /// <remarks>
        /// Bit-wise and - Binary.
        /// </remarks>
        Z3_OP_BAND = 1049,

        /// <summary>
        /// Z3_OP_BOR
        /// </summary>
        /// <remarks>
        /// Bit-wise or - Binary.
        /// </remarks>
        Z3_OP_BOR = 1050,

        /// <summary>
        /// Z3_OP_BNOT
        /// </summary>
        /// <remarks>
        /// Bit-wise not - Unary.
        /// </remarks>
        Z3_OP_BNOT = 1051,

        /// <summary>
        /// Z3_OP_BXOR
        /// </summary>
        /// <remarks>
        /// Bit-wise xor - Binary.
        /// </remarks>
        Z3_OP_BXOR = 1052,

        /// <summary>
        /// Z3_OP_BNAND
        /// </summary>
        /// <remarks>
        /// Bit-wise nand - Binary.
        /// </remarks>
        Z3_OP_BNAND = 1053,

        /// <summary>
        /// Z3_OP_BNOR
        /// </summary>
        /// <remarks>
        /// Bit-wise nor - Binary.
        /// </remarks>
        Z3_OP_BNOR = 1054,

        /// <summary>
        /// Z3_OP_BXNOR
        /// </summary>
        /// <remarks>
        /// Bit-wise xnor - Binary.
        /// </remarks>
        Z3_OP_BXNOR = 1055,

        /// <summary>
        /// Z3_OP_CONCAT
        /// </summary>
        /// <remarks>
        /// Bit-vector concatenation - Binary.
        /// </remarks>
        Z3_OP_CONCAT = 1056,

        /// <summary>
        /// Z3_OP_SIGN_EXT
        /// </summary>
        /// <remarks>
        /// Bit-vector sign extension.
        /// </remarks>
        Z3_OP_SIGN_EXT = 1057,

        /// <summary>
        /// Z3_OP_ZERO_EXT
        /// </summary>
        /// <remarks>
        /// Bit-vector zero extension.
        /// </remarks>
        Z3_OP_ZERO_EXT = 1058,

        /// <summary>
        /// Z3_OP_EXTRACT
        /// </summary>
        /// <remarks>
        /// Bit-vector extraction.
        /// </remarks>
        Z3_OP_EXTRACT = 1059,

        /// <summary>
        /// Z3_OP_REPEAT
        /// </summary>
        /// <remarks>
        /// Repeat bit-vector n times.
        /// </remarks>
        Z3_OP_REPEAT = 1060,

        /// <summary>
        /// Z3_OP_BREDOR
        /// </summary>
        /// <remarks>
        /// Bit-vector reduce or - Unary.
        /// </remarks>
        Z3_OP_BREDOR = 1061,

        /// <summary>
        /// Z3_OP_BREDAND
        /// </summary>
        /// <remarks>
        /// Bit-vector reduce and - Unary.
        /// </remarks>
        Z3_OP_BREDAND = 1062,

        /// <summary>
        /// Z3_OP_BCOMP
        /// </summary>
        /// <remarks>
        /// .
        /// </remarks>
        Z3_OP_BCOMP = 1063,

        /// <summary>
        /// Z3_OP_BSHL
        /// </summary>
        /// <remarks>
        /// Shift left.
        /// </remarks>
        Z3_OP_BSHL = 1064,

        /// <summary>
        /// Z3_OP_BLSHR
        /// </summary>
        /// <remarks>
        /// Logical shift right.
        /// </remarks>
        Z3_OP_BLSHR = 1065,

        /// <summary>
        /// Z3_OP_BASHR
        /// </summary>
        /// <remarks>
        /// Arithmetical shift right.
        /// </remarks>
        Z3_OP_BASHR = 1066,

        /// <summary>
        /// Z3_OP_ROTATE_LEFT
        /// </summary>
        /// <remarks>
        /// Left rotation.
        /// </remarks>
        Z3_OP_ROTATE_LEFT = 1067,

        /// <summary>
        /// Z3_OP_ROTATE_RIGHT
        /// </summary>
        /// <remarks>
        /// Right rotation.
        /// </remarks>
        Z3_OP_ROTATE_RIGHT = 1068,

        /// <summary>
        /// Z3_OP_EXT_ROTATE_LEFT
        /// </summary>
        /// <remarks>
        /// (extended) Left rotation. Similar to Z3_OP_ROTATE_LEFT, but it is a binary operator instead of a parametric one.
        /// </remarks>
        Z3_OP_EXT_ROTATE_LEFT = 1069,

        /// <summary>
        /// Z3_OP_EXT_ROTATE_RIGHT
        /// </summary>
        /// <remarks>
        /// (extended) Right rotation. Similar to Z3_OP_ROTATE_RIGHT, but it is a binary operator instead of a parametric one.
        /// </remarks>
        Z3_OP_EXT_ROTATE_RIGHT = 1070,

        /// <summary>Z3_OP_BIT2BOOL</summary>
        Z3_OP_BIT2BOOL = 1071,

        /// <summary>
        /// Z3_OP_INT2BV
        /// </summary>
        /// <remarks>
        /// Coerce integer to bit-vector.
        /// </remarks>
        Z3_OP_INT2BV = 1072,

        /// <summary>
        /// Z3_OP_BV2INT
        /// </summary>
        /// <remarks>
        /// Coerce bit-vector to integer.
        /// </remarks>
        Z3_OP_BV2INT = 1073,

        /// <summary>
        /// Z3_OP_SBV2INT
        /// </summary>
        /// <remarks>
        /// Coerce signed bit-vector to integer.
        /// </remarks>
        Z3_OP_SBV2INT = 1074,

        /// <summary>
        /// Z3_OP_CARRY
        /// </summary>
        /// <remarks>
        /// Compute the carry bit in a full-adder.
        /// The meaning is given by the equivalence
        /// (carry l1 l2 l3) &lt;=&gt; (or (and l1 l2) (and l1 l3) (and l2 l3)))
        /// </remarks>
        Z3_OP_CARRY = 1075,

        /// <summary>
        /// Z3_OP_XOR3
        /// </summary>
        /// <remarks>
        /// Compute ternary XOR.
        /// The meaning is given by the equivalence
        /// (xor3 l1 l2 l3) &lt;=&gt; (xor (xor l1 l2) l3)
        /// </remarks>
        Z3_OP_XOR3 = 1076,

        /// <summary>
        /// Z3_OP_BSMUL_NO_OVFL
        /// </summary>
        /// <remarks>
        /// a predicate to check that bit-wise signed multiplication does not overflow.
        /// Signed multiplication overflows if the operands have the same sign and the result of multiplication
        /// does not fit within the available bits. \sa Z3_mk_bvmul_no_overflow.
        /// </remarks>
        Z3_OP_BSMUL_NO_OVFL = 1077,

        /// <summary>
        /// Z3_OP_BUMUL_NO_OVFL
        /// </summary>
        /// <remarks>
        /// check that bit-wise unsigned multiplication does not overflow.
        /// Unsigned multiplication overflows if the result does not fit within the available bits.
        /// \sa Z3_mk_bvmul_no_overflow.
        /// </remarks>
        Z3_OP_BUMUL_NO_OVFL = 1078,

        /// <summary>
        /// Z3_OP_BSMUL_NO_UDFL
        /// </summary>
        /// <remarks>
        /// check that bit-wise signed multiplication does not underflow.
        /// Signed multiplication underflows if the operands have opposite signs and the result of multiplication
        /// does not fit within the available bits. Z3_mk_bvmul_no_underflow.
        /// </remarks>
        Z3_OP_BSMUL_NO_UDFL = 1079,

        /// <summary>
        /// Z3_OP_BSDIV_I
        /// </summary>
        /// <remarks>
        /// Binary signed division.
        /// It has the same semantics as Z3_OP_BSDIV, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        Z3_OP_BSDIV_I = 1080,

        /// <summary>
        /// Z3_OP_BUDIV_I
        /// </summary>
        /// <remarks>
        /// Binary unsigned division.
        /// It has the same semantics as Z3_OP_BUDIV, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        Z3_OP_BUDIV_I = 1081,

        /// <summary>
        /// Z3_OP_BSREM_I
        /// </summary>
        /// <remarks>
        /// Binary signed remainder.
        /// It has the same semantics as Z3_OP_BSREM, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        Z3_OP_BSREM_I = 1082,

        /// <summary>
        /// Z3_OP_BUREM_I
        /// </summary>
        /// <remarks>
        /// Binary unsigned remainder.
        /// It has the same semantics as Z3_OP_BUREM, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        Z3_OP_BUREM_I = 1083,

        /// <summary>
        /// Z3_OP_BSMOD_I
        /// </summary>
        /// <remarks>
        /// Binary signed modulus.
        /// It has the same semantics as Z3_OP_BSMOD, but created in a context where the second operand can be assumed to be non-zero.
        /// </remarks>
        Z3_OP_BSMOD_I = 1084,

        /// <summary>
        /// Z3_OP_PR_UNDEF
        /// </summary>
        /// <remarks>
        /// Undef/Null proof object.
        /// </remarks>
        Z3_OP_PR_UNDEF = 0x500,

        /// <summary>
        /// Z3_OP_PR_TRUE
        /// </summary>
        /// <remarks>
        /// Proof for the expression 'true'.
        /// </remarks>
        Z3_OP_PR_TRUE = 1281,

        /// <summary>
        /// Z3_OP_PR_ASSERTED
        /// </summary>
        /// <remarks>
        /// Proof for a fact asserted by the user.
        /// </remarks>
        Z3_OP_PR_ASSERTED = 1282,

        /// <summary>
        /// Z3_OP_PR_GOAL
        /// </summary>
        /// <remarks>
        /// Proof for a fact (tagged as goal) asserted by the user.
        /// </remarks>
        Z3_OP_PR_GOAL = 1283,

        /// <summary>
        /// Z3_OP_PR_MODUS_PONENS
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for p and a proof for (implies p q), produces a proof for q.
        /// </para>
        /// <para>
        /// T1: p
        /// T2: (implies p q)
        /// [mp T1 T2]: q
        /// </para>
        /// <para>
        /// The second antecedents may also be a proof for (iff p q).
        /// </para>
        /// </remarks>
        Z3_OP_PR_MODUS_PONENS = 1284,

        /// <summary>
        /// Z3_OP_PR_REFLEXIVITY
        /// </summary>
        /// <remarks>
        /// A proof for (R t t), where R is a reflexive relation. This proof object has no antecedents.
        /// The only reflexive relations that are used are
        /// equivalence modulo namings, equality and equivalence.
        /// That is, R is either '~', '=' or 'iff'.
        /// </remarks>
        Z3_OP_PR_REFLEXIVITY = 1285,

        /// <summary>
        /// Z3_OP_PR_SYMMETRY
        /// </summary>
        /// <remarks>
        /// Given an symmetric relation R and a proof for (R t s), produces a proof for (R s t).
        /// <code>
        /// ╔════════════════════════╗
        /// ║ T1: (R t s)            ║
        /// ║ [symmetry T1]: (R s t) ║
        /// ╚════════════════════════╝
        /// </code>
        /// T1 is the antecedent of this proof object.
        /// </remarks>
        Z3_OP_PR_SYMMETRY = 1286,

        /// <summary>
        /// Z3_OP_PR_TRANSITIVITY
        /// </summary>
        /// <remarks>
        /// Given a transitive relation R, and proofs for (R t s) and (R s u), produces a proof
        /// for (R t u).
        /// <code>
        /// ╔════════════════════════╗
        /// ║ T1: (R t s)            ║
        /// ║ T2: (R s u)            ║
        /// ║ [trans T1 T2]: (R t u) ║
        /// ╚════════════════════════╝
        /// </code>
        /// </remarks>
        Z3_OP_PR_TRANSITIVITY = 1287,

        /// <summary>
        /// Z3_OP_PR_TRANSITIVITY_STAR
        /// </summary>
        /// <remarks>
        /// <para>
        /// Condensed transitivity proof.
        /// It combines several symmetry and transitivity proofs. Example:
        /// <code>
        /// ╔════════════════════════════╗
        /// ║ T1: (R a b)                ║
        /// ║ T2: (R c b)                ║
        /// ║ T3: (R c d)                ║
        /// ║ [trans* T1 T2 T3]: (R a d) ║
        /// ╚════════════════════════════╝
        /// </code>
        /// R must be a symmetric and transitive relation.
        /// </para>
        /// <para>
        /// Assuming that this proof object is a proof for (R s t), then
        /// a proof checker must check if it is possible to prove (R s t)
        /// using the antecedents, symmetry and transitivity.  That is,
        /// if there is a path from s to t, if we view every
        /// antecedent (R a b) as an edge between a and b.
        /// </para>
        /// </remarks>
        Z3_OP_PR_TRANSITIVITY_STAR = 1288,

        /// <summary>
        /// Z3_OP_PR_MONOTONICITY
        /// </summary>
        /// <remarks>
        /// <para>
        /// Monotonicity proof object.
        /// </para>
        /// <para>
        /// T1: (R t_1 s_1)
        /// ...
        /// Tn: (R t_n s_n)
        /// [monotonicity T1 ... Tn]: (R (f t_1 ... t_n) (f s_1 ... s_n))
        /// </para>
        /// <para>
        /// Remark: if t_i == s_i, then the antecedent Ti is suppressed.
        /// That is, reflexivity proofs are suppressed to save space.
        /// </para>
        /// </remarks>
        Z3_OP_PR_MONOTONICITY = 1289,

        /// <summary>
        /// Z3_OP_PR_QUANT_INTRO
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for (~ p q), produces a proof for (~ (forall (x) p) (forall (x) q)).
        /// </para>
        /// <para>
        /// T1: (~ p q)
        /// [quant-intro T1]: (~ (forall (x) p) (forall (x) q))
        /// </para>
        /// </remarks>
        Z3_OP_PR_QUANT_INTRO = 1290,

        /// <summary>
        /// Z3_OP_PR_BIND
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof p, produces a proof of lambda x . p, where x are free variables in p.
        /// </para>
        /// <para>
        /// T1: f
        /// [proof-bind T1] forall (x) f
        /// </para>
        /// </remarks>
        Z3_OP_PR_BIND = 1291,

        /// <summary>
        /// Z3_OP_PR_DISTRIBUTIVITY
        /// </summary>
        /// <remarks>
        /// <para>
        /// Distributivity proof object.
        /// Given that f (= or) distributes over g (= and), produces a proof for
        /// <code>
        /// ╔══════════════════════╗
        /// ║ (= (f a (g c d))     ║
        /// ║ (g (f a c) (f a d))) ║
        /// ╚══════════════════════╝
        /// </code>
        /// If f and g are associative, this proof also justifies the following equality:
        /// <code>
        /// ╔══════════════════════════════════════╗
        /// ║ (= (f (g a b) (g c d))               ║
        /// ║ (g (f a c) (f a d) (f b c) (f b d))) ║
        /// ╚══════════════════════════════════════╝
        /// </code>
        /// where each f and g can have arbitrary number of arguments.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// Remark. This rule is used by the CNF conversion pass and
        /// instantiated by f = or, and g = and.
        /// </para>
        /// </remarks>
        Z3_OP_PR_DISTRIBUTIVITY = 1292,

        /// <summary>
        /// Z3_OP_PR_AND_ELIM
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for (and l_1 ... l_n), produces a proof for l_i
        /// </para>
        /// <para>
        /// T1: (and l_1 ... l_n)
        /// [and-elim T1]: l_i
        /// </para>
        /// </remarks>
        Z3_OP_PR_AND_ELIM = 1293,

        /// <summary>
        /// Z3_OP_PR_NOT_OR_ELIM
        /// </summary>
        /// <remarks>
        /// <para>
        /// Given a proof for (not (or l_1 ... l_n)), produces a proof for (not l_i).
        /// </para>
        /// <para>
        /// T1: (not (or l_1 ... l_n))
        /// [not-or-elim T1]: (not l_i)
        /// </para>
        /// </remarks>
        Z3_OP_PR_NOT_OR_ELIM = 1294,

        /// <summary>
        /// Z3_OP_PR_REWRITE
        /// </summary>
        /// <remarks>
        /// <para>
        /// A proof for a local rewriting step (= t s).
        /// The head function symbol of t is interpreted.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// The conclusion of a rewrite rule is either an equality (= t s),
        /// an equivalence (iff t s), or equi-satisfiability (~ t s).
        /// Remark: if f is bool, then = is iff.
        /// Examples:
        /// <code>
        /// ╔═══════════════════════╗
        /// ║ (= (+ x 0) x)         ║
        /// ║ (= (+ x 1 2) (+ 3 x)) ║
        /// ║ (iff (or x false) x)  ║
        /// ╚═══════════════════════╝
        /// </code>
        /// </para>
        /// </remarks>
        Z3_OP_PR_REWRITE = 1295,

        /// <summary>
        /// Z3_OP_PR_REWRITE_STAR
        /// </summary>
        /// <remarks>
        /// A proof for rewriting an expression t into an expression s.
        /// This proof object can have n antecedents.
        /// The antecedents are proofs for equalities used as substitution rules.
        /// The proof rule is used in a few cases. The cases are:
        /// <list type="bullet">
        /// <item><description>When applying contextual simplification (CONTEXT_SIMPLIFIER=true)</description></item>
        /// <item><description>When converting bit-vectors to Booleans (BIT2BOOL=true)</description></item>
        /// </list>
        /// </remarks>
        Z3_OP_PR_REWRITE_STAR = 1296,

        /// <summary>
        /// Z3_OP_PR_PULL_QUANT
        /// </summary>
        /// <remarks>
        /// A proof for (iff (f (forall (x) q(x)) r) (forall (x) (f (q x) r))). This proof object has no antecedents.
        /// </remarks>
        Z3_OP_PR_PULL_QUANT = 1297,

        /// <summary>
        /// Z3_OP_PR_PUSH_QUANT
        /// </summary>
        /// <remarks>
        /// A proof for:
        /// <code>
        /// ╔═════════════════════════════════════════════════════════════════════════╗
        /// ║ (iff (forall (x_1 ... x_m) (and p_1[x_1 ... x_m] ... p_n[x_1 ... x_m])) ║
        /// ║ (and (forall (x_1 ... x_m) p_1[x_1 ... x_m])                            ║
        /// ║ ...                                                                     ║
        /// ║ (forall (x_1 ... x_m) p_n[x_1 ... x_m])))                               ║
        /// ╚═════════════════════════════════════════════════════════════════════════╝
        /// </code>
        /// This proof object has no antecedents.
        /// </remarks>
        Z3_OP_PR_PUSH_QUANT = 1298,

        /// <summary>
        /// Z3_OP_PR_ELIM_UNUSED_VARS
        /// </summary>
        /// <remarks>
        /// <para>
        /// A proof for (iff (forall (x_1 ... x_n y_1 ... y_m) p[x_1 ... x_n])
        /// (forall (x_1 ... x_n) p[x_1 ... x_n]))
        /// </para>
        /// <para>
        /// It is used to justify the elimination of unused variables.
        /// This proof object has no antecedents.
        /// </para>
        /// </remarks>
        Z3_OP_PR_ELIM_UNUSED_VARS = 1299,

        /// <summary>
        /// Z3_OP_PR_DER
        /// </summary>
        /// <remarks>
        /// <para>
        /// A proof for destructive equality resolution:
        /// (iff (forall (x) (or (not (= x t)) P[x])) P[t])
        /// if x does not occur in t.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// </para>
        /// <para>
        /// Several variables can be eliminated simultaneously.
        /// </para>
        /// </remarks>
        Z3_OP_PR_DER = 1300,

        /// <summary>
        /// Z3_OP_PR_QUANT_INST
        /// </summary>
        /// <remarks>
        /// A proof of (or (not (forall (x) (P x))) (P a))
        /// </remarks>
        Z3_OP_PR_QUANT_INST = 1301,

        /// <summary>
        /// Z3_OP_PR_HYPOTHESIS
        /// </summary>
        /// <remarks>
        /// Mark a hypothesis in a natural deduction style proof.
        /// </remarks>
        Z3_OP_PR_HYPOTHESIS = 1302,

        /// <summary>
        /// Z3_OP_PR_LEMMA
        /// </summary>
        /// <remarks>
        /// <para>
        /// T1: false
        /// [lemma T1]: (or (not l_1) ... (not l_n))
        /// </para>
        /// <para>
        /// This proof object has one antecedent: a hypothetical proof for false.
        /// It converts the proof in a proof for (or (not l_1) ... (not l_n)),
        /// when T1 contains the open hypotheses: l_1, ..., l_n.
        /// The hypotheses are closed after an application of a lemma.
        /// Furthermore, there are no other open hypotheses in the subtree covered by
        /// the lemma.
        /// </para>
        /// </remarks>
        Z3_OP_PR_LEMMA = 1303,

        /// <summary>
        /// Z3_OP_PR_UNIT_RESOLUTION
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═════════════════════════════════════════════════════╗
        /// ║ T1:      (or l_1 ... l_n l_1' ... l_m')             ║
        /// ║ T2:      (not l_1)                                  ║
        /// ║ ...                                                 ║
        /// ║ T(n+1):  (not l_n)                                  ║
        /// ║ [unit-resolution T1 ... T(n+1)]: (or l_1' ... l_m') ║
        /// ╚═════════════════════════════════════════════════════╝
        /// </code>
        /// </remarks>
        Z3_OP_PR_UNIT_RESOLUTION = 1304,

        /// <summary>
        /// Z3_OP_PR_IFF_TRUE
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═════════════════════════════╗
        /// ║ T1: p                       ║
        /// ║ [iff-true T1]: (iff p true) ║
        /// ╚═════════════════════════════╝
        /// </code>
        /// </remarks>
        Z3_OP_PR_IFF_TRUE = 1305,

        /// <summary>
        /// Z3_OP_PR_IFF_FALSE
        /// </summary>
        /// <remarks>
        /// <code>
        /// ╔═══════════════════════════════╗
        /// ║ T1: (not p)                   ║
        /// ║ [iff-false T1]: (iff p false) ║
        /// ╚═══════════════════════════════╝
        /// </code>
        /// </remarks>
        Z3_OP_PR_IFF_FALSE = 1306,

        /// <summary>
        /// Z3_OP_PR_COMMUTATIVITY
        /// </summary>
        /// <remarks>
        /// <para>
        /// [comm]: (= (f a b) (f b a))
        /// </para>
        /// <para>
        /// f is a commutative operator.
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// Remark: if f is bool, then = is iff.
        /// </para>
        /// </remarks>
        Z3_OP_PR_COMMUTATIVITY = 1307,

        /// <summary>
        /// Z3_OP_PR_DEF_AXIOM
        /// </summary>
        /// <remarks>
        /// Proof object used to justify Tseitin's like axioms:
        /// <code>
        /// ╔══════════════════════════════════╗
        /// ║ (or (not (and p q)) p)           ║
        /// ║ (or (not (and p q)) q)           ║
        /// ║ (or (not (and p q r)) p)         ║
        /// ║ (or (not (and p q r)) q)         ║
        /// ║ (or (not (and p q r)) r)         ║
        /// ║ ...                              ║
        /// ║ (or (and p q) (not p) (not q))   ║
        /// ║ (or (not (or p q)) p q)          ║
        /// ║ (or (or p q) (not p))            ║
        /// ║ (or (or p q) (not q))            ║
        /// ║ (or (not (iff p q)) (not p) q)   ║
        /// ║ (or (not (iff p q)) p (not q))   ║
        /// ║ (or (iff p q) (not p) (not q))   ║
        /// ║ (or (iff p q) p q)               ║
        /// ║ (or (not (ite a b c)) (not a) b) ║
        /// ║ (or (not (ite a b c)) a c)       ║
        /// ║ (or (ite a b c) (not a) (not b)) ║
        /// ║ (or (ite a b c) a (not c))       ║
        /// ║ (or (not (not a)) (not a))       ║
        /// ║ (or (not a) a)                   ║
        /// ╚══════════════════════════════════╝
        /// </code>
        /// This proof object has no antecedents.
        /// Note: all axioms are propositional tautologies.
        /// Note also that 'and' and 'or' can take multiple arguments.
        /// You can recover the propositional tautologies by
        /// unfolding the Boolean connectives in the axioms a small
        /// bounded number of steps (=3).
        /// </remarks>
        Z3_OP_PR_DEF_AXIOM = 1308,

        /// <summary>
        /// Z3_OP_PR_ASSUMPTION_ADD
        /// </summary>
        /// <remarks>
        /// Clausal proof adding axiom
        /// </remarks>
        Z3_OP_PR_ASSUMPTION_ADD = 1309,

        /// <summary>
        /// Z3_OP_PR_LEMMA_ADD
        /// </summary>
        /// <remarks>
        /// Clausal proof lemma addition
        /// </remarks>
        Z3_OP_PR_LEMMA_ADD = 1310,

        /// <summary>
        /// Z3_OP_PR_REDUNDANT_DEL
        /// </summary>
        /// <remarks>
        /// Clausal proof lemma deletion
        /// </remarks>
        Z3_OP_PR_REDUNDANT_DEL = 1311,

        /// <summary>Z3_OP_PR_CLAUSE_TRAIL</summary>
        Z3_OP_PR_CLAUSE_TRAIL = 1312,

        /// <summary>
        /// Z3_OP_PR_DEF_INTRO
        /// </summary>
        /// <remarks>
        /// <para>
        /// Introduces a name for a formula/term.
        /// Suppose e is an expression with free variables x, and def-intro
        /// introduces the name n(x). The possible cases are:
        /// </para>
        /// <para>
        /// When e is of Boolean type:
        /// [def-intro]: (and (or n (not e)) (or (not n) e))
        /// </para>
        /// <para>
        /// or:
        /// [def-intro]: (or (not n) e)
        /// when e only occurs positively.
        /// </para>
        /// <para>
        /// When e is of the form (ite cond th el):
        /// [def-intro]: (and (or (not cond) (= n th)) (or cond (= n el)))
        /// </para>
        /// <para>
        /// Otherwise:
        /// [def-intro]: (= n e)
        /// </para>
        /// </remarks>
        Z3_OP_PR_DEF_INTRO = 1313,

        /// <summary>
        /// Z3_OP_PR_APPLY_DEF
        /// </summary>
        /// <remarks>
        /// <para>
        /// [apply-def T1]: F ~ n
        /// </para>
        /// <para>
        /// F is 'equivalent' to n, given that T1 is a proof that
        /// n is a name for F.
        /// </para>
        /// </remarks>
        Z3_OP_PR_APPLY_DEF = 1314,

        /// <summary>
        /// Z3_OP_PR_IFF_OEQ
        /// </summary>
        /// <remarks>
        /// T1: (iff p q)
        /// [iff~ T1]: (~ p q)
        /// </remarks>
        Z3_OP_PR_IFF_OEQ = 1315,

        /// <summary>
        /// Z3_OP_PR_NNF_POS
        /// </summary>
        /// <remarks>
        /// <para>
        /// Proof for a (positive) NNF step. Example:
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// T2: (not s_2) ~ r_2
        /// T3: s_1 ~ r_1'
        /// T4: s_2 ~ r_2'
        /// [nnf-pos T1 T2 T3 T4]: (~ (iff s_1 s_2) (and (or r_1 r_2') (or r_1' r_2)))
        /// </para>
        /// <para>
        /// The negation normal form steps NNF_POS and NNF_NEG are used in the following cases:
        /// (a) When creating the NNF of a positive force quantifier.
        /// The quantifier is retained (unless the bound variables are eliminated).
        /// Example
        /// </para>
        /// <para>
        /// T1: q ~ q_new
        /// [nnf-pos T1]: (~ (forall (x T) q) (forall (x T) q_new))
        /// </para>
        /// <para>
        /// (b) When recursively creating NNF over Boolean formulas, where the top-level
        /// connective is changed during NNF conversion. The relevant Boolean connectives
        /// for NNF_POS are 'implies', 'iff', 'xor', 'ite'.
        /// NNF_NEG furthermore handles the case where negation is pushed
        /// over Boolean connectives 'and' and 'or'.
        /// </para>
        /// </remarks>
        Z3_OP_PR_NNF_POS = 1316,

        /// <summary>
        /// Z3_OP_PR_NNF_NEG
        /// </summary>
        /// <remarks>
        /// <para>
        /// Proof for a (negative) NNF step. Examples:
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// ...
        /// Tn: (not s_n) ~ r_n
        /// [nnf-neg T1 ... Tn]: (not (and s_1 ... s_n)) ~ (or r_1 ... r_n)
        /// </para>
        /// <para>
        /// and
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// ...
        /// Tn: (not s_n) ~ r_n
        /// [nnf-neg T1 ... Tn]: (not (or s_1 ... s_n)) ~ (and r_1 ... r_n)
        /// </para>
        /// <para>
        /// and
        /// </para>
        /// <para>
        /// T1: (not s_1) ~ r_1
        /// T2: (not s_2) ~ r_2
        /// T3: s_1 ~ r_1'
        /// T4: s_2 ~ r_2'
        /// [nnf-neg T1 T2 T3 T4]: (~ (not (iff s_1 s_2))
        /// (and (or r_1 r_2) (or r_1' r_2')))
        /// </para>
        /// </remarks>
        Z3_OP_PR_NNF_NEG = 1317,

        /// <summary>
        /// Z3_OP_PR_SKOLEMIZE
        /// </summary>
        /// <remarks>
        /// <para>
        /// Proof for:
        /// </para>
        /// <para>
        /// [sk]: (~ (not (forall x (p x y))) (not (p (sk y) y)))
        /// [sk]: (~ (exists x (p x y)) (p (sk y) y))
        /// </para>
        /// <para>
        /// This proof object has no antecedents.
        /// </para>
        /// </remarks>
        Z3_OP_PR_SKOLEMIZE = 1318,

        /// <summary>
        /// Z3_OP_PR_MODUS_PONENS_OEQ
        /// </summary>
        /// <remarks>
        /// <para>
        /// Modus ponens style rule for equi-satisfiability.
        /// </para>
        /// <para>
        /// T1: p
        /// T2: (~ p q)
        /// [mp~ T1 T2]: q
        /// </para>
        /// </remarks>
        Z3_OP_PR_MODUS_PONENS_OEQ = 1319,

        /// <summary>
        /// Z3_OP_PR_TH_LEMMA
        /// </summary>
        /// <remarks>
        /// <para>
        /// Generic proof for theory lemmas.
        /// The theory lemma function comes with one or more parameters.
        /// The first parameter indicates the name of the theory.
        /// For the theory of arithmetic, additional parameters provide hints for
        /// checking the theory lemma.
        /// The hints for arithmetic are:
        /// </para>
        /// <para>
        /// <list type="bullet">
        /// <item><description>farkas - followed by rational coefficients. Multiply the coefficients to the inequalities in the lemma, add the (negated) inequalities and obtain a contradiction.</description></item>
        /// </list>
        /// </para>
        /// <para>
        /// <list type="bullet">
        /// <item><description>triangle-eq - Indicates a lemma related to the equivalence:</description></item>
        /// </list>
        /// </para>
        /// <para>
        /// (iff (= t1 t2) (and (&lt;= t1 t2) (&lt;= t2 t1)))
        /// </para>
        /// <para>
        /// <list type="bullet">
        /// <item><description>gcd-test - Indicates an integer linear arithmetic lemma that uses a gcd test.</description></item>
        /// </list>
        /// </para>
        /// </remarks>
        Z3_OP_PR_TH_LEMMA = 1320,

        /// <summary>
        /// Z3_OP_PR_HYPER_RESOLVE
        /// </summary>
        /// <remarks>
        /// <para>
        /// Hyper-resolution rule.
        /// </para>
        /// <para>
        /// The premises of the rules is a sequence of clauses.
        /// The first clause argument is the main clause of the rule.
        /// with a literal from the first (main) clause.
        /// </para>
        /// <para>
        /// Premises of the rules are of the form
        /// <code>
        /// ╔═════════════════════╗
        /// ║ (or l0 l1 l2 .. ln) ║
        /// ╚═════════════════════╝
        /// </code>
        /// or
        /// <code>
        /// ╔═══════════════════════════╗
        /// ║ (=> (and l1 l2 .. ln) l0) ║
        /// ╚═══════════════════════════╝
        /// </code>
        /// or in the most general (ground) form:
        /// <code>
        /// ╔═══════════════════════════════════════════════╗
        /// ║ (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln)) ║
        /// ╚═══════════════════════════════════════════════╝
        /// </code>
        /// In other words we use the following (Prolog style) convention for Horn
        /// implications:
        /// The head of a Horn implication is position 0,
        /// the first conjunct in the body of an implication is position 1
        /// the second conjunct in the body of an implication is position 2
        /// </para>
        /// <para>
        /// For general implications where the head is a disjunction, the
        /// first n positions correspond to the n disjuncts in the head.
        /// The next m positions correspond to the m conjuncts in the body.
        /// </para>
        /// <para>
        /// The premises can be universally quantified so that the most
        /// general non-ground form is:
        /// </para>
        /// <para>
        /// <code>
        /// ╔═══════════════════════════════════════════════════════════════╗
        /// ║ (forall (vars) (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln))) ║
        /// ╚═══════════════════════════════════════════════════════════════╝
        /// </code>
        /// </para>
        /// <para>
        /// The hyper-resolution rule takes a sequence of parameters.
        /// The parameters are substitutions of bound variables separated by pairs
        /// of literal positions from the main clause and side clause.
        /// </para>
        /// </remarks>
        Z3_OP_PR_HYPER_RESOLVE = 1321,

        /// <summary>
        /// Z3_OP_RA_STORE
        /// </summary>
        /// <remarks>
        /// Insert a record into a relation.
        /// The function takes n+1 arguments, where the first argument is the relation and the remaining n elements
        /// correspond to the n columns of the relation.
        /// </remarks>
        Z3_OP_RA_STORE = 0x600,

        /// <summary>
        /// Z3_OP_RA_EMPTY
        /// </summary>
        /// <remarks>
        /// Creates the empty relation.
        /// </remarks>
        Z3_OP_RA_EMPTY = 1537,

        /// <summary>
        /// Z3_OP_RA_IS_EMPTY
        /// </summary>
        /// <remarks>
        /// Tests if the relation is empty.
        /// </remarks>
        Z3_OP_RA_IS_EMPTY = 1538,

        /// <summary>
        /// Z3_OP_RA_JOIN
        /// </summary>
        /// <remarks>
        /// Create the relational join.
        /// </remarks>
        Z3_OP_RA_JOIN = 1539,

        /// <summary>
        /// Z3_OP_RA_UNION
        /// </summary>
        /// <remarks>
        /// Create the union or convex hull of two relations.
        /// The function takes two arguments.
        /// </remarks>
        Z3_OP_RA_UNION = 1540,

        /// <summary>
        /// Z3_OP_RA_WIDEN
        /// </summary>
        /// <remarks>
        /// Widen two relations.
        /// The function takes two arguments.
        /// </remarks>
        Z3_OP_RA_WIDEN = 1541,

        /// <summary>
        /// Z3_OP_RA_PROJECT
        /// </summary>
        /// <remarks>
        /// Project the columns (provided as numbers in the parameters).
        /// The function takes one argument.
        /// </remarks>
        Z3_OP_RA_PROJECT = 1542,

        /// <summary>
        /// Z3_OP_RA_FILTER
        /// </summary>
        /// <remarks>
        /// Filter (restrict) a relation with respect to a predicate.
        /// The first argument is a relation.
        /// The second argument is a predicate with free de-Bruijn indices
        /// corresponding to the columns of the relation.
        /// So the first column in the relation has index 0.
        /// </remarks>
        Z3_OP_RA_FILTER = 1543,

        /// <summary>
        /// Z3_OP_RA_NEGATION_FILTER
        /// </summary>
        /// <remarks>
        /// <para>
        /// Intersect the first relation with respect to negation
        /// of the second relation (the function takes two arguments).
        /// Logically, the specification can be described by a function
        /// </para>
        /// <para>
        /// target = filter_by_negation(pos, neg, columns)
        /// </para>
        /// <para>
        /// where columns are pairs c1, d1, .., cN, dN of columns from pos and neg, such that
        /// target are elements in x in pos, such that there is no y in neg that agrees with
        /// x on the columns c1, d1, .., cN, dN.
        /// </para>
        /// </remarks>
        Z3_OP_RA_NEGATION_FILTER = 1544,

        /// <summary>
        /// Z3_OP_RA_RENAME
        /// </summary>
        /// <remarks>
        /// rename columns in the relation.
        /// The function takes one argument.
        /// The parameters contain the renaming as a cycle.
        /// </remarks>
        Z3_OP_RA_RENAME = 1545,

        /// <summary>
        /// Z3_OP_RA_COMPLEMENT
        /// </summary>
        /// <remarks>
        /// Complement the relation.
        /// </remarks>
        Z3_OP_RA_COMPLEMENT = 1546,

        /// <summary>
        /// Z3_OP_RA_SELECT
        /// </summary>
        /// <remarks>
        /// Check if a record is an element of the relation.
        /// The function takes n+1 arguments, where the first argument is a relation,
        /// and the remaining n arguments correspond to a record.
        /// </remarks>
        Z3_OP_RA_SELECT = 1547,

        /// <summary>
        /// Z3_OP_RA_CLONE
        /// </summary>
        /// <remarks>
        /// Create a fresh copy (clone) of a relation.
        /// The function is logically the identity, but
        /// in the context of a register machine allows
        /// for <see cref="Z3_OP_RA_UNION"/> to perform destructive updates to the first argument.
        /// </remarks>
        Z3_OP_RA_CLONE = 1548,

        /// <summary>Z3_OP_FD_CONSTANT</summary>
        Z3_OP_FD_CONSTANT = 1549,

        /// <summary>
        /// Z3_OP_FD_LT
        /// </summary>
        /// <remarks>
        /// A less than predicate over the finite domain Z3_FINITE_DOMAIN_SORT.
        /// </remarks>
        Z3_OP_FD_LT = 1550,

        /// <summary>Z3_OP_SEQ_UNIT</summary>
        Z3_OP_SEQ_UNIT = 1551,

        /// <summary>Z3_OP_SEQ_EMPTY</summary>
        Z3_OP_SEQ_EMPTY = 1552,

        /// <summary>Z3_OP_SEQ_CONCAT</summary>
        Z3_OP_SEQ_CONCAT = 1553,

        /// <summary>Z3_OP_SEQ_PREFIX</summary>
        Z3_OP_SEQ_PREFIX = 1554,

        /// <summary>Z3_OP_SEQ_SUFFIX</summary>
        Z3_OP_SEQ_SUFFIX = 1555,

        /// <summary>Z3_OP_SEQ_CONTAINS</summary>
        Z3_OP_SEQ_CONTAINS = 1556,

        /// <summary>Z3_OP_SEQ_EXTRACT</summary>
        Z3_OP_SEQ_EXTRACT = 1557,

        /// <summary>Z3_OP_SEQ_REPLACE</summary>
        Z3_OP_SEQ_REPLACE = 1558,

        /// <summary>Z3_OP_SEQ_REPLACE_RE</summary>
        Z3_OP_SEQ_REPLACE_RE = 1559,

        /// <summary>Z3_OP_SEQ_REPLACE_RE_ALL</summary>
        Z3_OP_SEQ_REPLACE_RE_ALL = 1560,

        /// <summary>Z3_OP_SEQ_REPLACE_ALL</summary>
        Z3_OP_SEQ_REPLACE_ALL = 1561,

        /// <summary>Z3_OP_SEQ_AT</summary>
        Z3_OP_SEQ_AT = 1562,

        /// <summary>Z3_OP_SEQ_NTH</summary>
        Z3_OP_SEQ_NTH = 1563,

        /// <summary>Z3_OP_SEQ_LENGTH</summary>
        Z3_OP_SEQ_LENGTH = 1564,

        /// <summary>Z3_OP_SEQ_INDEX</summary>
        Z3_OP_SEQ_INDEX = 1565,

        /// <summary>Z3_OP_SEQ_LAST_INDEX</summary>
        Z3_OP_SEQ_LAST_INDEX = 1566,

        /// <summary>Z3_OP_SEQ_TO_RE</summary>
        Z3_OP_SEQ_TO_RE = 1567,

        /// <summary>Z3_OP_SEQ_IN_RE</summary>
        Z3_OP_SEQ_IN_RE = 1568,

        /// <summary>Z3_OP_SEQ_MAP</summary>
        Z3_OP_SEQ_MAP = 1569,

        /// <summary>Z3_OP_SEQ_MAPI</summary>
        Z3_OP_SEQ_MAPI = 1570,

        /// <summary>Z3_OP_SEQ_FOLDL</summary>
        Z3_OP_SEQ_FOLDL = 1571,

        /// <summary>Z3_OP_SEQ_FOLDLI</summary>
        Z3_OP_SEQ_FOLDLI = 1572,

        /// <summary>Z3_OP_STR_TO_INT</summary>
        Z3_OP_STR_TO_INT = 1573,

        /// <summary>Z3_OP_INT_TO_STR</summary>
        Z3_OP_INT_TO_STR = 1574,

        /// <summary>Z3_OP_UBV_TO_STR</summary>
        Z3_OP_UBV_TO_STR = 1575,

        /// <summary>Z3_OP_SBV_TO_STR</summary>
        Z3_OP_SBV_TO_STR = 1576,

        /// <summary>Z3_OP_STR_TO_CODE</summary>
        Z3_OP_STR_TO_CODE = 1577,

        /// <summary>Z3_OP_STR_FROM_CODE</summary>
        Z3_OP_STR_FROM_CODE = 1578,

        /// <summary>Z3_OP_STRING_LT</summary>
        Z3_OP_STRING_LT = 1579,

        /// <summary>Z3_OP_STRING_LE</summary>
        Z3_OP_STRING_LE = 1580,

        /// <summary>Z3_OP_RE_PLUS</summary>
        Z3_OP_RE_PLUS = 1581,

        /// <summary>Z3_OP_RE_STAR</summary>
        Z3_OP_RE_STAR = 1582,

        /// <summary>Z3_OP_RE_OPTION</summary>
        Z3_OP_RE_OPTION = 1583,

        /// <summary>Z3_OP_RE_CONCAT</summary>
        Z3_OP_RE_CONCAT = 1584,

        /// <summary>Z3_OP_RE_UNION</summary>
        Z3_OP_RE_UNION = 1585,

        /// <summary>Z3_OP_RE_RANGE</summary>
        Z3_OP_RE_RANGE = 1586,

        /// <summary>Z3_OP_RE_DIFF</summary>
        Z3_OP_RE_DIFF = 1587,

        /// <summary>Z3_OP_RE_INTERSECT</summary>
        Z3_OP_RE_INTERSECT = 1588,

        /// <summary>Z3_OP_RE_LOOP</summary>
        Z3_OP_RE_LOOP = 1589,

        /// <summary>Z3_OP_RE_POWER</summary>
        Z3_OP_RE_POWER = 1590,

        /// <summary>Z3_OP_RE_COMPLEMENT</summary>
        Z3_OP_RE_COMPLEMENT = 1591,

        /// <summary>Z3_OP_RE_EMPTY_SET</summary>
        Z3_OP_RE_EMPTY_SET = 1592,

        /// <summary>Z3_OP_RE_FULL_SET</summary>
        Z3_OP_RE_FULL_SET = 1593,

        /// <summary>Z3_OP_RE_FULL_CHAR_SET</summary>
        Z3_OP_RE_FULL_CHAR_SET = 1594,

        /// <summary>Z3_OP_RE_OF_PRED</summary>
        Z3_OP_RE_OF_PRED = 1595,

        /// <summary>Z3_OP_RE_REVERSE</summary>
        Z3_OP_RE_REVERSE = 1596,

        /// <summary>Z3_OP_RE_DERIVATIVE</summary>
        Z3_OP_RE_DERIVATIVE = 1597,

        /// <summary>Z3_OP_CHAR_CONST</summary>
        Z3_OP_CHAR_CONST = 1598,

        /// <summary>Z3_OP_CHAR_LE</summary>
        Z3_OP_CHAR_LE = 1599,

        /// <summary>Z3_OP_CHAR_TO_INT</summary>
        Z3_OP_CHAR_TO_INT = 1600,

        /// <summary>Z3_OP_CHAR_TO_BV</summary>
        Z3_OP_CHAR_TO_BV = 1601,

        /// <summary>Z3_OP_CHAR_FROM_BV</summary>
        Z3_OP_CHAR_FROM_BV = 1602,

        /// <summary>Z3_OP_CHAR_IS_DIGIT</summary>
        Z3_OP_CHAR_IS_DIGIT = 1603,

        /// <summary>
        /// Z3_OP_LABEL
        /// </summary>
        /// <remarks>
        /// A label (used by the Boogie Verification condition generator).
        /// The label has two parameters, a string and a Boolean polarity.
        /// It takes one argument, a formula.
        /// </remarks>
        Z3_OP_LABEL = 0x700,

        /// <summary>
        /// Z3_OP_LABEL_LIT
        /// </summary>
        /// <remarks>
        /// A label literal (used by the Boogie Verification condition generator).
        /// A label literal has a set of string parameters. It takes no arguments.
        /// </remarks>
        Z3_OP_LABEL_LIT = 1793,

        /// <summary>
        /// Z3_OP_DT_CONSTRUCTOR
        /// </summary>
        /// <remarks>
        /// datatype constructor.
        /// </remarks>
        Z3_OP_DT_CONSTRUCTOR = 0x800,

        /// <summary>
        /// Z3_OP_DT_RECOGNISER
        /// </summary>
        /// <remarks>
        /// datatype recognizer.
        /// </remarks>
        Z3_OP_DT_RECOGNISER = 2049,

        /// <summary>
        /// Z3_OP_DT_IS
        /// </summary>
        /// <remarks>
        /// datatype recognizer.
        /// </remarks>
        Z3_OP_DT_IS = 2050,

        /// <summary>
        /// Z3_OP_DT_ACCESSOR
        /// </summary>
        /// <remarks>
        /// datatype accessor.
        /// </remarks>
        Z3_OP_DT_ACCESSOR = 2051,

        /// <summary>
        /// Z3_OP_DT_UPDATE_FIELD
        /// </summary>
        /// <remarks>
        /// datatype field update.
        /// </remarks>
        Z3_OP_DT_UPDATE_FIELD = 2052,

        /// <summary>
        /// Z3_OP_PB_AT_MOST
        /// </summary>
        /// <remarks>
        /// Cardinality constraint.
        /// E.g., x + y + z &lt;= 2
        /// </remarks>
        Z3_OP_PB_AT_MOST = 0x900,

        /// <summary>
        /// Z3_OP_PB_AT_LEAST
        /// </summary>
        /// <remarks>
        /// Cardinality constraint.
        /// E.g., x + y + z &gt;= 2
        /// </remarks>
        Z3_OP_PB_AT_LEAST = 2305,

        /// <summary>
        /// Z3_OP_PB_LE
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean cardinality constraint.
        /// Example  2*x + 3*y &lt;= 4
        /// </remarks>
        Z3_OP_PB_LE = 2306,

        /// <summary>
        /// Z3_OP_PB_GE
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean cardinality constraint.
        /// Example  2*x + 3*y + 2*z &gt;= 4
        /// </remarks>
        Z3_OP_PB_GE = 2307,

        /// <summary>
        /// Z3_OP_PB_EQ
        /// </summary>
        /// <remarks>
        /// Generalized Pseudo-Boolean equality constraint.
        /// Example  2*x + 1*y + 2*z + 1*u = 4
        /// </remarks>
        Z3_OP_PB_EQ = 2308,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_LO
        /// </summary>
        /// <remarks>
        /// A relation that is a total linear order
        /// </remarks>
        Z3_OP_SPECIAL_RELATION_LO = 0xa000,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_PO
        /// </summary>
        /// <remarks>
        /// A relation that is a partial order
        /// </remarks>
        Z3_OP_SPECIAL_RELATION_PO = 40961,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_PLO
        /// </summary>
        /// <remarks>
        /// A relation that is a piecewise linear order
        /// </remarks>
        Z3_OP_SPECIAL_RELATION_PLO = 40962,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TO
        /// </summary>
        /// <remarks>
        /// A relation that is a tree order
        /// </remarks>
        Z3_OP_SPECIAL_RELATION_TO = 40963,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TC
        /// </summary>
        /// <remarks>
        /// Transitive closure of a relation
        /// </remarks>
        Z3_OP_SPECIAL_RELATION_TC = 40964,

        /// <summary>
        /// Z3_OP_SPECIAL_RELATION_TRC
        /// </summary>
        /// <remarks>
        /// Transitive reflexive closure of a relation
        /// </remarks>
        Z3_OP_SPECIAL_RELATION_TRC = 40965,

        /// <summary>
        /// Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RNE
        /// </remarks>
        Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN = 0xb000,

        /// <summary>
        /// Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RNA
        /// </remarks>
        Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY = 45057,

        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_POSITIVE
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTP
        /// </remarks>
        Z3_OP_FPA_RM_TOWARD_POSITIVE = 45058,

        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_NEGATIVE
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTN
        /// </remarks>
        Z3_OP_FPA_RM_TOWARD_NEGATIVE = 45059,

        /// <summary>
        /// Z3_OP_FPA_RM_TOWARD_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point rounding mode RTZ
        /// </remarks>
        Z3_OP_FPA_RM_TOWARD_ZERO = 45060,

        /// <summary>
        /// Z3_OP_FPA_NUM
        /// </summary>
        /// <remarks>
        /// Floating-point value
        /// </remarks>
        Z3_OP_FPA_NUM = 45061,

        /// <summary>
        /// Z3_OP_FPA_PLUS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point +oo
        /// </remarks>
        Z3_OP_FPA_PLUS_INF = 45062,

        /// <summary>
        /// Z3_OP_FPA_MINUS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point -oo
        /// </remarks>
        Z3_OP_FPA_MINUS_INF = 45063,

        /// <summary>
        /// Z3_OP_FPA_NAN
        /// </summary>
        /// <remarks>
        /// Floating-point NaN
        /// </remarks>
        Z3_OP_FPA_NAN = 45064,

        /// <summary>
        /// Z3_OP_FPA_PLUS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point +zero
        /// </remarks>
        Z3_OP_FPA_PLUS_ZERO = 45065,

        /// <summary>
        /// Z3_OP_FPA_MINUS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point -zero
        /// </remarks>
        Z3_OP_FPA_MINUS_ZERO = 45066,

        /// <summary>
        /// Z3_OP_FPA_ADD
        /// </summary>
        /// <remarks>
        /// Floating-point addition
        /// </remarks>
        Z3_OP_FPA_ADD = 45067,

        /// <summary>
        /// Z3_OP_FPA_SUB
        /// </summary>
        /// <remarks>
        /// Floating-point subtraction
        /// </remarks>
        Z3_OP_FPA_SUB = 45068,

        /// <summary>
        /// Z3_OP_FPA_NEG
        /// </summary>
        /// <remarks>
        /// Floating-point negation
        /// </remarks>
        Z3_OP_FPA_NEG = 45069,

        /// <summary>
        /// Z3_OP_FPA_MUL
        /// </summary>
        /// <remarks>
        /// Floating-point multiplication
        /// </remarks>
        Z3_OP_FPA_MUL = 45070,

        /// <summary>
        /// Z3_OP_FPA_DIV
        /// </summary>
        /// <remarks>
        /// Floating-point division
        /// </remarks>
        Z3_OP_FPA_DIV = 45071,

        /// <summary>
        /// Z3_OP_FPA_REM
        /// </summary>
        /// <remarks>
        /// Floating-point remainder
        /// </remarks>
        Z3_OP_FPA_REM = 45072,

        /// <summary>
        /// Z3_OP_FPA_ABS
        /// </summary>
        /// <remarks>
        /// Floating-point absolute value
        /// </remarks>
        Z3_OP_FPA_ABS = 45073,

        /// <summary>
        /// Z3_OP_FPA_MIN
        /// </summary>
        /// <remarks>
        /// Floating-point minimum
        /// </remarks>
        Z3_OP_FPA_MIN = 45074,

        /// <summary>
        /// Z3_OP_FPA_MAX
        /// </summary>
        /// <remarks>
        /// Floating-point maximum
        /// </remarks>
        Z3_OP_FPA_MAX = 45075,

        /// <summary>
        /// Z3_OP_FPA_FMA
        /// </summary>
        /// <remarks>
        /// Floating-point fused multiply-add
        /// </remarks>
        Z3_OP_FPA_FMA = 45076,

        /// <summary>
        /// Z3_OP_FPA_SQRT
        /// </summary>
        /// <remarks>
        /// Floating-point square root
        /// </remarks>
        Z3_OP_FPA_SQRT = 45077,

        /// <summary>
        /// Z3_OP_FPA_ROUND_TO_INTEGRAL
        /// </summary>
        /// <remarks>
        /// Floating-point round to integral
        /// </remarks>
        Z3_OP_FPA_ROUND_TO_INTEGRAL = 45078,

        /// <summary>
        /// Z3_OP_FPA_EQ
        /// </summary>
        /// <remarks>
        /// Floating-point equality
        /// </remarks>
        Z3_OP_FPA_EQ = 45079,

        /// <summary>
        /// Z3_OP_FPA_LT
        /// </summary>
        /// <remarks>
        /// Floating-point less than
        /// </remarks>
        Z3_OP_FPA_LT = 45080,

        /// <summary>
        /// Z3_OP_FPA_GT
        /// </summary>
        /// <remarks>
        /// Floating-point greater than
        /// </remarks>
        Z3_OP_FPA_GT = 45081,

        /// <summary>
        /// Z3_OP_FPA_LE
        /// </summary>
        /// <remarks>
        /// Floating-point less than or equal
        /// </remarks>
        Z3_OP_FPA_LE = 45082,

        /// <summary>
        /// Z3_OP_FPA_GE
        /// </summary>
        /// <remarks>
        /// Floating-point greater than or equal
        /// </remarks>
        Z3_OP_FPA_GE = 45083,

        /// <summary>
        /// Z3_OP_FPA_IS_NAN
        /// </summary>
        /// <remarks>
        /// Floating-point isNaN
        /// </remarks>
        Z3_OP_FPA_IS_NAN = 45084,

        /// <summary>
        /// Z3_OP_FPA_IS_INF
        /// </summary>
        /// <remarks>
        /// Floating-point isInfinite
        /// </remarks>
        Z3_OP_FPA_IS_INF = 45085,

        /// <summary>
        /// Z3_OP_FPA_IS_ZERO
        /// </summary>
        /// <remarks>
        /// Floating-point isZero
        /// </remarks>
        Z3_OP_FPA_IS_ZERO = 45086,

        /// <summary>
        /// Z3_OP_FPA_IS_NORMAL
        /// </summary>
        /// <remarks>
        /// Floating-point isNormal
        /// </remarks>
        Z3_OP_FPA_IS_NORMAL = 45087,

        /// <summary>
        /// Z3_OP_FPA_IS_SUBNORMAL
        /// </summary>
        /// <remarks>
        /// Floating-point isSubnormal
        /// </remarks>
        Z3_OP_FPA_IS_SUBNORMAL = 45088,

        /// <summary>
        /// Z3_OP_FPA_IS_NEGATIVE
        /// </summary>
        /// <remarks>
        /// Floating-point isNegative
        /// </remarks>
        Z3_OP_FPA_IS_NEGATIVE = 45089,

        /// <summary>
        /// Z3_OP_FPA_IS_POSITIVE
        /// </summary>
        /// <remarks>
        /// Floating-point isPositive
        /// </remarks>
        Z3_OP_FPA_IS_POSITIVE = 45090,

        /// <summary>
        /// Z3_OP_FPA_FP
        /// </summary>
        /// <remarks>
        /// Floating-point constructor from 3 bit-vectors
        /// </remarks>
        Z3_OP_FPA_FP = 45091,

        /// <summary>
        /// Z3_OP_FPA_TO_FP
        /// </summary>
        /// <remarks>
        /// Floating-point conversion (various)
        /// </remarks>
        Z3_OP_FPA_TO_FP = 45092,

        /// <summary>
        /// Z3_OP_FPA_TO_FP_UNSIGNED
        /// </summary>
        /// <remarks>
        /// Floating-point conversion from unsigned bit-vector
        /// </remarks>
        Z3_OP_FPA_TO_FP_UNSIGNED = 45093,

        /// <summary>
        /// Z3_OP_FPA_TO_UBV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to unsigned bit-vector
        /// </remarks>
        Z3_OP_FPA_TO_UBV = 45094,

        /// <summary>
        /// Z3_OP_FPA_TO_SBV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to signed bit-vector
        /// </remarks>
        Z3_OP_FPA_TO_SBV = 45095,

        /// <summary>
        /// Z3_OP_FPA_TO_REAL
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to real number
        /// </remarks>
        Z3_OP_FPA_TO_REAL = 45096,

        /// <summary>
        /// Z3_OP_FPA_TO_IEEE_BV
        /// </summary>
        /// <remarks>
        /// Floating-point conversion to IEEE-754 bit-vector
        /// </remarks>
        Z3_OP_FPA_TO_IEEE_BV = 45097,

        /// <summary>
        /// Z3_OP_FPA_BVWRAP
        /// </summary>
        /// <remarks>
        /// (Implicitly) represents the internal bitvector-
        /// representation of a floating-point term (used for the lazy encoding
        /// of non-relevant terms in theory_fpa)
        /// </remarks>
        Z3_OP_FPA_BVWRAP = 45098,

        /// <summary>
        /// Z3_OP_FPA_BV2RM
        /// </summary>
        /// <remarks>
        /// <para>
        /// Conversion of a 3-bit bit-vector term to a
        /// floating-point rounding-mode term
        /// </para>
        /// <para>
        /// The conversion uses the following values:
        /// 0 = 000 = Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN,
        /// 1 = 001 = Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY,
        /// 2 = 010 = Z3_OP_FPA_RM_TOWARD_POSITIVE,
        /// 3 = 011 = Z3_OP_FPA_RM_TOWARD_NEGATIVE,
        /// 4 = 100 = Z3_OP_FPA_RM_TOWARD_ZERO.
        /// </para>
        /// </remarks>
        Z3_OP_FPA_BV2RM = 45099,

        /// <summary>
        /// Z3_OP_INTERNAL
        /// </summary>
        /// <remarks>
        /// internal (often interpreted) symbol, but no additional
        /// information is exposed. Tools may use the string representation of the
        /// function declaration to obtain more information.
        /// </remarks>
        Z3_OP_INTERNAL = 45100,

        /// <summary>
        /// Z3_OP_RECURSIVE
        /// </summary>
        /// <remarks>
        /// function declared as recursive
        /// </remarks>
        Z3_OP_RECURSIVE = 45101,

        /// <summary>Z3_OP_UNINTERPRETED</summary>
        Z3_OP_UNINTERPRETED = 45102,
    }

    /// <summary>
    /// Z3 error codes (See <see cref="GetErrorCode"/>).
    /// </summary>
    public enum ErrorCode
    {
        /// <summary>
        /// Z3_OK
        /// </summary>
        /// <remarks>
        /// No error.
        /// </remarks>
        Z3_OK = 0,

        /// <summary>
        /// Z3_SORT_ERROR
        /// </summary>
        /// <remarks>
        /// User tried to build an invalid (type incorrect) AST.
        /// </remarks>
        Z3_SORT_ERROR = 1,

        /// <summary>
        /// Z3_IOB
        /// </summary>
        /// <remarks>
        /// Index out of bounds.
        /// </remarks>
        Z3_IOB = 2,

        /// <summary>
        /// Z3_INVALID_ARG
        /// </summary>
        /// <remarks>
        /// Invalid argument was provided.
        /// </remarks>
        Z3_INVALID_ARG = 3,

        /// <summary>
        /// Z3_PARSER_ERROR
        /// </summary>
        /// <remarks>
        /// An error occurred when parsing a string or file.
        /// </remarks>
        Z3_PARSER_ERROR = 4,

        /// <summary>
        /// Z3_NO_PARSER
        /// </summary>
        /// <remarks>
        /// Parser output is not available, that is, user didn't invoke <see cref="ParseSmtlib2String"/> or <see cref="ParseSmtlib2File"/>.
        /// </remarks>
        Z3_NO_PARSER = 5,

        /// <summary>
        /// Z3_INVALID_PATTERN
        /// </summary>
        /// <remarks>
        /// Invalid pattern was used to build a quantifier.
        /// </remarks>
        Z3_INVALID_PATTERN = 6,

        /// <summary>
        /// Z3_MEMOUT_FAIL
        /// </summary>
        /// <remarks>
        /// A memory allocation failure was encountered.
        /// </remarks>
        Z3_MEMOUT_FAIL = 7,

        /// <summary>
        /// Z3_FILE_ACCESS_ERROR
        /// </summary>
        /// <remarks>
        /// A file could not be accessed.
        /// </remarks>
        Z3_FILE_ACCESS_ERROR = 8,

        /// <summary>
        /// Z3_INTERNAL_FATAL
        /// </summary>
        /// <remarks>
        /// An error internal to Z3 occurred.
        /// </remarks>
        Z3_INTERNAL_FATAL = 9,

        /// <summary>
        /// Z3_INVALID_USAGE
        /// </summary>
        /// <remarks>
        /// API call is invalid in the current state.
        /// </remarks>
        Z3_INVALID_USAGE = 10,

        /// <summary>
        /// Z3_DEC_REF_ERROR
        /// </summary>
        /// <remarks>
        /// Trying to decrement the reference counter of an AST that was deleted or the reference counter was not initialized with <see cref="IncRef"/>.
        /// </remarks>
        Z3_DEC_REF_ERROR = 11,

        /// <summary>Z3_EXCEPTION</summary>
        Z3_EXCEPTION = 12,
    }

    /// <summary>
    /// A Goal is essentially a set of formulas.
    /// Z3 provide APIs for building strategies/tactics for solving and transforming Goals.
    /// Some of these transformations apply under/over approximations.
    /// </summary>
    public enum GoalPrec
    {
        /// <summary>
        /// Z3_GOAL_PRECISE
        /// </summary>
        /// <remarks>
        /// Approximations/Relaxations were not applied on the goal (sat and unsat answers were preserved).
        /// </remarks>
        Z3_GOAL_PRECISE = 0,

        /// <summary>
        /// Z3_GOAL_UNDER
        /// </summary>
        /// <remarks>
        /// Goal is the product of a under-approximation (sat answers are preserved).
        /// </remarks>
        Z3_GOAL_UNDER = 1,

        /// <summary>
        /// Z3_GOAL_OVER
        /// </summary>
        /// <remarks>
        /// Goal is the product of an over-approximation (unsat answers are preserved).
        /// </remarks>
        Z3_GOAL_OVER = 2,

        /// <summary>Z3_GOAL_UNDER_OVER</summary>
        Z3_GOAL_UNDER_OVER = 3,
    }

    /// <summary>
    /// Lifted Boolean type: false, undefined, true.
    /// </summary>
    public enum Lbool
    {
        /// <summary>Z3_L_FALSE</summary>
        Z3_L_FALSE = -1,

        /// <summary>Z3_L_UNDEF</summary>
        Z3_L_UNDEF = 0,

        /// <summary>Z3_L_TRUE</summary>
        Z3_L_TRUE = 1,
    }

    /// <summary>
    /// The different kinds of parameters that can be associated with parameter sets.
    /// (see <see cref="MkParams"/>).
    /// </summary>
    public enum ParamKind
    {
        /// <summary>
        /// Z3_PK_UINT
        /// </summary>
        /// <remarks>
        /// integer parameters.
        /// </remarks>
        Z3_PK_UINT = 0,

        /// <summary>
        /// Z3_PK_BOOL
        /// </summary>
        /// <remarks>
        /// boolean parameters.
        /// </remarks>
        Z3_PK_BOOL = 1,

        /// <summary>
        /// Z3_PK_DOUBLE
        /// </summary>
        /// <remarks>
        /// double parameters.
        /// </remarks>
        Z3_PK_DOUBLE = 2,

        /// <summary>
        /// Z3_PK_SYMBOL
        /// </summary>
        /// <remarks>
        /// symbol parameters.
        /// </remarks>
        Z3_PK_SYMBOL = 3,

        /// <summary>
        /// Z3_PK_STRING
        /// </summary>
        /// <remarks>
        /// string parameters.
        /// </remarks>
        Z3_PK_STRING = 4,

        /// <summary>
        /// Z3_PK_OTHER
        /// </summary>
        /// <remarks>
        /// all internal parameter kinds which are not exposed in the API.
        /// </remarks>
        Z3_PK_OTHER = 5,

        /// <summary>Z3_PK_INVALID</summary>
        Z3_PK_INVALID = 6,
    }

    /// <summary>
    /// The different kinds of parameters that can be associated with function symbols.
    /// </summary>
    /// <seealso cref="GetDeclNumParameters"/>
    /// <seealso cref="GetDeclParameterKind"/>
    public enum ParameterKind
    {
        /// <summary>
        /// Z3_PARAMETER_INT
        /// </summary>
        /// <remarks>
        /// is used for integer parameters.
        /// </remarks>
        Z3_PARAMETER_INT = 0,

        /// <summary>
        /// Z3_PARAMETER_DOUBLE
        /// </summary>
        /// <remarks>
        /// is used for double parameters.
        /// </remarks>
        Z3_PARAMETER_DOUBLE = 1,

        /// <summary>
        /// Z3_PARAMETER_RATIONAL
        /// </summary>
        /// <remarks>
        /// is used for parameters that are rational numbers.
        /// </remarks>
        Z3_PARAMETER_RATIONAL = 2,

        /// <summary>
        /// Z3_PARAMETER_SYMBOL
        /// </summary>
        /// <remarks>
        /// is used for parameters that are symbols.
        /// </remarks>
        Z3_PARAMETER_SYMBOL = 3,

        /// <summary>
        /// Z3_PARAMETER_SORT
        /// </summary>
        /// <remarks>
        /// is used for sort parameters.
        /// </remarks>
        Z3_PARAMETER_SORT = 4,

        /// <summary>
        /// Z3_PARAMETER_AST
        /// </summary>
        /// <remarks>
        /// is used for expression parameters.
        /// </remarks>
        Z3_PARAMETER_AST = 5,

        /// <summary>
        /// Z3_PARAMETER_FUNC_DECL
        /// </summary>
        /// <remarks>
        /// is used for function declaration parameters.
        /// </remarks>
        Z3_PARAMETER_FUNC_DECL = 6,

        /// <summary>
        /// Z3_PARAMETER_INTERNAL
        /// </summary>
        /// <remarks>
        /// is used for parameters that are private to Z3. They cannot be accessed.
        /// </remarks>
        Z3_PARAMETER_INTERNAL = 7,

        /// <summary>Z3_PARAMETER_ZSTRING</summary>
        Z3_PARAMETER_ZSTRING = 8,
    }

    /// <summary>
    /// The different kinds of Z3 types (See <see cref="GetSortKind"/>).
    /// </summary>
    public enum SortKind
    {
        /// <summary>Z3_UNINTERPRETED_SORT</summary>
        Z3_UNINTERPRETED_SORT = 0,

        /// <summary>Z3_BOOL_SORT</summary>
        Z3_BOOL_SORT = 1,

        /// <summary>Z3_INT_SORT</summary>
        Z3_INT_SORT = 2,

        /// <summary>Z3_REAL_SORT</summary>
        Z3_REAL_SORT = 3,

        /// <summary>Z3_BV_SORT</summary>
        Z3_BV_SORT = 4,

        /// <summary>Z3_ARRAY_SORT</summary>
        Z3_ARRAY_SORT = 5,

        /// <summary>Z3_DATATYPE_SORT</summary>
        Z3_DATATYPE_SORT = 6,

        /// <summary>Z3_RELATION_SORT</summary>
        Z3_RELATION_SORT = 7,

        /// <summary>Z3_FINITE_DOMAIN_SORT</summary>
        Z3_FINITE_DOMAIN_SORT = 8,

        /// <summary>Z3_FLOATING_POINT_SORT</summary>
        Z3_FLOATING_POINT_SORT = 9,

        /// <summary>Z3_ROUNDING_MODE_SORT</summary>
        Z3_ROUNDING_MODE_SORT = 10,

        /// <summary>Z3_SEQ_SORT</summary>
        Z3_SEQ_SORT = 11,

        /// <summary>Z3_RE_SORT</summary>
        Z3_RE_SORT = 12,

        /// <summary>Z3_CHAR_SORT</summary>
        Z3_CHAR_SORT = 13,

        /// <summary>Z3_TYPE_VAR</summary>
        Z3_TYPE_VAR = 14,

        /// <summary>Z3_UNKNOWN_SORT</summary>
        Z3_UNKNOWN_SORT = 1000,
    }

    /// <summary>
    /// The different kinds of symbol.
    /// In Z3, a symbol can be represented using integers and strings (See <see cref="GetSymbolKind"/>).
    /// </summary>
    /// <seealso cref="MkIntSymbol"/>
    /// <seealso cref="MkStringSymbol"/>
    public enum SymbolKind
    {
        /// <summary>Z3_INT_SYMBOL</summary>
        Z3_INT_SYMBOL = 0,

        /// <summary>Z3_STRING_SYMBOL</summary>
        Z3_STRING_SYMBOL = 1,
    }
}
