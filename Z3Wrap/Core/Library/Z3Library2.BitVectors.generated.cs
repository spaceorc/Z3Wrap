// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.BitVectors.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    /// <para>
    /// Bitwise negation.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvnot(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvnot(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnot));
    }

    /// <summary>
    /// <para>
    /// Take conjunction of bits in vector, return vector of length 1.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvredand(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvredand(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvredand));
    }

    /// <summary>
    /// <para>
    /// Take disjunction of bits in vector, return vector of length 1.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvredor(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvredor(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvredor));
    }

    /// <summary>
    /// <para>
    /// Bitwise and.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvand(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvand));
    }

    /// <summary>
    /// <para>
    /// Bitwise or.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvor));
    }

    /// <summary>
    /// <para>
    /// Bitwise exclusive-or.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvxor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvxor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvxor));
    }

    /// <summary>
    /// <para>
    /// Bitwise nand.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvnand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvnand(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnand));
    }

    /// <summary>
    /// <para>
    /// Bitwise nor.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvnor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnor));
    }

    /// <summary>
    /// <para>
    /// Bitwise xnor.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvxnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvxnor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvxnor));
    }

    /// <summary>
    /// <para>
    /// Standard two's complement unary minus.
    /// </para>
    /// <para>
    /// The node t1 must have bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvneg(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvneg(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvneg));
    }

    /// <summary>
    /// <para>
    /// Standard two's complement addition.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvadd(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvadd(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvadd));
    }

    /// <summary>
    /// <para>
    /// Standard two's complement subtraction.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvsub(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsub(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsub));
    }

    /// <summary>
    /// <para>
    /// Standard two's complement multiplication.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvmul(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvmul(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvmul));
    }

    /// <summary>
    /// <para>
    /// Unsigned division.
    /// </para>
    /// <para>
    /// It is defined as the floor of
    /// <code>
    /// t1/t2
    /// </code>
    /// if t2 is
    /// different from zero. If
    /// <code>
    /// t2
    /// </code>
    /// is zero, then the result
    /// is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvudiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvudiv(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvudiv));
    }

    /// <summary>
    /// <para>
    /// Two's complement signed division.
    /// </para>
    /// <para>
    /// It is defined in the following way:
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item>
    /// <description>
    /// The floor of
    /// <code>
    /// t1/t2
    /// </code>
    /// if t2 is different from zero, and
    /// <code>
    /// t1*t2 &gt;= 0
    /// </code>
    /// .
    /// </description>
    /// </item>
    /// </list>
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item>
    /// <description>
    /// The ceiling of
    /// <code>
    /// t1/t2
    /// </code>
    /// if t2 is different from zero, and
    /// <code>
    /// t1*t2 &lt; 0
    /// </code>
    /// .
    /// </description>
    /// </item>
    /// </list>
    /// </para>
    /// <para>
    /// If
    /// <code>
    /// t2
    /// </code>
    /// is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvsdiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsdiv(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsdiv));
    }

    /// <summary>
    /// <para>
    /// Unsigned remainder.
    /// </para>
    /// <para>
    /// It is defined as
    /// <code>
    /// t1 - (t1 /u t2) * t2
    /// </code>
    /// , where
    /// <code>
    /// /u
    /// </code>
    /// represents unsigned division.
    /// </para>
    /// <para>
    /// If
    /// <code>
    /// t2
    /// </code>
    /// is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvurem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvurem(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvurem));
    }

    /// <summary>
    /// <para>
    /// Two's complement signed remainder (sign follows dividend).
    /// </para>
    /// <para>
    /// It is defined as
    /// <code>
    /// t1 - (t1 /s t2) * t2
    /// </code>
    /// , where
    /// <code>
    /// /s
    /// </code>
    /// represents signed division.
    /// The most significant bit (sign) of the result is equal to the most significant bit of t1.
    /// </para>
    /// <para>
    /// If
    /// <code>
    /// t2
    /// </code>
    /// is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="MkBvsmod"/>
    public IntPtr MkBvsrem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsrem(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsrem));
    }

    /// <summary>
    /// <para>
    /// Two's complement signed remainder (sign follows divisor).
    /// </para>
    /// <para>
    /// If
    /// <code>
    /// t2
    /// </code>
    /// is zero, then the result is undefined.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <seealso cref="MkBvsrem"/>
    public IntPtr MkBvsmod(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsmod(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsmod));
    }

    /// <summary>
    /// <para>
    /// Unsigned less than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvult(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvult(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvult));
    }

    /// <summary>
    /// <para>
    /// Two's complement signed less than.
    /// </para>
    /// <para>
    /// It abbreviates:
    /// <code>
    /// (or (and (= (extract[|m-1|:|m-1|] t1) bit1)
    /// (= (extract[|m-1|:|m-1|] t2) bit0))
    /// (and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
    /// (bvult t1 t2)))
    /// </code>
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvslt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvslt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvslt));
    }

    /// <summary>
    /// <para>
    /// Unsigned less than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvule(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvule(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvule));
    }

    /// <summary>
    /// <para>
    /// Two's complement signed less than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvsle(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsle(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsle));
    }

    /// <summary>
    /// <para>
    /// Unsigned greater than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvuge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvuge(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvuge));
    }

    /// <summary>
    /// <para>
    /// Two's complement signed greater than or equal to.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvsge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsge(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsge));
    }

    /// <summary>
    /// <para>
    /// Unsigned greater than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvugt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvugt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvugt));
    }

    /// <summary>
    /// <para>
    /// Two's complement signed greater than.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvsgt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsgt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsgt));
    }

    /// <summary>
    /// <para>
    /// Concatenate the given bit-vectors.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have (possibly different) bit-vector sorts
    /// </para>
    /// <para>
    /// The result is a bit-vector of size
    /// <code>
    /// n1+n2
    /// </code>
    /// , where n1 (n2) is the size
    /// of t1 (t2).
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkConcat(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkConcat(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkConcat));
    }

    /// <summary>
    /// <para>
    /// Extract the bits high down to low from a bit-vector of
    /// size m to yield a new bit-vector of size n, where
    /// <code>
    /// n = high - low + 1
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="high" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="low" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkExtract(IntPtr c, uint high, uint low, IntPtr t1)
    {
        var result = nativeLibrary.MkExtract(c, high, low, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkExtract));
    }

    /// <summary>
    /// <para>
    /// Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of
    /// size
    /// <code>
    /// m+i
    /// </code>
    /// , where m is the size of the given
    /// bit-vector.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkSignExt(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkSignExt(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkSignExt));
    }

    /// <summary>
    /// <para>
    /// Extend the given bit-vector with zeros to the (unsigned) equivalent
    /// bit-vector of size
    /// <code>
    /// m+i
    /// </code>
    /// , where m is the size of the
    /// given bit-vector.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkZeroExt(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkZeroExt(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkZeroExt));
    }

    /// <summary>
    /// <para>
    /// Repeat the given bit-vector up length
    /// <code>
    /// i
    /// </code>
    /// .
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkRepeat(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkRepeat(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkRepeat));
    }

    /// <summary>
    /// <para>
    /// Extracts the bit at position
    /// <code>
    /// i
    /// </code>
    /// of a bit-vector and
    /// yields a boolean.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBit2bool(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkBit2bool(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBit2bool));
    }

    /// <summary>
    /// <para>
    /// Shift left.
    /// </para>
    /// <para>
    /// It is equivalent to multiplication by
    /// <code>
    /// 2^x
    /// </code>
    /// where x is the value of the
    /// third argument.
    /// </para>
    /// <para>
    /// NB. The semantics of shift operations varies between environments. This
    /// definition does not necessarily capture directly the semantics of the
    /// programming language or assembly architecture you are modeling.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvshl(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvshl(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvshl));
    }

    /// <summary>
    /// <para>
    /// Logical shift right.
    /// </para>
    /// <para>
    /// It is equivalent to unsigned division by
    /// <code>
    /// 2^x
    /// </code>
    /// where x is the
    /// value of the third argument.
    /// </para>
    /// <para>
    /// NB. The semantics of shift operations varies between environments. This
    /// definition does not necessarily capture directly the semantics of the
    /// programming language or assembly architecture you are modeling.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvlshr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvlshr(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvlshr));
    }

    /// <summary>
    /// <para>
    /// Arithmetic shift right.
    /// </para>
    /// <para>
    /// It is like logical shift right except that the most significant
    /// bits of the result always copy the most significant bit of the
    /// second argument.
    /// </para>
    /// <para>
    /// The semantics of shift operations varies between environments. This
    /// definition does not necessarily capture directly the semantics of the
    /// programming language or assembly architecture you are modeling.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvashr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvashr(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvashr));
    }

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the left i times.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkRotateLeft(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkRotateLeft(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkRotateLeft));
    }

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the right i times.
    /// </para>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="i" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkRotateRight(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkRotateRight(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkRotateRight));
    }

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the left t2 times.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkExtRotateLeft(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkExtRotateLeft(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkExtRotateLeft));
    }

    /// <summary>
    /// <para>
    /// Rotate bits of t1 to the right t2 times.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkExtRotateRight(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkExtRotateRight(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkExtRotateRight));
    }

    /// <summary>
    /// <para>
    /// Create an n bit bit-vector from the integer argument t1.
    /// </para>
    /// <para>
    /// The resulting bit-vector has n bits, where the i'th bit (counting
    /// from 0 to n-1) is 1 if \c (t1 div 2^i) mod 2 is 1.
    /// </para>
    /// <para>
    /// The node t1 must have integer sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="n" ctype="unsigned">
    /// unsigned parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkInt2bv(IntPtr c, uint n, IntPtr t1)
    {
        var result = nativeLibrary.MkInt2bv(c, n, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkInt2bv));
    }

    /// <summary>
    /// <para>
    /// Create an integer from the bit-vector argument t1.
    /// If is_signed is false, then the bit-vector t1 is treated as unsigned.
    /// So the result is non-negative
    /// and in the range
    /// <code>
    /// [0..2^N-1]
    /// </code>
    /// , where N are the number of bits in t1.
    /// If is_signed is true, t1 is treated as a signed bit-vector.
    /// </para>
    /// <para/>
    /// <para>
    /// The node t1 must have a bit-vector sort.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="isSigned" ctype="bool">
    /// bool parameter
    /// </param>
    public IntPtr MkBv2int(IntPtr c, IntPtr t1, bool isSigned)
    {
        var result = nativeLibrary.MkBv2int(c, t1, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBv2int));
    }

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise addition
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="isSigned" ctype="bool">
    /// bool parameter
    /// </param>
    public IntPtr MkBvaddNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var result = nativeLibrary.MkBvaddNoOverflow(c, t1, t2, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvaddNoOverflow));
    }

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed addition
    /// of t1 and t2 does not underflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvaddNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvaddNoUnderflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvaddNoUnderflow));
    }

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed subtraction
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvsubNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsubNoOverflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsubNoOverflow));
    }

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise subtraction
    /// of t1 and t2 does not underflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="isSigned" ctype="bool">
    /// bool parameter
    /// </param>
    public IntPtr MkBvsubNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var result = nativeLibrary.MkBvsubNoUnderflow(c, t1, t2, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsubNoUnderflow));
    }

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed division
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvsdivNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsdivNoOverflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsdivNoOverflow));
    }

    /// <summary>
    /// <para>
    /// Check that bit-wise negation does not overflow when
    /// t1 is interpreted as a signed bit-vector.
    /// </para>
    /// <para>
    /// The node t1 must have bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvnegNoOverflow(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvnegNoOverflow(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnegNoOverflow));
    }

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise multiplication
    /// of t1 and t2 does not overflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="isSigned" ctype="bool">
    /// bool parameter
    /// </param>
    public IntPtr MkBvmulNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var result = nativeLibrary.MkBvmulNoOverflow(c, t1, t2, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvmulNoOverflow));
    }

    /// <summary>
    /// <para>
    /// Create a predicate that checks that the bit-wise signed multiplication
    /// of t1 and t2 does not underflow.
    /// </para>
    /// <para>
    /// The nodes t1 and t2 must have the same bit-vector sort.
    /// The returned node is of sort Bool.
    /// </para>
    /// </summary>
    /// <param name="c" ctype="Z3_context">
    /// context parameter
    /// </param>
    /// <param name="t1" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    /// <param name="t2" ctype="Z3_ast">
    /// ast parameter
    /// </param>
    public IntPtr MkBvmulNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvmulNoUnderflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvmulNoUnderflow));
    }

}
