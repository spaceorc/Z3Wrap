// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.BitVectors.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core.Library;

public sealed partial class Z3Library2
{
    /// <summary>
    ///  Bitwise negation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkBvnot(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvnot(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnot));
    }

    /// <summary>
    ///  Take conjunction of bits in vector, return vector of length 1.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkBvredand(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvredand(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvredand));
    }

    /// <summary>
    ///  Take disjunction of bits in vector, return vector of length 1.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkBvredor(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvredor(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvredor));
    }

    /// <summary>
    ///  Bitwise and.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvand(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvand));
    }

    /// <summary>
    ///  Bitwise or.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvor));
    }

    /// <summary>
    ///  Bitwise exclusive-or.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvxor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvxor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvxor));
    }

    /// <summary>
    ///  Bitwise nand.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvnand(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvnand(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnand));
    }

    /// <summary>
    ///  Bitwise nor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvnor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnor));
    }

    /// <summary>
    ///  Bitwise xnor.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvxnor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvxnor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvxnor));
    }

    /// <summary>
    ///  Standard two's complement unary minus.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have bit-vector sort.
    /// </remarks>
    public IntPtr MkBvneg(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvneg(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvneg));
    }

    /// <summary>
    ///  Standard two's complement addition.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvadd(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvadd(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvadd));
    }

    /// <summary>
    ///  Standard two's complement subtraction.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvsub(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsub(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsub));
    }

    /// <summary>
    ///  Standard two's complement multiplication.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvmul(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvmul(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvmul));
    }

    /// <summary>
    ///  Unsigned division.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It is defined as the <c>floor</c> of <c>t1/t2</c> if <c>t2</c> is different from zero. If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvudiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvudiv(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvudiv));
    }

    /// <summary>
    ///  Two's complement signed division.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It is defined in the following way:  The <c>floor</c> of <c>t1/t2</c> if <c>t2</c> is different from zero, and <c>t1*t2 &gt;= 0</c> .  The <c>ceiling</c> of <c>t1/t2</c> if <c>t2</c> is different from zero, and <c>t1*t2 &lt; 0</c> .   If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvsdiv(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsdiv(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsdiv));
    }

    /// <summary>
    ///  Unsigned remainder.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It is defined as <c>t1 - (t1 /u t2) * t2</c> , where <c>/u</c> represents unsigned division. If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvurem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvurem(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvurem));
    }

    /// <summary>
    ///  Two's complement signed remainder (sign follows dividend).
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It is defined as <c>t1 - (t1 /s t2) * t2</c> , where <c>/s</c> represents signed division. The most significant bit (sign) of the result is equal to the most significant bit of <c>t1</c> . If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    /// <seealso cref="MkBvsmod"/>
    public IntPtr MkBvsrem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsrem(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsrem));
    }

    /// <summary>
    ///  Two's complement signed remainder (sign follows divisor).
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// If <c>t2</c> is zero, then the result is undefined. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    /// <seealso cref="MkBvsrem"/>
    public IntPtr MkBvsmod(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsmod(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsmod));
    }

    /// <summary>
    ///  Unsigned less than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvult(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvult(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvult));
    }

    /// <summary>
    ///  Two's complement signed less than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It abbreviates: <code>
    /// (or (and (= (extract[|m-1|:|m-1|] t1) bit1)
    /// (= (extract[|m-1|:|m-1|] t2) bit0))
    /// (and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
    /// (bvult t1 t2)))
    /// </code> The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvslt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvslt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvslt));
    }

    /// <summary>
    ///  Unsigned less than or equal to.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvule(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvule(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvule));
    }

    /// <summary>
    ///  Two's complement signed less than or equal to.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvsle(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsle(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsle));
    }

    /// <summary>
    ///  Unsigned greater than or equal to.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvuge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvuge(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvuge));
    }

    /// <summary>
    ///  Two's complement signed greater than or equal to.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvsge(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsge(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsge));
    }

    /// <summary>
    ///  Unsigned greater than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvugt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvugt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvugt));
    }

    /// <summary>
    ///  Two's complement signed greater than.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvsgt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsgt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsgt));
    }

    /// <summary>
    ///  Concatenate the given bit-vectors.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have (possibly different) bit-vector sorts The result is a bit-vector of size <c>n1+n2</c> , where <c>n1</c> ( <c>n2</c> ) is the size of <c>t1</c> ( <c>t2</c> ).
    /// </remarks>
    public IntPtr MkConcat(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkConcat(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkConcat));
    }

    /// <summary>
    ///  Extract the bits <c>high</c> down to <c>low</c> from a bit-vector of size <c>m</c> to yield a new bit-vector of size <c>n</c> , where <c>n = high - low + 1</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="high" ctype="unsigned">unsigned parameter</param>
    /// <param name="low" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkExtract(IntPtr c, uint high, uint low, IntPtr t1)
    {
        var result = nativeLibrary.MkExtract(c, high, low, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkExtract));
    }

    /// <summary>
    ///  Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of size <c>m+i</c> , where <c>m</c> is the size of the given bit-vector.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkSignExt(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkSignExt(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkSignExt));
    }

    /// <summary>
    ///  Extend the given bit-vector with zeros to the (unsigned) equivalent bit-vector of size <c>m+i</c> , where <c>m</c> is the size of the given bit-vector.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkZeroExt(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkZeroExt(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkZeroExt));
    }

    /// <summary>
    ///  Repeat the given bit-vector up length <c>i</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkRepeat(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkRepeat(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkRepeat));
    }

    /// <summary>
    ///  Extracts the bit at position <c>i</c> of a bit-vector and yields a boolean.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkBit2bool(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkBit2bool(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBit2bool));
    }

    /// <summary>
    ///  Shift left.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It is equivalent to multiplication by <c>2^x</c> where <c>x</c> is the value of the third argument. NB. The semantics of shift operations varies between environments. This definition does not necessarily capture directly the semantics of the programming language or assembly architecture you are modeling. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvshl(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvshl(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvshl));
    }

    /// <summary>
    ///  Logical shift right.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It is equivalent to unsigned division by <c>2^x</c> where <c>x</c> is the value of the third argument. NB. The semantics of shift operations varies between environments. This definition does not necessarily capture directly the semantics of the programming language or assembly architecture you are modeling. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvlshr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvlshr(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvlshr));
    }

    /// <summary>
    ///  Arithmetic shift right.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// It is like logical shift right except that the most significant bits of the result always copy the most significant bit of the second argument. The semantics of shift operations varies between environments. This definition does not necessarily capture directly the semantics of the programming language or assembly architecture you are modeling. The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkBvashr(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvashr(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvashr));
    }

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the left <c>i</c> times.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkRotateLeft(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkRotateLeft(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkRotateLeft));
    }

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the right <c>i</c> times.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="i" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkRotateRight(IntPtr c, uint i, IntPtr t1)
    {
        var result = nativeLibrary.MkRotateRight(c, i, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkRotateRight));
    }

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the left <c>t2</c> times.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkExtRotateLeft(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkExtRotateLeft(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkExtRotateLeft));
    }

    /// <summary>
    ///  Rotate bits of <c>t1</c> to the right <c>t2</c> times.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort.
    /// </remarks>
    public IntPtr MkExtRotateRight(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkExtRotateRight(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkExtRotateRight));
    }

    /// <summary>
    ///  Create an <c>n</c> bit bit-vector from the integer argument <c>t1</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The resulting bit-vector has <c>n</c> bits, where the i'th bit (counting from 0 to <c>n-1</c> ) is 1 if (t1 div 2^i) mod 2 is 1.  The node <c>t1</c> must have integer sort.
    /// </remarks>
    public IntPtr MkInt2bv(IntPtr c, uint n, IntPtr t1)
    {
        var result = nativeLibrary.MkInt2bv(c, n, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkInt2bv));
    }

    /// <summary>
    ///  Create an integer from the bit-vector argument <c>t1</c> . If <c>is_signed</c> is false, then the bit-vector <c>t1</c> is treated as unsigned. So the result is non-negative and in the range <c>[0..2^N-1]</c> , where N are the number of bits in <c>t1</c> . If <c>is_signed</c> is true, <c>t1</c> is treated as a signed bit-vector.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have a bit-vector sort.
    /// </remarks>
    public IntPtr MkBv2int(IntPtr c, IntPtr t1, bool isSigned)
    {
        var result = nativeLibrary.MkBv2int(c, t1, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBv2int));
    }

    /// <summary>
    ///  Create a predicate that checks that the bit-wise addition of <c>t1</c> and <c>t2</c> does not overflow.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvaddNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var result = nativeLibrary.MkBvaddNoOverflow(c, t1, t2, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvaddNoOverflow));
    }

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed addition of <c>t1</c> and <c>t2</c> does not underflow.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvaddNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvaddNoUnderflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvaddNoUnderflow));
    }

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed subtraction of <c>t1</c> and <c>t2</c> does not overflow.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvsubNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsubNoOverflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsubNoOverflow));
    }

    /// <summary>
    ///  Create a predicate that checks that the bit-wise subtraction of <c>t1</c> and <c>t2</c> does not underflow.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvsubNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var result = nativeLibrary.MkBvsubNoUnderflow(c, t1, t2, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsubNoUnderflow));
    }

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed division of <c>t1</c> and <c>t2</c> does not overflow.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvsdivNoOverflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvsdivNoOverflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvsdivNoOverflow));
    }

    /// <summary>
    ///  Check that bit-wise negation does not overflow when <c>t1</c> is interpreted as a signed bit-vector.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The node <c>t1</c> must have bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvnegNoOverflow(IntPtr c, IntPtr t1)
    {
        var result = nativeLibrary.MkBvnegNoOverflow(c, t1);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvnegNoOverflow));
    }

    /// <summary>
    ///  Create a predicate that checks that the bit-wise multiplication of <c>t1</c> and <c>t2</c> does not overflow.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="isSigned" ctype="bool">bool parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvmulNoOverflow(IntPtr c, IntPtr t1, IntPtr t2, bool isSigned)
    {
        var result = nativeLibrary.MkBvmulNoOverflow(c, t1, t2, isSigned);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvmulNoOverflow));
    }

    /// <summary>
    ///  Create a predicate that checks that the bit-wise signed multiplication of <c>t1</c> and <c>t2</c> does not underflow.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have the same bit-vector sort. The returned node is of sort Bool.
    /// </remarks>
    public IntPtr MkBvmulNoUnderflow(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkBvmulNoUnderflow(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkBvmulNoUnderflow));
    }

}
