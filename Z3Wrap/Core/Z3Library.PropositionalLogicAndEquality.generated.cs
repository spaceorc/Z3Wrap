// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.PropositionalLogicAndEquality.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Create an AST node representing <c>true</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkTrue(IntPtr c)
    {
        var result = nativeLibrary.MkTrue(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkTrue));
    }

    /// <summary>
    ///  Create an AST node representing <c>false</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkFalse(IntPtr c)
    {
        var result = nativeLibrary.MkFalse(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFalse));
    }

    /// <summary>
    ///  Create an AST node representing <c>l = r</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="l" ctype="Z3_ast">ast parameter</param>
    /// <param name="r" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>l</c> and <c>r</c> must have the same type.
    /// </remarks>
    public IntPtr MkEq(IntPtr c, IntPtr l, IntPtr r)
    {
        var result = nativeLibrary.MkEq(c, l, r);
        CheckError(c);
        return CheckHandle(result, nameof(MkEq));
    }

    /// <summary>
    ///  Create an AST node representing <c>distinct(args[0], ..., args[num_args-1])</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The <c>distinct</c> construct is used for declaring the arguments pairwise distinct. That is, <c>Forall 0 &lt;= i &lt; j &lt; num_args. not args[i] = args[j]</c> . All arguments must have the same sort.
    /// The number of arguments of a distinct construct must be greater than one.
    /// </remarks>
    public IntPtr MkDistinct(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkDistinct(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkDistinct));
    }

    /// <summary>
    ///  Create an AST node representing <c>not(a)</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>a</c> must have Boolean sort.
    /// </remarks>
    public IntPtr MkNot(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.MkNot(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(MkNot));
    }

    /// <summary>
    ///  Create an AST node representing an if-then-else: <c>ite(t1, t2, t3)</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <param name="t3" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The node <c>t1</c> must have Boolean sort, <c>t2</c> and <c>t3</c> must have the same sort. The sort of the new node is equal to the sort of <c>t2</c> and <c>t3</c> .
    /// </remarks>
    public IntPtr MkIte(IntPtr c, IntPtr t1, IntPtr t2, IntPtr t3)
    {
        var result = nativeLibrary.MkIte(c, t1, t2, t3);
        CheckError(c);
        return CheckHandle(result, nameof(MkIte));
    }

    /// <summary>
    ///  Create an AST node representing <c>t1 iff t2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have Boolean sort.
    /// </remarks>
    public IntPtr MkIff(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkIff(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkIff));
    }

    /// <summary>
    ///  Create an AST node representing <c>t1 implies t2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have Boolean sort.
    /// </remarks>
    public IntPtr MkImplies(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkImplies(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkImplies));
    }

    /// <summary>
    ///  Create an AST node representing <c>t1 xor t2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t1" ctype="Z3_ast">ast parameter</param>
    /// <param name="t2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>t1</c> and <c>t2</c> must have Boolean sort.
    /// </remarks>
    public IntPtr MkXor(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkXor(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkXor));
    }

    /// <summary>
    ///  Create an AST node representing <c>args[0] and ... and args[num_args-1]</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The array <c>args</c> must have <c>num_args</c> elements. All arguments must have Boolean sort.
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkAnd(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkAnd(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkAnd));
    }

    /// <summary>
    ///  Create an AST node representing <c>args[0] or ... or args[num_args-1]</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="numArgs" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The array <c>args</c> must have <c>num_args</c> elements. All arguments must have Boolean sort.
    /// The number of arguments must be greater than zero.
    /// </remarks>
    public IntPtr MkOr(IntPtr c, uint numArgs, IntPtr[] args)
    {
        var result = nativeLibrary.MkOr(c, numArgs, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkOr));
    }

}
