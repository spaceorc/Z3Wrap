// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.FloatingPointArithmetic.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Create the RoundingMode sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRtp"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRoundingModeSort(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundingModeSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundingModeSort));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRne"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundNearestTiesToEven(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundNearestTiesToEven(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundNearestTiesToEven));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRoundNearestTiesToEven"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtp"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRne(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRne(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRne));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRna"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundNearestTiesToAway(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundNearestTiesToAway(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundNearestTiesToAway));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRoundNearestTiesToAway"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtp"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRna(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRna(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRna));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRtp"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundTowardPositive(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundTowardPositive(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundTowardPositive));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRoundTowardPositive"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRtp(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRtp(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRtp));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRtn"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    /// <seealso cref="MkFpaRoundTowardZero"/>
    public IntPtr MkFpaRoundTowardNegative(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundTowardNegative(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundTowardNegative));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRoundTowardNegative"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtp"/>
    /// <seealso cref="MkFpaRtz"/>
    public IntPtr MkFpaRtn(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRtn(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRtn));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRtz"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRoundNearestTiesToAway"/>
    /// <seealso cref="MkFpaRoundNearestTiesToEven"/>
    /// <seealso cref="MkFpaRoundTowardNegative"/>
    /// <seealso cref="MkFpaRoundTowardPositive"/>
    public IntPtr MkFpaRoundTowardZero(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRoundTowardZero(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundTowardZero));
    }

    /// <summary>
    ///  Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaRoundTowardZero"/> .
    /// </remarks>
    /// <seealso cref="MkFpaRoundingModeSort"/>
    /// <seealso cref="MkFpaRna"/>
    /// <seealso cref="MkFpaRne"/>
    /// <seealso cref="MkFpaRtn"/>
    /// <seealso cref="MkFpaRtp"/>
    public IntPtr MkFpaRtz(IntPtr c)
    {
        var result = nativeLibrary.MkFpaRtz(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRtz));
    }

    /// <summary>
    ///  Create a FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="ebits" ctype="unsigned"> number of exponent bits </param>
    /// <param name="sbits" ctype="unsigned"> number of significand bits </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// <c>ebits</c> must be larger than 1 and <c>sbits</c> must be larger than 2.
    /// </remarks>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSort16"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSort32"/>
    /// <seealso cref="MkFpaSortDouble"/>
    /// <seealso cref="MkFpaSort64"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    /// <seealso cref="MkFpaSort128"/>
    public IntPtr MkFpaSort(IntPtr c, uint ebits, uint sbits)
    {
        var result = nativeLibrary.MkFpaSort(c, ebits, sbits);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort));
    }

    /// <summary>
    ///  Create the half-precision (16-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSort16"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSortDouble"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    public IntPtr MkFpaSortHalf(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortHalf(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortHalf));
    }

    /// <summary>
    ///  Create the half-precision (16-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSortHalf"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort32"/>
    /// <seealso cref="MkFpaSort64"/>
    /// <seealso cref="MkFpaSort128"/>
    public IntPtr MkFpaSort16(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort16(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort16));
    }

    /// <summary>
    ///  Create the single-precision (32-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context. </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSort32"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSortDouble"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    public IntPtr MkFpaSortSingle(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortSingle(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortSingle));
    }

    /// <summary>
    ///  Create the single-precision (32-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSortSingle"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort16"/>
    /// <seealso cref="MkFpaSort64"/>
    /// <seealso cref="MkFpaSort128"/>
    public IntPtr MkFpaSort32(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort32(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort32));
    }

    /// <summary>
    ///  Create the double-precision (64-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSort64"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSortQuadruple"/>
    public IntPtr MkFpaSortDouble(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortDouble(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortDouble));
    }

    /// <summary>
    ///  Create the double-precision (64-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSortDouble"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort16"/>
    /// <seealso cref="MkFpaSort32"/>
    /// <seealso cref="MkFpaSort128"/>
    public IntPtr MkFpaSort64(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort64(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort64));
    }

    /// <summary>
    ///  Create the quadruple-precision (128-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSort128"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSortHalf"/>
    /// <seealso cref="MkFpaSortSingle"/>
    /// <seealso cref="MkFpaSortDouble"/>
    public IntPtr MkFpaSortQuadruple(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSortQuadruple(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSortQuadruple));
    }

    /// <summary>
    ///  Create the quadruple-precision (128-bit) FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// This is the same as <see cref="MkFpaSortQuadruple"/> .
    /// </remarks>
    /// <seealso cref="MkFpaSort"/>
    /// <seealso cref="MkFpaSort16"/>
    /// <seealso cref="MkFpaSort32"/>
    /// <seealso cref="MkFpaSort64"/>
    public IntPtr MkFpaSort128(IntPtr c)
    {
        var result = nativeLibrary.MkFpaSort128(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSort128));
    }

    /// <summary>
    ///  Create a floating-point NaN of sort <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="s" ctype="Z3_sort"> target sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <seealso cref="MkFpaInf"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaZero"/>
    public IntPtr MkFpaNan(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkFpaNan(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNan));
    }

    /// <summary>
    ///  Create a floating-point infinity of sort <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="s" ctype="Z3_sort"> target sort </param>
    /// <param name="negative" ctype="bool"> indicates whether the result should be negative </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// When <c>negative</c> is <c>true</c> , -oo will be generated instead of +oo.
    /// </remarks>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaNan"/>
    /// <seealso cref="MkFpaZero"/>
    public IntPtr MkFpaInf(IntPtr c, IntPtr s, bool negative)
    {
        var result = nativeLibrary.MkFpaInf(c, s, negative);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaInf));
    }

    /// <summary>
    ///  Create a floating-point zero of sort <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="s" ctype="Z3_sort"> target sort </param>
    /// <param name="negative" ctype="bool"> indicates whether the result should be negative </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// When <c>negative</c> is <c>true</c> , -zero will be generated instead of +zero.
    /// </remarks>
    /// <seealso cref="MkFpaInf"/>
    /// <seealso cref="MkFpaIsZero"/>
    /// <seealso cref="MkFpaNan"/>
    public IntPtr MkFpaZero(IntPtr c, IntPtr s, bool negative)
    {
        var result = nativeLibrary.MkFpaZero(c, s, negative);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaZero));
    }

    /// <summary>
    ///  Create an expression of FloatingPoint sort from three bit-vector expressions.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="sgn" ctype="Z3_ast"> sign </param>
    /// <param name="exp" ctype="Z3_ast"> exponent </param>
    /// <param name="sig" ctype="Z3_ast"> significand </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This is the operator named fp in the SMT FP theory definition. Note that <c>sgn</c> is required to be a bit-vector of size 1. Significand and exponent are required to be longer than 1 and 2 respectively. The FloatingPoint sort of the resulting expression is automatically determined from the bit-vector sizes of the arguments. The exponent is assumed to be in IEEE-754 biased representation.
    /// </remarks>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaFp(IntPtr c, IntPtr sgn, IntPtr exp, IntPtr sig)
    {
        var result = nativeLibrary.MkFpaFp(c, sgn, exp, sig);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaFp));
    }

    /// <summary>
    ///  Create a numeral of FloatingPoint sort from a float.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="v" ctype="float"> value </param>
    /// <param name="ty" ctype="Z3_sort"> sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This function is used to create numerals that fit in a float value. It is slightly faster than <see cref="MkNumeral"/> since it is not necessary to parse a string. <c>ty</c> must be a FloatingPoint sort
    /// </remarks>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralFloat(IntPtr c, float v, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralFloat(c, v, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralFloat));
    }

    /// <summary>
    ///  Create a numeral of FloatingPoint sort from a double.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="v" ctype="double"> value </param>
    /// <param name="ty" ctype="Z3_sort"> sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// This function is used to create numerals that fit in a double value. It is slightly faster than <see cref="MkNumeral"/> since it is not necessary to parse a string. <c>ty</c> must be a FloatingPoint sort
    /// </remarks>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralDouble(IntPtr c, double v, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralDouble(c, v, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralDouble));
    }

    /// <summary>
    ///  Create a numeral of FloatingPoint sort from a signed integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="v" ctype="signed"> value </param>
    /// <param name="ty" ctype="Z3_sort"> result sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>ty</c> must be a FloatingPoint sort
    /// </remarks>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralInt(IntPtr c, int v, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralInt(c, v, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralInt));
    }

    /// <summary>
    ///  Create a numeral of FloatingPoint sort from a sign bit and two integers.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="sgn" ctype="bool"> sign bit (true == negative) </param>
    /// <param name="exp" ctype="signed"> exponent </param>
    /// <param name="sig" ctype="unsigned"> significand </param>
    /// <param name="ty" ctype="Z3_sort"> result sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>ty</c> must be a FloatingPoint sort
    /// </remarks>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralInt64Uint64"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralIntUint(IntPtr c, bool sgn, int exp, uint sig, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralIntUint(c, sgn, exp, sig, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralIntUint));
    }

    /// <summary>
    ///  Create a numeral of FloatingPoint sort from a sign bit and two 64-bit integers.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="sgn" ctype="bool"> sign bit (true == negative) </param>
    /// <param name="exp" ctype="int64_t"> exponent </param>
    /// <param name="sig" ctype="uint64_t"> significand </param>
    /// <param name="ty" ctype="Z3_sort"> result sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>ty</c> must be a FloatingPoint sort
    /// </remarks>
    /// <seealso cref="MkFpaFp"/>
    /// <seealso cref="MkFpaNumeralDouble"/>
    /// <seealso cref="MkFpaNumeralFloat"/>
    /// <seealso cref="MkFpaNumeralInt"/>
    /// <seealso cref="MkFpaNumeralIntUint"/>
    /// <seealso cref="MkNumeral"/>
    public IntPtr MkFpaNumeralInt64Uint64(IntPtr c, bool sgn, long exp, ulong sig, IntPtr ty)
    {
        var result = nativeLibrary.MkFpaNumeralInt64Uint64(c, sgn, exp, sig, ty);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNumeralInt64Uint64));
    }

    /// <summary>
    ///  Floating-point absolute value.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <seealso cref="MkFpaIsNegative"/>
    /// <seealso cref="MkFpaIsPositive"/>
    /// <seealso cref="MkFpaNeg"/>
    public IntPtr MkFpaAbs(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaAbs(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaAbs));
    }

    /// <summary>
    ///  Floating-point negation.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <seealso cref="MkFpaAbs"/>
    /// <seealso cref="MkFpaIsNegative"/>
    /// <seealso cref="MkFpaIsPositive"/>
    public IntPtr MkFpaNeg(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaNeg(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaNeg));
    }

    /// <summary>
    ///  Floating-point addition.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>rm</c> must be of RoundingMode sort, <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaAdd(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaAdd(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaAdd));
    }

    /// <summary>
    ///  Floating-point subtraction.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>rm</c> must be of RoundingMode sort, <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaSub(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaSub(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSub));
    }

    /// <summary>
    ///  Floating-point multiplication.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>rm</c> must be of RoundingMode sort, <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaMul(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaMul(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaMul));
    }

    /// <summary>
    ///  Floating-point division.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort. </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The nodes <c>rm</c> must be of RoundingMode sort, <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaDiv(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaDiv(c, rm, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaDiv));
    }

    /// <summary>
    ///  Floating-point fused multiply-add.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t3" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The result is <c>round((t1 * t2) + t3)</c> . <c>rm</c> must be of RoundingMode sort, <c>t1</c> , <c>t2</c> , and <c>t3</c> must have the same FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaFma(IntPtr c, IntPtr rm, IntPtr t1, IntPtr t2, IntPtr t3)
    {
        var result = nativeLibrary.MkFpaFma(c, rm, t1, t2, t3);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaFma));
    }

    /// <summary>
    ///  Floating-point square root.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>rm</c> must be of RoundingMode sort, <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaSqrt(IntPtr c, IntPtr rm, IntPtr t)
    {
        var result = nativeLibrary.MkFpaSqrt(c, rm, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaSqrt));
    }

    /// <summary>
    ///  Floating-point remainder.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaRem(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaRem(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRem));
    }

    /// <summary>
    ///  Floating-point roundToIntegral. Rounds a floating-point number to the closest integer, again represented as a floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must be of FloatingPoint sort.
    /// </remarks>
    public IntPtr MkFpaRoundToIntegral(IntPtr c, IntPtr rm, IntPtr t)
    {
        var result = nativeLibrary.MkFpaRoundToIntegral(c, rm, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaRoundToIntegral));
    }

    /// <summary>
    ///  Minimum of floating-point numbers.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t1</c> , <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaMax"/>
    public IntPtr MkFpaMin(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaMin(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaMin));
    }

    /// <summary>
    ///  Maximum of floating-point numbers.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t1</c> , <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaMin"/>
    public IntPtr MkFpaMax(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaMax(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaMax));
    }

    /// <summary>
    ///  Floating-point less than or equal.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaLeq(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaLeq(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaLeq));
    }

    /// <summary>
    ///  Floating-point less than.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLeq"/>
    public IntPtr MkFpaLt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaLt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaLt));
    }

    /// <summary>
    ///  Floating-point greater than or equal.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLeq"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaGeq(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaGeq(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaGeq));
    }

    /// <summary>
    ///  Floating-point greater than.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaEq"/>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaLeq"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaGt(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaGt(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaGt));
    }

    /// <summary>
    ///  Floating-point equality.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t1" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="t2" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Note that this is IEEE 754 equality (as opposed to SMT-LIB <c>=</c> ). <c>t1</c> and <c>t2</c> must have the same FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaGeq"/>
    /// <seealso cref="MkFpaGt"/>
    /// <seealso cref="MkFpaLeq"/>
    /// <seealso cref="MkFpaLt"/>
    public IntPtr MkFpaEq(IntPtr c, IntPtr t1, IntPtr t2)
    {
        var result = nativeLibrary.MkFpaEq(c, t1, t2);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaEq));
    }

    /// <summary>
    ///  Predicate indicating whether <c>t</c> is a normal floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    public IntPtr MkFpaIsNormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsNormal(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsNormal));
    }

    /// <summary>
    ///  Predicate indicating whether <c>t</c> is a subnormal floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    public IntPtr MkFpaIsSubnormal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsSubnormal(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsSubnormal));
    }

    /// <summary>
    ///  Predicate indicating whether <c>t</c> is a floating-point number with zero value, i.e., +zero or -zero.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaZero"/>
    public IntPtr MkFpaIsZero(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsZero(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsZero));
    }

    /// <summary>
    ///  Predicate indicating whether <c>t</c> is a floating-point number representing +oo or -oo.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaInf"/>
    /// <seealso cref="MkFpaIsNan"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    public IntPtr MkFpaIsInfinite(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsInfinite(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsInfinite));
    }

    /// <summary>
    ///  Predicate indicating whether <c>t</c> is a NaN.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaIsInfinite"/>
    /// <seealso cref="MkFpaIsNormal"/>
    /// <seealso cref="MkFpaIsSubnormal"/>
    /// <seealso cref="MkFpaIsZero"/>
    /// <seealso cref="MkFpaNan"/>
    public IntPtr MkFpaIsNan(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsNan(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsNan));
    }

    /// <summary>
    ///  Predicate indicating whether <c>t</c> is a negative floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaAbs"/>
    /// <seealso cref="MkFpaIsPositive"/>
    /// <seealso cref="MkFpaNeg"/>
    public IntPtr MkFpaIsNegative(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsNegative(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsNegative));
    }

    /// <summary>
    ///  Predicate indicating whether <c>t</c> is a positive floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// <c>t</c> must have FloatingPoint sort.
    /// </remarks>
    /// <seealso cref="MkFpaAbs"/>
    /// <seealso cref="MkFpaIsNegative"/>
    /// <seealso cref="MkFpaNeg"/>
    public IntPtr MkFpaIsPositive(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaIsPositive(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaIsPositive));
    }

    /// <summary>
    ///  Conversion of a single IEEE 754-2008 bit-vector into a floating-point number.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="bv" ctype="Z3_ast"> a bit-vector term </param>
    /// <param name="s" ctype="Z3_sort"> floating-point sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of a bit-vector term <c>bv</c> to a floating-point term of sort <c>s</c> . <c>s</c> must be a FloatingPoint sort, <c>t</c> must be of bit-vector sort, and the bit-vector size of <c>bv</c> must be equal to <c>ebits+sbits</c> of <c>s</c> . The format of the bit-vector is as defined by the IEEE 754-2008 interchange format.
    /// </remarks>
    public IntPtr MkFpaToFpBv(IntPtr c, IntPtr bv, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpBv(c, bv, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpBv));
    }

    /// <summary>
    ///  Conversion of a FloatingPoint term into another term of different FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="s" ctype="Z3_sort"> floating-point sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of a floating-point term <c>t</c> to a floating-point term of sort <c>s</c> . If necessary, the result will be rounded according to rounding mode <c>rm</c> . <c>s</c> must be a FloatingPoint sort, <c>rm</c> must be of RoundingMode sort, <c>t</c> must be of floating-point sort.
    /// </remarks>
    public IntPtr MkFpaToFpFloat(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpFloat(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpFloat));
    }

    /// <summary>
    ///  Conversion of a term of real sort into a term of FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of Real sort </param>
    /// <param name="s" ctype="Z3_sort"> floating-point sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of term <c>t</c> of real sort into a floating-point term of sort <c>s</c> . If necessary, the result will be rounded according to rounding mode <c>rm</c> . <c>s</c> must be a FloatingPoint sort, <c>rm</c> must be of RoundingMode sort, <c>t</c> must be of real sort.
    /// </remarks>
    public IntPtr MkFpaToFpReal(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpReal(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpReal));
    }

    /// <summary>
    ///  Conversion of a 2's complement signed bit-vector term into a term of FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of bit-vector sort </param>
    /// <param name="s" ctype="Z3_sort"> floating-point sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of the bit-vector term <c>t</c> into a floating-point term of sort <c>s</c> . The bit-vector <c>t</c> is taken to be in signed 2's complement format. If necessary, the result will be rounded according to rounding mode <c>rm</c> . <c>s</c> must be a FloatingPoint sort, <c>rm</c> must be of RoundingMode sort, <c>t</c> must be of bit-vector sort.
    /// </remarks>
    public IntPtr MkFpaToFpSigned(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpSigned(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpSigned));
    }

    /// <summary>
    ///  Conversion of a 2's complement unsigned bit-vector term into a term of FloatingPoint sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of bit-vector sort </param>
    /// <param name="s" ctype="Z3_sort"> floating-point sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of the bit-vector term <c>t</c> into a floating-point term of sort <c>s</c> . The bit-vector <c>t</c> is taken to be in unsigned 2's complement format. If necessary, the result will be rounded according to rounding mode <c>rm</c> . <c>s</c> must be a FloatingPoint sort, <c>rm</c> must be of RoundingMode sort, <c>t</c> must be of bit-vector sort.
    /// </remarks>
    public IntPtr MkFpaToFpUnsigned(IntPtr c, IntPtr rm, IntPtr t, IntPtr s)
    {
        var result = nativeLibrary.MkFpaToFpUnsigned(c, rm, t, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToFpUnsigned));
    }

    /// <summary>
    ///  Conversion of a floating-point term into an unsigned bit-vector.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="sz" ctype="unsigned"> size of the resulting bit-vector </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of the floating-point term <c>t</c> into a bit-vector term of size <c>sz</c> in unsigned 2's complement format. If necessary, the result will be rounded according to rounding mode <c>rm</c> .
    /// </remarks>
    public IntPtr MkFpaToUbv(IntPtr c, IntPtr rm, IntPtr t, uint sz)
    {
        var result = nativeLibrary.MkFpaToUbv(c, rm, t, sz);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToUbv));
    }

    /// <summary>
    ///  Conversion of a floating-point term into a signed bit-vector.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="rm" ctype="Z3_ast"> term of RoundingMode sort </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <param name="sz" ctype="unsigned"> size of the resulting bit-vector </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of the floating-point term <c>t</c> into a bit-vector term of size <c>sz</c> in signed 2's complement format. If necessary, the result will be rounded according to rounding mode <c>rm</c> .
    /// </remarks>
    public IntPtr MkFpaToSbv(IntPtr c, IntPtr rm, IntPtr t, uint sz)
    {
        var result = nativeLibrary.MkFpaToSbv(c, rm, t, sz);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToSbv));
    }

    /// <summary>
    ///  Conversion of a floating-point term into a real-numbered term.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> logical context </param>
    /// <param name="t" ctype="Z3_ast"> term of FloatingPoint sort </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Produces a term that represents the conversion of the floating-point term <c>t</c> into a real number. Note that this type of conversion will often result in non-linear constraints over real terms.
    /// </remarks>
    public IntPtr MkFpaToReal(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkFpaToReal(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkFpaToReal));
    }

}
