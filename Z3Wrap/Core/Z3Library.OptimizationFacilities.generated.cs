// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.OptimizationFacilities.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Create a new optimize context.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_optimize">optimize value</returns>
    /// <remarks>
    /// User must use <see cref="OptimizeIncRef"/> and <see cref="OptimizeDecRef"/> to manage optimize objects. Even if the context was created using MkContext instead of <see cref="MkContextRc"/> .
    /// </remarks>
    public IntPtr MkOptimize(IntPtr c)
    {
        var result = nativeLibrary.MkOptimize(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkOptimize));
    }

    /// <summary>
    ///  Increment the reference counter of the given optimize context.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_optimize">optimize parameter</param>
    public void OptimizeIncRef(IntPtr c, IntPtr d)
    {
        nativeLibrary.OptimizeIncRef(c, d);
    }

    /// <summary>
    ///  Decrement the reference counter of the given optimize context.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_optimize">optimize parameter</param>
    public void OptimizeDecRef(IntPtr c, IntPtr d)
    {
        nativeLibrary.OptimizeDecRef(c, d);
    }

    /// <summary>
    ///  Assert hard constraint to the optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="OptimizeAssertSoft"/>
    /// <seealso cref="OptimizeAssertAndTrack"/>
    public void OptimizeAssert(IntPtr c, IntPtr o, IntPtr a)
    {
        nativeLibrary.OptimizeAssert(c, o, a);
        CheckError(c);
    }

    /// <summary>
    ///  Assert tracked hard constraint to the optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <seealso cref="OptimizeAssert"/>
    /// <seealso cref="OptimizeAssertSoft"/>
    public void OptimizeAssertAndTrack(IntPtr c, IntPtr o, IntPtr a, IntPtr t)
    {
        nativeLibrary.OptimizeAssertAndTrack(c, o, a, t);
        CheckError(c);
    }

    /// <summary>
    ///  Assert soft constraint to the optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="a" ctype="Z3_ast"> - formula </param>
    /// <param name="weight" ctype="Z3_string"> - a penalty for violating soft constraint. Negative weights convert into rewards. </param>
    /// <param name="id"> - optional identifier to group soft constraints </param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="OptimizeAssert"/>
    /// <seealso cref="OptimizeAssertAndTrack"/>
    public uint OptimizeAssertSoft(IntPtr c, IntPtr o, IntPtr a, string weight, string id)
    {
        using var weightAnsi = new AnsiStringPtr(weight);
        using var idAnsi = new AnsiStringPtr(id);
        var idSymbol = nativeLibrary.MkStringSymbol(c, idAnsi);
        CheckError(c);
        var result = nativeLibrary.OptimizeAssertSoft(c, o, a, weightAnsi, idSymbol);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Assert soft constraint to the optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="a" ctype="Z3_ast"> - formula </param>
    /// <param name="weight" ctype="Z3_string"> - a penalty for violating soft constraint. Negative weights convert into rewards. </param>
    /// <param name="id" ctype="Z3_symbol"> - optional identifier to group soft constraints </param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="OptimizeAssert"/>
    /// <seealso cref="OptimizeAssertAndTrack"/>
    public uint OptimizeAssertSoftOriginal(IntPtr c, IntPtr o, IntPtr a, string weight, IntPtr id)
    {
        using var weightAnsi = new AnsiStringPtr(weight);
        var result = nativeLibrary.OptimizeAssertSoft(c, o, a, weightAnsi, id);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Add a maximization constraint.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="t" ctype="Z3_ast"> - arithmetical term </param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="OptimizeMinimize"/>
    public uint OptimizeMaximize(IntPtr c, IntPtr o, IntPtr t)
    {
        var result = nativeLibrary.OptimizeMaximize(c, o, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Add a minimization constraint.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="t" ctype="Z3_ast"> - arithmetical term </param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="OptimizeMaximize"/>
    public uint OptimizeMinimize(IntPtr c, IntPtr o, IntPtr t)
    {
        var result = nativeLibrary.OptimizeMinimize(c, o, t);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Create a backtracking point.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_optimize">optimize parameter</param>
    /// <remarks>
    /// The optimize solver contains a set of rules, added facts and assertions. The set of rules, facts and assertions are restored upon calling <see cref="OptimizePop"/> .
    /// </remarks>
    /// <seealso cref="OptimizePop"/>
    public void OptimizePush(IntPtr c, IntPtr d)
    {
        nativeLibrary.OptimizePush(c, d);
        CheckError(c);
    }

    /// <summary>
    ///  Backtrack one level.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_optimize">optimize parameter</param>
    /// <remarks>
    /// Precondition: The number of calls to pop cannot exceed calls to push.
    /// </remarks>
    /// <seealso cref="OptimizePush"/>
    public void OptimizePop(IntPtr c, IntPtr d)
    {
        nativeLibrary.OptimizePop(c, d);
        CheckError(c);
    }

    /// <summary>
    ///  provide an initialization hint to the solver. The initialization hint is used to calibrate an initial value of the expression that represents a variable. If the variable is Boolean, the initial phase is set according to <c>value</c> . If the variable is an integer or real, the initial Simplex tableau is recalibrated to attempt to follow the value assignment.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="val" ctype="Z3_ast">ast parameter</param>
    public void OptimizeSetInitialValue(IntPtr c, IntPtr o, IntPtr v, IntPtr val)
    {
        nativeLibrary.OptimizeSetInitialValue(c, o, v, val);
        CheckError(c);
    }

    /// <summary>
    ///  Check consistency and produce optimal values.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="numAssumptions" ctype="unsigned"> - number of additional assumptions </param>
    /// <param name="assumptions" ctype="Z3_ast const[]"> - the additional assumptions </param>
    /// <returns ctype="Z3_lbool">lbool value</returns>
    /// <seealso cref="OptimizeGetReasonUnknown"/>
    /// <seealso cref="OptimizeGetModel"/>
    /// <seealso cref="OptimizeGetStatistics"/>
    /// <seealso cref="OptimizeGetUnsatCore"/>
    public Lbool OptimizeCheck(IntPtr c, IntPtr o, uint numAssumptions, IntPtr[] assumptions)
    {
        var result = nativeLibrary.OptimizeCheck(c, o, numAssumptions, assumptions);
        CheckError(c);
        return (Lbool)result;
    }

    /// <summary>
    ///  Retrieve a string that describes the last status returned by <see cref="OptimizeCheck"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_optimize">optimize parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Use this method when <see cref="OptimizeCheck"/> returns <c>Z3_L_UNDEF</c> .
    /// </remarks>
    public string OptimizeGetReasonUnknown(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.OptimizeGetReasonUnknown(c, d);
        CheckError(c);
        result = CheckHandle(result, nameof(OptimizeGetReasonUnknown));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Retrieve the model for the last <see cref="OptimizeCheck"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <returns ctype="Z3_model">model value</returns>
    /// <remarks>
    /// The error handler is invoked if a model is not available because the commands above were not invoked for the given optimization solver, or if the result was <c>Z3_L_FALSE</c> .
    /// </remarks>
    public IntPtr OptimizeGetModel(IntPtr c, IntPtr o)
    {
        var result = nativeLibrary.OptimizeGetModel(c, o);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetModel));
    }

    /// <summary>
    ///  Retrieve the unsat core for the last <see cref="OptimizeCheck"/> The unsat core is a subset of the assumptions <c>a</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    public IntPtr OptimizeGetUnsatCore(IntPtr c, IntPtr o)
    {
        var result = nativeLibrary.OptimizeGetUnsatCore(c, o);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetUnsatCore));
    }

    /// <summary>
    ///  Set parameters on optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="p" ctype="Z3_params"> - parameters </param>
    /// <seealso cref="OptimizeGetHelp"/>
    /// <seealso cref="OptimizeGetParamDescrs"/>
    public void OptimizeSetParams(IntPtr c, IntPtr o, IntPtr p)
    {
        nativeLibrary.OptimizeSetParams(c, o, p);
        CheckError(c);
    }

    /// <summary>
    ///  Return the parameter description set for the given optimize object.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <returns ctype="Z3_param_descrs">param_descrs value</returns>
    /// <seealso cref="OptimizeGetHelp"/>
    /// <seealso cref="OptimizeSetParams"/>
    public IntPtr OptimizeGetParamDescrs(IntPtr c, IntPtr o)
    {
        var result = nativeLibrary.OptimizeGetParamDescrs(c, o);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetParamDescrs));
    }

    /// <summary>
    ///  Retrieve lower bound value or approximation for the i'th optimization objective.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="idx" ctype="unsigned"> - index of optimization objective </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <seealso cref="OptimizeGetUpper"/>
    /// <seealso cref="OptimizeGetLowerAsVector"/>
    /// <seealso cref="OptimizeGetUpperAsVector"/>
    public IntPtr OptimizeGetLower(IntPtr c, IntPtr o, uint idx)
    {
        var result = nativeLibrary.OptimizeGetLower(c, o, idx);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetLower));
    }

    /// <summary>
    ///  Retrieve upper bound value or approximation for the i'th optimization objective.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="idx" ctype="unsigned"> - index of optimization objective </param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <seealso cref="OptimizeGetLower"/>
    /// <seealso cref="OptimizeGetLowerAsVector"/>
    /// <seealso cref="OptimizeGetUpperAsVector"/>
    public IntPtr OptimizeGetUpper(IntPtr c, IntPtr o, uint idx)
    {
        var result = nativeLibrary.OptimizeGetUpper(c, o, idx);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetUpper));
    }

    /// <summary>
    ///  Retrieve lower bound value or approximation for the i'th optimization objective. The returned vector is of length 3. It always contains numerals. The three numerals are coefficients <c>a</c> , <c>b</c> , <c>c</c> and encode the result of <see cref="OptimizeGetLower"/>  <c>a * infinity + b + c * epsilon</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="idx" ctype="unsigned"> - index of optimization objective </param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    /// <seealso cref="OptimizeGetLower"/>
    /// <seealso cref="OptimizeGetUpper"/>
    /// <seealso cref="OptimizeGetUpperAsVector"/>
    public IntPtr OptimizeGetLowerAsVector(IntPtr c, IntPtr o, uint idx)
    {
        var result = nativeLibrary.OptimizeGetLowerAsVector(c, o, idx);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetLowerAsVector));
    }

    /// <summary>
    ///  Retrieve upper bound value or approximation for the i'th optimization objective.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context </param>
    /// <param name="idx" ctype="unsigned"> - index of optimization objective </param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    /// <seealso cref="OptimizeGetLower"/>
    /// <seealso cref="OptimizeGetUpper"/>
    /// <seealso cref="OptimizeGetLowerAsVector"/>
    public IntPtr OptimizeGetUpperAsVector(IntPtr c, IntPtr o, uint idx)
    {
        var result = nativeLibrary.OptimizeGetUpperAsVector(c, o, idx);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetUpperAsVector));
    }

    /// <summary>
    ///  Print the current context as a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context. </param>
    /// <param name="o" ctype="Z3_optimize"> - optimization context. </param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <seealso cref="OptimizeFromFile"/>
    /// <seealso cref="OptimizeFromString"/>
    public string OptimizeToString(IntPtr c, IntPtr o)
    {
        var result = nativeLibrary.OptimizeToString(c, o);
        CheckError(c);
        result = CheckHandle(result, nameof(OptimizeToString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Parse an SMT-LIB2 string with assertions, soft constraints and optimization objectives. Add the parsed constraints and objectives to the optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context. </param>
    /// <param name="o" ctype="Z3_optimize"> - optimize context. </param>
    /// <param name="s" ctype="Z3_string"> - string containing SMT2 specification. </param>
    /// <seealso cref="OptimizeFromFile"/>
    /// <seealso cref="OptimizeToString"/>
    public void OptimizeFromString(IntPtr c, IntPtr o, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        nativeLibrary.OptimizeFromString(c, o, sAnsi);
        CheckError(c);
    }

    /// <summary>
    ///  Parse an SMT-LIB2 file with assertions, soft constraints and optimization objectives. Add the parsed constraints and objectives to the optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context. </param>
    /// <param name="o" ctype="Z3_optimize"> - optimize context. </param>
    /// <param name="s" ctype="Z3_string"> - path to file containing SMT2 specification. </param>
    /// <seealso cref="OptimizeFromString"/>
    /// <seealso cref="OptimizeToString"/>
    public void OptimizeFromFile(IntPtr c, IntPtr o, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        nativeLibrary.OptimizeFromFile(c, o, sAnsi);
        CheckError(c);
    }

    /// <summary>
    ///  Return a string containing a description of parameters accepted by optimize.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_optimize">optimize parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <seealso cref="OptimizeGetParamDescrs"/>
    /// <seealso cref="OptimizeSetParams"/>
    public string OptimizeGetHelp(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.OptimizeGetHelp(c, t);
        CheckError(c);
        result = CheckHandle(result, nameof(OptimizeGetHelp));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Retrieve statistics information from the last call to <see cref="OptimizeCheck"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="d" ctype="Z3_optimize">optimize parameter</param>
    /// <returns ctype="Z3_stats">stats value</returns>
    public IntPtr OptimizeGetStatistics(IntPtr c, IntPtr d)
    {
        var result = nativeLibrary.OptimizeGetStatistics(c, d);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetStatistics));
    }

    /// <summary>
    ///  Return the set of asserted formulas on the optimization context.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    public IntPtr OptimizeGetAssertions(IntPtr c, IntPtr o)
    {
        var result = nativeLibrary.OptimizeGetAssertions(c, o);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetAssertions));
    }

    /// <summary>
    ///  Return objectives on the optimization context. If the objective function is a max-sat objective it is returned as a Pseudo-Boolean (minimization) sum of the form <c>(+ (if f1 w1 0) (if f2 w2 0) ...)</c> If the objective function is entered as a maximization objective, then return the corresponding minimization objective. In this way the resulting objective function is always returned as a minimization objective.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    public IntPtr OptimizeGetObjectives(IntPtr c, IntPtr o)
    {
        var result = nativeLibrary.OptimizeGetObjectives(c, o);
        CheckError(c);
        return CheckHandle(result, nameof(OptimizeGetObjectives));
    }

    /// <summary>
    ///  register a model event handler for new models.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="o" ctype="Z3_optimize">optimize parameter</param>
    /// <param name="m" ctype="Z3_model">model parameter</param>
    /// <param name="ctx" ctype="void*">void parameter</param>
    /// <param name="modelEh" ctype="Z3_model_eh">model_eh parameter</param>
    public void OptimizeRegisterModelEh(IntPtr c, IntPtr o, IntPtr m, IntPtr ctx, IntPtr modelEh)
    {
        nativeLibrary.OptimizeRegisterModelEh(c, o, m, ctx, modelEh);
        CheckError(c);
    }

}
