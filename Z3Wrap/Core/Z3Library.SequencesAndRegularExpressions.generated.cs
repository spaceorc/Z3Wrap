// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.SequencesAndRegularExpressions.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Create a sequence sort out of the sort for the elements.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    public IntPtr MkSeqSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkSeqSort(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqSort));
    }

    /// <summary>
    ///  Check if <c>s</c> is a sequence sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsSeqSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsSeqSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Retrieve basis sort for sequence sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    public IntPtr GetSeqSortBasis(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetSeqSortBasis(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(GetSeqSortBasis));
    }

    /// <summary>
    ///  Create a regular expression sort out of a sequence sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="seq" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    public IntPtr MkReSort(IntPtr c, IntPtr seq)
    {
        var result = nativeLibrary.MkReSort(c, seq);
        CheckError(c);
        return CheckHandle(result, nameof(MkReSort));
    }

    /// <summary>
    ///  Check if <c>s</c> is a regular expression sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsReSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsReSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Retrieve basis sort for regex sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    public IntPtr GetReSortBasis(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetReSortBasis(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(GetReSortBasis));
    }

    /// <summary>
    ///  Create a sort for unicode strings.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// The sort for characters can be changed to ASCII by setting the global parameter <c>encoding</c> to <c>ascii</c> , or alternative to 16 bit characters by setting <c>encoding</c> to <c>bmp</c> .
    /// </remarks>
    public IntPtr MkStringSort(IntPtr c)
    {
        var result = nativeLibrary.MkStringSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkStringSort));
    }

    /// <summary>
    ///  Create a sort for unicode characters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_sort">sort value</returns>
    /// <remarks>
    /// The sort for characters can be changed to ASCII by setting the global parameter <c>encoding</c> to <c>ascii</c> , or alternative to 16 bit characters by setting <c>encoding</c> to <c>bmp</c> .
    /// </remarks>
    public IntPtr MkCharSort(IntPtr c)
    {
        var result = nativeLibrary.MkCharSort(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharSort));
    }

    /// <summary>
    ///  Check if <c>s</c> is a string sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsStringSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsStringSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Check if <c>s</c> is a character sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsCharSort(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsCharSort(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Create a string constant out of the string that is passed in The string may contain escape encoding for non-printable characters or characters outside of the basic printable ASCII range. For example, the escape encoding \u{0} represents the character 0 and the encoding \u{100} represents the character 256.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_string">string parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkString(IntPtr c, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var result = nativeLibrary.MkString(c, sAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(MkString));
    }

    /// <summary>
    ///  Create a string constant out of the string that is passed in It takes the length of the string as well to take into account 0 characters. The string is treated as if it is unescaped so a sequence of characters \u{0} is treated as 5 characters and not the character 0.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="len" ctype="unsigned">unsigned parameter</param>
    /// <param name="s" ctype="Z3_string">string parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkLstring(IntPtr c, uint len, string s)
    {
        using var sAnsi = new AnsiStringPtr(s);
        var result = nativeLibrary.MkLstring(c, len, sAnsi);
        CheckError(c);
        return CheckHandle(result, nameof(MkLstring));
    }

    /// <summary>
    ///  Create a string constant out of the string that is passed in It takes the length of the string as well to take into account 0 characters. The string is unescaped.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="len" ctype="unsigned">unsigned parameter</param>
    /// <param name="chars" ctype="unsigned const[]">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkU32string(IntPtr c, uint len, uint[] chars)
    {
        var result = nativeLibrary.MkU32string(c, len, chars);
        CheckError(c);
        return CheckHandle(result, nameof(MkU32string));
    }

    /// <summary>
    ///  Determine if <c>s</c> is a string constant.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="bool">bool value</returns>
    public bool IsString(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.IsString(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Retrieve the string constant stored in <c>s</c> . Characters outside the basic printable ASCII range are escaped.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// </remarks>
    public string GetString(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetString(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(GetString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Retrieve the string constant stored in <c>s</c> . The string can contain escape sequences. Characters in the range 1 to 255 are literal. Characters in the range 0, and 256 above are escaped.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="length" ctype="unsigned*">unsigned parameter</param>
    /// <returns ctype="Z3_char_ptr">char_ptr value</returns>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// </remarks>
    public IntPtr GetLstring(IntPtr c, IntPtr s, out uint length)
    {
        var result = nativeLibrary.GetLstring(c, s, out length);
        CheckError(c);
        return CheckHandle(result, nameof(GetLstring));
    }

    /// <summary>
    ///  Retrieve the length of the unescaped string constant stored in <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// </remarks>
    public uint GetStringLength(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.GetStringLength(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Retrieve the unescaped string constant stored in <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="length" ctype="unsigned">unsigned parameter</param>
    /// <param name="contents" ctype="unsigned[]">unsigned parameter</param>
    /// <remarks>
    /// Precondition: Z3_is_string(c, s)
    /// Precondition: length contains the number of characters in s
    /// </remarks>
    public void GetStringContents(IntPtr c, IntPtr s, uint length, uint[] contents)
    {
        nativeLibrary.GetStringContents(c, s, length, contents);
        CheckError(c);
    }

    /// <summary>
    ///  Create an empty sequence of the sequence sort <c>seq</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="seq" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: s is a sequence sort.
    /// </remarks>
    public IntPtr MkSeqEmpty(IntPtr c, IntPtr seq)
    {
        var result = nativeLibrary.MkSeqEmpty(c, seq);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqEmpty));
    }

    /// <summary>
    ///  Create a unit sequence of <c>a</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqUnit(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.MkSeqUnit(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqUnit));
    }

    /// <summary>
    ///  Concatenate sequences.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkSeqConcat(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkSeqConcat(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqConcat));
    }

    /// <summary>
    ///  Check if <c>prefix</c> is a prefix of <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="prefix" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: prefix and s are the same sequence sorts.
    /// </remarks>
    public IntPtr MkSeqPrefix(IntPtr c, IntPtr prefix, IntPtr s)
    {
        var result = nativeLibrary.MkSeqPrefix(c, prefix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqPrefix));
    }

    /// <summary>
    ///  Check if <c>suffix</c> is a suffix of <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="suffix" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: <c>suffix</c> and <c>s</c> are the same sequence sorts.
    /// </remarks>
    public IntPtr MkSeqSuffix(IntPtr c, IntPtr suffix, IntPtr s)
    {
        var result = nativeLibrary.MkSeqSuffix(c, suffix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqSuffix));
    }

    /// <summary>
    ///  Check if <c>container</c> contains <c>containee</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="container" ctype="Z3_ast">ast parameter</param>
    /// <param name="containee" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: <c>container</c> and <c>containee</c> are the same sequence sorts.
    /// </remarks>
    public IntPtr MkSeqContains(IntPtr c, IntPtr container, IntPtr containee)
    {
        var result = nativeLibrary.MkSeqContains(c, container, containee);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqContains));
    }

    /// <summary>
    ///  Check if <c>s1</c> is lexicographically strictly less than <c>s2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="prefix" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: <c>s1</c> and <c>s2</c> are strings
    /// </remarks>
    public IntPtr MkStrLt(IntPtr c, IntPtr prefix, IntPtr s)
    {
        var result = nativeLibrary.MkStrLt(c, prefix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkStrLt));
    }

    /// <summary>
    ///  Check if <c>s1</c> is equal or lexicographically strictly less than <c>s2</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="prefix" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: <c>s1</c> and <c>s2</c> are strings
    /// </remarks>
    public IntPtr MkStrLe(IntPtr c, IntPtr prefix, IntPtr s)
    {
        var result = nativeLibrary.MkStrLe(c, prefix, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkStrLe));
    }

    /// <summary>
    ///  Extract subsequence starting at <c>offset</c> of <c>length</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="offset" ctype="Z3_ast">ast parameter</param>
    /// <param name="length" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqExtract(IntPtr c, IntPtr s, IntPtr offset, IntPtr length)
    {
        var result = nativeLibrary.MkSeqExtract(c, s, offset, length);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqExtract));
    }

    /// <summary>
    ///  Replace the first occurrence of <c>src</c> with <c>dst</c> in <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="src" ctype="Z3_ast">ast parameter</param>
    /// <param name="dst" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqReplace(IntPtr c, IntPtr s, IntPtr src, IntPtr dst)
    {
        var result = nativeLibrary.MkSeqReplace(c, s, src, dst);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqReplace));
    }

    /// <summary>
    ///  Retrieve from <c>s</c> the unit sequence positioned at position <c>index</c> . The sequence is empty if the index is out of bounds.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="index" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqAt(IntPtr c, IntPtr s, IntPtr index)
    {
        var result = nativeLibrary.MkSeqAt(c, s, index);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqAt));
    }

    /// <summary>
    ///  Retrieve from <c>s</c> the element positioned at position <c>index</c> . The function is under-specified if the index is out of bounds.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="index" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqNth(IntPtr c, IntPtr s, IntPtr index)
    {
        var result = nativeLibrary.MkSeqNth(c, s, index);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqNth));
    }

    /// <summary>
    ///  Return the length of the sequence <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqLength(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkSeqLength(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqLength));
    }

    /// <summary>
    ///  Return index of the first occurrence of <c>substr</c> in <c>s</c> starting from offset <c>offset</c> . If <c>s</c> does not contain <c>substr</c> , then the value is -1, if <c>offset</c> is the length of <c>s</c> , then the value is -1 as well. The value is -1 if <c>offset</c> is negative or larger than the length of <c>s</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="substr" ctype="Z3_ast">ast parameter</param>
    /// <param name="offset" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqIndex(IntPtr c, IntPtr s, IntPtr substr, IntPtr offset)
    {
        var result = nativeLibrary.MkSeqIndex(c, s, substr, offset);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqIndex));
    }

    /// <summary>
    ///  Return index of the last occurrence of <c>substr</c> in <c>s</c> . If <c>s</c> does not contain <c>substr</c> , then the value is -1, def_API('Z3_mk_seq_last_index', AST, (_in(CONTEXT), _in(AST), _in(AST)))
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <param name="substr" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqLastIndex(IntPtr c, IntPtr s, IntPtr substr)
    {
        var result = nativeLibrary.MkSeqLastIndex(c, s, substr);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqLastIndex));
    }

    /// <summary>
    ///  Create a map of the function <c>f</c> over the sequence <c>s</c> . def_API('Z3_mk_seq_map', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqMap(IntPtr c, IntPtr f, IntPtr s)
    {
        var result = nativeLibrary.MkSeqMap(c, f, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqMap));
    }

    /// <summary>
    ///  Create a map of the function <c>f</c> over the sequence <c>s</c> starting at index <c>i</c> . def_API('Z3_mk_seq_mapi', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqMapi(IntPtr c, IntPtr f, IntPtr i, IntPtr s)
    {
        var result = nativeLibrary.MkSeqMapi(c, f, i, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqMapi));
    }

    /// <summary>
    ///  Create a fold of the function <c>f</c> over the sequence <c>s</c> with accumulator a. def_API('Z3_mk_seq_foldl', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_ast">ast parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqFoldl(IntPtr c, IntPtr f, IntPtr a, IntPtr s)
    {
        var result = nativeLibrary.MkSeqFoldl(c, f, a, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqFoldl));
    }

    /// <summary>
    ///  Create a fold with index tracking of the function <c>f</c> over the sequence <c>s</c> with accumulator <c>a</c> starting at index <c>i</c> . def_API('Z3_mk_seq_foldli', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST), _in(AST)))
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="f" ctype="Z3_ast">ast parameter</param>
    /// <param name="i" ctype="Z3_ast">ast parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqFoldli(IntPtr c, IntPtr f, IntPtr i, IntPtr a, IntPtr s)
    {
        var result = nativeLibrary.MkSeqFoldli(c, f, i, a, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqFoldli));
    }

    /// <summary>
    ///  Convert string to integer.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkStrToInt(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkStrToInt(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkStrToInt));
    }

    /// <summary>
    ///  Integer to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkIntToStr(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkIntToStr(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkIntToStr));
    }

    /// <summary>
    ///  String to code conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkStringToCode(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.MkStringToCode(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(MkStringToCode));
    }

    /// <summary>
    ///  Code to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkStringFromCode(IntPtr c, IntPtr a)
    {
        var result = nativeLibrary.MkStringFromCode(c, a);
        CheckError(c);
        return CheckHandle(result, nameof(MkStringFromCode));
    }

    /// <summary>
    ///  Unsigned bit-vector to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkUbvToStr(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkUbvToStr(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkUbvToStr));
    }

    /// <summary>
    ///  Signed bit-vector to string conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSbvToStr(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.MkSbvToStr(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(MkSbvToStr));
    }

    /// <summary>
    ///  Create a regular expression that accepts the sequence <c>seq</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="seq" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqToRe(IntPtr c, IntPtr seq)
    {
        var result = nativeLibrary.MkSeqToRe(c, seq);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqToRe));
    }

    /// <summary>
    ///  Check if <c>seq</c> is in the language generated by the regular expression <c>re</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="seq" ctype="Z3_ast">ast parameter</param>
    /// <param name="re" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkSeqInRe(IntPtr c, IntPtr seq, IntPtr re)
    {
        var result = nativeLibrary.MkSeqInRe(c, seq, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkSeqInRe));
    }

    /// <summary>
    ///  Create the regular language <c>re+</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkRePlus(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkRePlus(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkRePlus));
    }

    /// <summary>
    ///  Create the regular language <c>re*</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkReStar(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReStar(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReStar));
    }

    /// <summary>
    ///  Create the regular language [re].
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkReOption(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReOption(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReOption));
    }

    /// <summary>
    ///  Create the union of the regular languages.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkReUnion(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkReUnion(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkReUnion));
    }

    /// <summary>
    ///  Create the concatenation of the regular languages.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkReConcat(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkReConcat(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkReConcat));
    }

    /// <summary>
    ///  Create the range regular expression over two sequences of length 1.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="lo" ctype="Z3_ast">ast parameter</param>
    /// <param name="hi" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkReRange(IntPtr c, IntPtr lo, IntPtr hi)
    {
        var result = nativeLibrary.MkReRange(c, lo, hi);
        CheckError(c);
        return CheckHandle(result, nameof(MkReRange));
    }

    /// <summary>
    ///  Create a regular expression that accepts all singleton sequences of the regular expression sort.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="regexSort" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkReAllchar(IntPtr c, IntPtr regexSort)
    {
        var result = nativeLibrary.MkReAllchar(c, regexSort);
        CheckError(c);
        return CheckHandle(result, nameof(MkReAllchar));
    }

    /// <summary>
    ///  Create a regular expression loop. The supplied regular expression <c>r</c> is repeated between <c>lo</c> and <c>hi</c> times. The <c>lo</c> should be below <c>hi</c> with one exception: when supplying the value <c>hi</c> as 0, the meaning is to repeat the argument <c>r</c> at least <c>lo</c> number of times, and with an unbounded upper bound.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="r" ctype="Z3_ast">ast parameter</param>
    /// <param name="lo" ctype="unsigned">unsigned parameter</param>
    /// <param name="hi" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkReLoop(IntPtr c, IntPtr r, uint lo, uint hi)
    {
        var result = nativeLibrary.MkReLoop(c, r, lo, hi);
        CheckError(c);
        return CheckHandle(result, nameof(MkReLoop));
    }

    /// <summary>
    ///  Create a power regular expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re" ctype="Z3_ast">ast parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkRePower(IntPtr c, IntPtr re, uint n)
    {
        var result = nativeLibrary.MkRePower(c, re, n);
        CheckError(c);
        return CheckHandle(result, nameof(MkRePower));
    }

    /// <summary>
    ///  Create the intersection of the regular languages.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="args" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: n &gt; 0
    /// </remarks>
    public IntPtr MkReIntersect(IntPtr c, uint n, IntPtr[] args)
    {
        var result = nativeLibrary.MkReIntersect(c, n, args);
        CheckError(c);
        return CheckHandle(result, nameof(MkReIntersect));
    }

    /// <summary>
    ///  Create the complement of the regular language <c>re</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkReComplement(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReComplement(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReComplement));
    }

    /// <summary>
    ///  Create the difference of regular expressions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re1" ctype="Z3_ast">ast parameter</param>
    /// <param name="re2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkReDiff(IntPtr c, IntPtr re1, IntPtr re2)
    {
        var result = nativeLibrary.MkReDiff(c, re1, re2);
        CheckError(c);
        return CheckHandle(result, nameof(MkReDiff));
    }

    /// <summary>
    ///  Create an empty regular expression of sort <c>re</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: re is a regular expression sort.
    /// </remarks>
    public IntPtr MkReEmpty(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReEmpty(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReEmpty));
    }

    /// <summary>
    ///  Create an universal regular expression of sort <c>re</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="re" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: re is a regular expression sort.
    /// </remarks>
    public IntPtr MkReFull(IntPtr c, IntPtr re)
    {
        var result = nativeLibrary.MkReFull(c, re);
        CheckError(c);
        return CheckHandle(result, nameof(MkReFull));
    }

    /// <summary>
    ///  Create a character literal def_API('Z3_mk_char', AST, (_in(CONTEXT), _in(UINT)))
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="ch" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkChar(IntPtr c, uint ch)
    {
        var result = nativeLibrary.MkChar(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkChar));
    }

    /// <summary>
    ///  Create less than or equal to between two characters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="ch1" ctype="Z3_ast">ast parameter</param>
    /// <param name="ch2" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkCharLe(IntPtr c, IntPtr ch1, IntPtr ch2)
    {
        var result = nativeLibrary.MkCharLe(c, ch1, ch2);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharLe));
    }

    /// <summary>
    ///  Create an integer (code point) from character.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="ch" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkCharToInt(IntPtr c, IntPtr ch)
    {
        var result = nativeLibrary.MkCharToInt(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharToInt));
    }

    /// <summary>
    ///  Create a bit-vector (code point) from character.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="ch" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkCharToBv(IntPtr c, IntPtr ch)
    {
        var result = nativeLibrary.MkCharToBv(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharToBv));
    }

    /// <summary>
    ///  Create a character from a bit-vector (code point).
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="bv" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkCharFromBv(IntPtr c, IntPtr bv)
    {
        var result = nativeLibrary.MkCharFromBv(c, bv);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharFromBv));
    }

    /// <summary>
    ///  Create a check if the character is a digit.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="ch" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr MkCharIsDigit(IntPtr c, IntPtr ch)
    {
        var result = nativeLibrary.MkCharIsDigit(c, ch);
        CheckError(c);
        return CheckHandle(result, nameof(MkCharIsDigit));
    }

}
