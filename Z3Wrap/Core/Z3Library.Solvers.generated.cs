// <auto-generated>
// This file was generated by scripts/generate_library.py
// Source: NativeZ3Library.Solvers.generated.cs
// DO NOT EDIT - Changes will be overwritten
// </auto-generated>

#nullable enable

using System.Runtime.InteropServices;
using Spaceorc.Z3Wrap.Core.Interop;

namespace Spaceorc.Z3Wrap.Core;

public sealed partial class Z3Library
{
    /// <summary>
    ///  Create a new solver. This solver is a "combined solver" (see combined_solver module) that internally uses a non-incremental (solver1) and an incremental solver (solver2). This combined solver changes its behaviour based on how it is used and how its parameters are set.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_solver">solver value</returns>
    /// <remarks>
    /// If the solver is used in a non incremental way (i.e. no calls to <see cref="SolverPush"/> or <see cref="SolverPop"/> , and no calls to <see cref="SolverAssert"/> or <see cref="SolverAssertAndTrack"/> after checking satisfiability without an intervening <see cref="SolverReset"/> ) then solver1 will be used. This solver will apply Z3's "default" tactic. The "default" tactic will attempt to probe the logic used by the assertions and will apply a specialized tactic if one is supported. Otherwise the general <c>(and-then simplify smt)</c> tactic will be used. If the solver is used in an incremental way then the combined solver will switch to using solver2 (which behaves similarly to the general "smt" tactic). Note however it is possible to set the <c>solver2_timeout</c> , <c>solver2_unknown</c> , and <c>ignore_solver1</c> parameters of the combined solver to change its behaviour. The function <see cref="SolverGetModel"/> retrieves a model if the assertions is satisfiable (i.e., the result is <c>Z3_L_TRUE</c> ) and model construction is enabled. The function <see cref="SolverGetModel"/> can also be used even if the result is <c>Z3_L_UNDEF</c> , but the returned model is not guaranteed to satisfy quantified assertions.
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects. Even if the context was created using MkContext instead of <see cref="MkContextRc"/> .
    /// </remarks>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    /// <seealso cref="MkSolverFromTactic"/>
    public IntPtr MkSolver(IntPtr c)
    {
        var result = nativeLibrary.MkSolver(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkSolver));
    }

    /// <summary>
    ///  Create a new incremental solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_solver">solver value</returns>
    /// <remarks>
    /// This is equivalent to applying the "smt" tactic. Unlike <see cref="MkSolver"/> this solver  Does not attempt to apply any logic specific tactics.  Does not change its behaviour based on whether it used incrementally/non-incrementally.   Note that these differences can result in very different performance compared to <see cref="MkSolver"/> . The function <see cref="SolverGetModel"/> retrieves a model if the assertions is satisfiable (i.e., the result is <c>Z3_L_TRUE</c> ) and model construction is enabled. The function <see cref="SolverGetModel"/> can also be used even if the result is <c>Z3_L_UNDEF</c> , but the returned model is not guaranteed to satisfy quantified assertions.
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects. Even if the context was created using MkContext instead of <see cref="MkContextRc"/> .
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    /// <seealso cref="MkSolverFromTactic"/>
    public IntPtr MkSimpleSolver(IntPtr c)
    {
        var result = nativeLibrary.MkSimpleSolver(c);
        CheckError(c);
        return CheckHandle(result, nameof(MkSimpleSolver));
    }

    /// <summary>
    ///  Create a new solver customized for the given logic. It behaves like <see cref="MkSolver"/> if the logic is unknown or unsupported.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="logic">symbol parameter</param>
    /// <returns ctype="Z3_solver">solver value</returns>
    /// <remarks>
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects. Even if the context was created using MkContext instead of <see cref="MkContextRc"/> .
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverFromTactic"/>
    public IntPtr MkSolverForLogic(IntPtr c, string logic)
    {
        using var logicAnsi = new AnsiStringPtr(logic);
        var logicSymbol = nativeLibrary.MkStringSymbol(c, logicAnsi);
        CheckError(c);
        var result = nativeLibrary.MkSolverForLogic(c, logicSymbol);
        CheckError(c);
        return CheckHandle(result, nameof(MkSolverForLogic));
    }

    /// <summary>
    ///  Create a new solver customized for the given logic. It behaves like <see cref="MkSolver"/> if the logic is unknown or unsupported.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="logic" ctype="Z3_symbol">symbol parameter</param>
    /// <returns ctype="Z3_solver">solver value</returns>
    /// <remarks>
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects. Even if the context was created using MkContext instead of <see cref="MkContextRc"/> .
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverFromTactic"/>
    public IntPtr MkSolverForLogicOriginal(IntPtr c, IntPtr logic)
    {
        var result = nativeLibrary.MkSolverForLogic(c, logic);
        CheckError(c);
        return CheckHandle(result, nameof(MkSolverForLogic));
    }

    /// <summary>
    ///  Create a new solver that is implemented using the given tactic. The solver supports the commands <see cref="SolverPush"/> and <see cref="SolverPop"/> , but it will always solve each <see cref="SolverCheck"/> from scratch.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="t" ctype="Z3_tactic">tactic parameter</param>
    /// <returns ctype="Z3_solver">solver value</returns>
    /// <remarks>
    /// User must use <see cref="SolverIncRef"/> and <see cref="SolverDecRef"/> to manage solver objects. Even if the context was created using MkContext instead of <see cref="MkContextRc"/> .
    /// </remarks>
    /// <seealso cref="MkSolver"/>
    /// <seealso cref="MkSimpleSolver"/>
    /// <seealso cref="MkSolverForLogic"/>
    public IntPtr MkSolverFromTactic(IntPtr c, IntPtr t)
    {
        var result = nativeLibrary.MkSolverFromTactic(c, t);
        CheckError(c);
        return CheckHandle(result, nameof(MkSolverFromTactic));
    }

    /// <summary>
    ///  Copy a solver <c>s</c> from the context <c>source</c> to the context <c>target</c> .
    /// </summary>
    /// <param name="source" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="target" ctype="Z3_context">context parameter</param>
    /// <returns ctype="Z3_solver">solver value</returns>
    public IntPtr SolverTranslate(IntPtr source, IntPtr s, IntPtr target)
    {
        var result = nativeLibrary.SolverTranslate(source, s, target);
        CheckError(source);
        return CheckHandle(result, nameof(SolverTranslate));
    }

    /// <summary>
    ///  Ad-hoc method for importing model conversion from solver.
    /// </summary>
    /// <param name="ctx" ctype="Z3_context">context parameter</param>
    /// <param name="src" ctype="Z3_solver">solver parameter</param>
    /// <param name="dst" ctype="Z3_solver">solver parameter</param>
    /// <remarks>
    /// This method is used for scenarios where <c>src</c> has been used to solve a set of formulas and was interrupted. The <c>dst</c> solver may be a strengthening of <c>src</c> obtained from cubing (assigning a subset of literals or adding constraints over the assertions available in <c>src</c> ). If <c>dst</c> ends up being satisfiable, the model for <c>dst</c> may not correspond to a model of the original formula due to inprocessing in <c>src</c> . This method is used to take the side-effect of inprocessing into account when returning a model for <c>dst</c> .
    /// </remarks>
    public void SolverImportModelConverter(IntPtr ctx, IntPtr src, IntPtr dst)
    {
        nativeLibrary.SolverImportModelConverter(ctx, src, dst);
        CheckError(ctx);
    }

    /// <summary>
    ///  Return a string describing all solver available parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <seealso cref="SolverGetParamDescrs"/>
    /// <seealso cref="SolverSetParams"/>
    public string SolverGetHelp(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetHelp(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverGetHelp));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return the parameter description set for the given solver object.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_param_descrs">param_descrs value</returns>
    /// <seealso cref="SolverGetHelp"/>
    /// <seealso cref="SolverSetParams"/>
    public IntPtr SolverGetParamDescrs(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetParamDescrs(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(SolverGetParamDescrs));
    }

    /// <summary>
    ///  Set the given solver using the given parameters.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="p" ctype="Z3_params">params parameter</param>
    /// <seealso cref="SolverGetHelp"/>
    /// <seealso cref="SolverGetParamDescrs"/>
    public void SolverSetParams(IntPtr c, IntPtr s, IntPtr p)
    {
        nativeLibrary.SolverSetParams(c, s, p);
        CheckError(c);
    }

    /// <summary>
    ///  Increment the reference counter of the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    public void SolverIncRef(IntPtr c, IntPtr s)
    {
        nativeLibrary.SolverIncRef(c, s);
    }

    /// <summary>
    ///  Decrement the reference counter of the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    public void SolverDecRef(IntPtr c, IntPtr s)
    {
        nativeLibrary.SolverDecRef(c, s);
    }

    /// <summary>
    ///  Solver local interrupt. Normally you should use Z3_interrupt to cancel solvers because only one solver is enabled concurrently per context. However, per GitHub issue #1006, there are use cases where it is more convenient to cancel a specific solver. Solvers that are not selected for interrupts are left alone.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    public void SolverInterrupt(IntPtr c, IntPtr s)
    {
        nativeLibrary.SolverInterrupt(c, s);
        CheckError(c);
    }

    /// <summary>
    ///  Create a backtracking point.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <remarks>
    /// The solver contains a stack of assertions.
    /// </remarks>
    /// <seealso cref="SolverGetNumScopes"/>
    /// <seealso cref="SolverPop"/>
    public void SolverPush(IntPtr c, IntPtr s)
    {
        nativeLibrary.SolverPush(c, s);
        CheckError(c);
    }

    /// <summary>
    ///  Backtrack <c>n</c> backtracking points.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <remarks>
    /// Precondition: n &lt;= Z3_solver_get_num_scopes(c, s)
    /// </remarks>
    /// <seealso cref="SolverGetNumScopes"/>
    /// <seealso cref="SolverPush"/>
    public void SolverPop(IntPtr c, IntPtr s, uint n)
    {
        nativeLibrary.SolverPop(c, s, n);
        CheckError(c);
    }

    /// <summary>
    ///  Remove all assertions from the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <seealso cref="SolverAssert"/>
    /// <seealso cref="SolverAssertAndTrack"/>
    public void SolverReset(IntPtr c, IntPtr s)
    {
        nativeLibrary.SolverReset(c, s);
        CheckError(c);
    }

    /// <summary>
    ///  Return the number of backtracking points.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="unsigned">unsigned value</returns>
    /// <seealso cref="SolverPush"/>
    /// <seealso cref="SolverPop"/>
    public uint SolverGetNumScopes(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetNumScopes(c, s);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  Assert a constraint into the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// The functions <see cref="SolverCheck"/> and <see cref="SolverCheckAssumptions"/> should be used to check whether the logical context is consistent or not.
    /// </remarks>
    /// <seealso cref="SolverAssertAndTrack"/>
    /// <seealso cref="SolverReset"/>
    public void SolverAssert(IntPtr c, IntPtr s, IntPtr a)
    {
        nativeLibrary.SolverAssert(c, s, a);
        CheckError(c);
    }

    /// <summary>
    ///  Assert a constraint <c>a</c> into the solver, and track it (in the unsat) core using the Boolean constant <c>p</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="p" ctype="Z3_ast">ast parameter</param>
    /// <remarks>
    /// This API is an alternative to <see cref="SolverCheckAssumptions"/> for extracting unsat cores. Both APIs can be used in the same solver. The unsat core will contain a combination of the Boolean variables provided using Z3_solver_assert_and_track and the Boolean literals provided using <see cref="SolverCheckAssumptions"/> .
    /// Precondition: <c>a</c> must be a Boolean expression
    /// Precondition: <c>p</c> must be a Boolean constant (aka variable).
    /// </remarks>
    /// <seealso cref="SolverAssert"/>
    /// <seealso cref="SolverReset"/>
    public void SolverAssertAndTrack(IntPtr c, IntPtr s, IntPtr a, IntPtr p)
    {
        nativeLibrary.SolverAssertAndTrack(c, s, a, p);
        CheckError(c);
    }

    /// <summary>
    ///  load solver assertions from a file.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="fileName" ctype="Z3_string">string parameter</param>
    /// <seealso cref="SolverFromString"/>
    /// <seealso cref="SolverToString"/>
    public void SolverFromFile(IntPtr c, IntPtr s, string fileName)
    {
        using var fileNameAnsi = new AnsiStringPtr(fileName);
        nativeLibrary.SolverFromFile(c, s, fileNameAnsi);
        CheckError(c);
    }

    /// <summary>
    ///  load solver assertions from a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="str" ctype="Z3_string">string parameter</param>
    /// <seealso cref="SolverFromFile"/>
    /// <seealso cref="SolverToString"/>
    public void SolverFromString(IntPtr c, IntPtr s, string str)
    {
        using var strAnsi = new AnsiStringPtr(str);
        nativeLibrary.SolverFromString(c, s, strAnsi);
        CheckError(c);
    }

    /// <summary>
    ///  Return the set of asserted formulas on the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    public IntPtr[] SolverGetAssertions(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetAssertions(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverGetAssertions));
        return AstVectorToArray(c, result);
    }

    /// <summary>
    ///  Return the set of units modulo model conversion.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    public IntPtr[] SolverGetUnits(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetUnits(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverGetUnits));
        return AstVectorToArray(c, result);
    }

    /// <summary>
    ///  Return the trail modulo model conversion, in order of decision level The decision level can be retrieved using <c>Z3_solver_get_level</c> based on the trail.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    public IntPtr[] SolverGetTrail(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetTrail(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverGetTrail));
        return AstVectorToArray(c, result);
    }

    /// <summary>
    ///  Return the set of non units in the solver state.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    public IntPtr[] SolverGetNonUnits(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetNonUnits(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverGetNonUnits));
        return AstVectorToArray(c, result);
    }

    /// <summary>
    ///  retrieve the decision depth of Boolean literals (variables or their negations). Assumes a check-sat call and no other calls (to extract models) have been invoked.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="literals" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="sz" ctype="unsigned">unsigned parameter</param>
    /// <param name="levels" ctype="unsigned[]">unsigned parameter</param>
    public void SolverGetLevels(IntPtr c, IntPtr s, IntPtr literals, uint sz, uint[] levels)
    {
        nativeLibrary.SolverGetLevels(c, s, literals, sz, levels);
        CheckError(c);
    }

    /// <summary>
    ///  retrieve the congruence closure root of an expression. The root is retrieved relative to the state where the solver was in when it completed. If it completed during a set of case splits, the congruence roots are relative to these case splits. That is, the congruences are not consequences but they are true under the current state.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr SolverCongruenceRoot(IntPtr c, IntPtr s, IntPtr a)
    {
        var result = nativeLibrary.SolverCongruenceRoot(c, s, a);
        CheckError(c);
        return CheckHandle(result, nameof(SolverCongruenceRoot));
    }

    /// <summary>
    ///  retrieve the next expression in the congruence class. The set of congruent siblings form a cyclic list. Repeated calls on the siblings will result in returning to the original expression.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    public IntPtr SolverCongruenceNext(IntPtr c, IntPtr s, IntPtr a)
    {
        var result = nativeLibrary.SolverCongruenceNext(c, s, a);
        CheckError(c);
        return CheckHandle(result, nameof(SolverCongruenceNext));
    }

    /// <summary>
    ///  retrieve explanation for congruence.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="a" ctype="Z3_ast">ast parameter</param>
    /// <param name="b" ctype="Z3_ast">ast parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// Precondition: root(a) = root(b)
    /// </remarks>
    public IntPtr SolverCongruenceExplain(IntPtr c, IntPtr s, IntPtr a, IntPtr b)
    {
        var result = nativeLibrary.SolverCongruenceExplain(c, s, a, b);
        CheckError(c);
        return CheckHandle(result, nameof(SolverCongruenceExplain));
    }

    /// <summary>
    ///  retrieve a 'solution' for <c>variables</c> as defined by equalities in maintained by solvers. At this point, only linear solution are supported. The solution to <c>variables</c> may be presented in triangular form, such that variables used in solutions themselves have solutions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="variables" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="terms" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="guards" ctype="Z3_ast_vector">ast_vector parameter</param>
    public void SolverSolveFor(IntPtr c, IntPtr s, IntPtr variables, IntPtr terms, IntPtr guards)
    {
        nativeLibrary.SolverSolveFor(c, s, variables, terms, guards);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback to that retrieves assumed, inferred and deleted clauses during search.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context. </param>
    /// <param name="s" ctype="Z3_solver"> - solver object. </param>
    /// <param name="userContext" ctype="void*"> - a context used to maintain state for callbacks. </param>
    /// <param name="onClauseEh" ctype="Z3_on_clause_eh"> - a callback that is invoked by when a clause is  asserted to the CDCL engine (corresponding to an input clause after pre-processing)  inferred by CDCL(T) using either a SAT or theory conflict/propagation  deleted by the CDCL(T) engine   </param>
    public void SolverRegisterOnClause(IntPtr c, IntPtr s, IntPtr userContext, OnClauseEhCallback? onClauseEh)
    {
        nativeLibrary.SolverRegisterOnClause(c, s, userContext, (NativeZ3Library.OnClauseEhCallback?)(object?)onClauseEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a user-propagator with the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context. </param>
    /// <param name="s" ctype="Z3_solver"> - solver object. </param>
    /// <param name="userContext" ctype="void*"> - a context used to maintain state for callbacks. </param>
    /// <param name="pushEh" ctype="Z3_push_eh"> - a callback invoked when scopes are pushed </param>
    /// <param name="popEh" ctype="Z3_pop_eh"> - a callback invoked when scopes are popped </param>
    /// <param name="freshEh" ctype="Z3_fresh_eh"> - a solver may spawn new solvers internally. This callback is used to produce a fresh user_context to be associated with fresh solvers. </param>
    public void SolverPropagateInit(IntPtr c, IntPtr s, IntPtr userContext, PushEhCallback? pushEh, PopEhCallback? popEh, FreshEhCallback? freshEh)
    {
        nativeLibrary.SolverPropagateInit(c, s, userContext, (NativeZ3Library.PushEhCallback?)(object?)pushEh, (NativeZ3Library.PopEhCallback?)(object?)popEh, (NativeZ3Library.FreshEhCallback?)(object?)freshEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback for when an expression is bound to a fixed value. The supported expression types are
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="fixedEh" ctype="Z3_fixed_eh">fixed_eh parameter</param>
    /// <remarks>
    ///  Booleans  Bit-vectors
    /// </remarks>
    public void SolverPropagateFixed(IntPtr c, IntPtr s, FixedEhCallback? fixedEh)
    {
        nativeLibrary.SolverPropagateFixed(c, s, (NativeZ3Library.FixedEhCallback?)(object?)fixedEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback on final check. This provides freedom to the propagator to delay actions or implement a branch-and bound solver. The final check is invoked when all decision variables have been assigned by the solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="finalEh" ctype="Z3_final_eh">final_eh parameter</param>
    /// <remarks>
    /// The <c>final_eh</c> callback takes as argument the original user_context that was used when calling <c>Z3_solver_propagate_init</c> , and it takes a callback context with the opaque type <c>Z3_solver_callback</c> . The callback context is passed as argument to invoke the <c>Z3_solver_propagate_consequence</c> function. The callback context can only be accessed (for propagation and for dynamically registering expressions) within a callback. If the callback context gets used for propagation or conflicts, those propagations take effect and may trigger new decision variables to be set.
    /// </remarks>
    public void SolverPropagateFinal(IntPtr c, IntPtr s, FinalEhCallback? finalEh)
    {
        nativeLibrary.SolverPropagateFinal(c, s, (NativeZ3Library.FinalEhCallback?)(object?)finalEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback on expression equalities.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="eqEh" ctype="Z3_eq_eh">eq_eh parameter</param>
    public void SolverPropagateEq(IntPtr c, IntPtr s, EqEhCallback? eqEh)
    {
        nativeLibrary.SolverPropagateEq(c, s, (NativeZ3Library.EqEhCallback?)(object?)eqEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback on expression dis-equalities.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="eqEh" ctype="Z3_eq_eh">eq_eh parameter</param>
    public void SolverPropagateDiseq(IntPtr c, IntPtr s, EqEhCallback? eqEh)
    {
        nativeLibrary.SolverPropagateDiseq(c, s, (NativeZ3Library.EqEhCallback?)(object?)eqEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback when a new expression with a registered function is used by the solver The registered function appears at the top level and is created using <see cref="SolverPropagateDeclare"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="createdEh" ctype="Z3_created_eh">created_eh parameter</param>
    public void SolverPropagateCreated(IntPtr c, IntPtr s, CreatedEhCallback? createdEh)
    {
        nativeLibrary.SolverPropagateCreated(c, s, (NativeZ3Library.CreatedEhCallback?)(object?)createdEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback when the solver decides to split on a registered expression. The callback may change the arguments by providing other values by calling <see cref="SolverNextSplit"/>
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="decideEh" ctype="Z3_decide_eh">decide_eh parameter</param>
    public void SolverPropagateDecide(IntPtr c, IntPtr s, DecideEhCallback? decideEh)
    {
        nativeLibrary.SolverPropagateDecide(c, s, (NativeZ3Library.DecideEhCallback?)(object?)decideEh);
        CheckError(c);
    }

    /// <summary>
    ///  register a callback when the solver instantiates a quantifier. If the callback returns false, the actual instantiation of the quantifier is blocked. This allows the user propagator selectively prioritize instantiations without relying on default or configured weights.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="onBindingEh" ctype="Z3_on_binding_eh">on_binding_eh parameter</param>
    public void SolverPropagateOnBinding(IntPtr c, IntPtr s, OnBindingEhCallback? onBindingEh)
    {
        nativeLibrary.SolverPropagateOnBinding(c, s, (NativeZ3Library.OnBindingEhCallback?)(object?)onBindingEh);
        CheckError(c);
    }

    /// <summary>SolverNextSplit</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="cb" ctype="Z3_solver_callback">solver_callback parameter</param>
    /// <param name="t" ctype="Z3_ast">ast parameter</param>
    /// <param name="idx" ctype="unsigned">unsigned parameter</param>
    /// <param name="phase" ctype="Z3_lbool">lbool parameter</param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// Sets the next (registered) expression to split on. The function returns false and ignores the given expression in case the expression is already assigned internally (due to relevancy propagation, this assignments might not have been reported yet by the fixed callback). In case the function is called in the decide callback, it overrides the currently selected variable and phase.
    /// </remarks>
    public bool SolverNextSplit(IntPtr c, IntPtr cb, IntPtr t, uint idx, Lbool phase)
    {
        var result = nativeLibrary.SolverNextSplit(c, cb, t, idx, (NativeZ3Library.Lbool)phase);
        CheckError(c);
        return result;
    }

    /// <summary>SolverPropagateDeclare</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="name">symbol parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="domain" ctype="Z3_sort*">sort parameter</param>
    /// <param name="range" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Create uninterpreted function declaration for the user propagator. When expressions using the function are created by the solver invoke a callback to <see cref="SolverPropagateCreated"/> with arguments  context and callback solve  declared_expr: expression using function that was used as the top-level symbol  declared_id: a unique identifier (unique within the current scope) to track the expression.
    /// </remarks>
    public IntPtr SolverPropagateDeclare(IntPtr c, string name, uint n, out IntPtr domain, IntPtr range)
    {
        using var nameAnsi = new AnsiStringPtr(name);
        var nameSymbol = nativeLibrary.MkStringSymbol(c, nameAnsi);
        CheckError(c);
        var result = nativeLibrary.SolverPropagateDeclare(c, nameSymbol, n, out domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(SolverPropagateDeclare));
    }

    /// <summary>SolverPropagateDeclare</summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="name" ctype="Z3_symbol">symbol parameter</param>
    /// <param name="n" ctype="unsigned">unsigned parameter</param>
    /// <param name="domain" ctype="Z3_sort*">sort parameter</param>
    /// <param name="range" ctype="Z3_sort">sort parameter</param>
    /// <returns ctype="Z3_func_decl">func_decl value</returns>
    /// <remarks>
    /// Create uninterpreted function declaration for the user propagator. When expressions using the function are created by the solver invoke a callback to <see cref="SolverPropagateCreated"/> with arguments  context and callback solve  declared_expr: expression using function that was used as the top-level symbol  declared_id: a unique identifier (unique within the current scope) to track the expression.
    /// </remarks>
    public IntPtr SolverPropagateDeclareOriginal(IntPtr c, IntPtr name, uint n, out IntPtr domain, IntPtr range)
    {
        var result = nativeLibrary.SolverPropagateDeclare(c, name, n, out domain, range);
        CheckError(c);
        return CheckHandle(result, nameof(SolverPropagateDeclare));
    }

    /// <summary>
    ///  register an expression to propagate on with the solver. Only expressions of type Bool and type Bit-Vector can be registered for propagation.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="e" ctype="Z3_ast">ast parameter</param>
    public void SolverPropagateRegister(IntPtr c, IntPtr s, IntPtr e)
    {
        nativeLibrary.SolverPropagateRegister(c, s, e);
        CheckError(c);
    }

    /// <summary>
    ///  register an expression to propagate on with the solver. Only expressions of type Bool and type Bit-Vector can be registered for propagation. Unlike <see cref="SolverPropagateRegister"/> , this function takes a solver callback context as argument. It can be invoked during a callback to register new expressions.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="cb" ctype="Z3_solver_callback">solver_callback parameter</param>
    /// <param name="e" ctype="Z3_ast">ast parameter</param>
    public void SolverPropagateRegisterCb(IntPtr c, IntPtr cb, IntPtr e)
    {
        nativeLibrary.SolverPropagateRegisterCb(c, cb, e);
        CheckError(c);
    }

    /// <summary>
    ///  propagate a consequence based on fixed values and equalities. A client may invoke it during the <c>propagate_fixed</c> , <c>propagate_eq</c> , <c>propagate_diseq</c> , and <c>propagate_final</c> callbacks. The callback adds a propagation consequence based on the fixed values passed <c>ids</c> and equalities <c>eqs</c> based on parameters <c>lhs</c> , <c>rhs</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context"> - context </param>
    /// <param name="cb" ctype="Z3_solver_callback"> - solver callback </param>
    /// <param name="numFixed" ctype="unsigned"> - number of fixed terms used as premise to propagation </param>
    /// <param name="fixed" ctype="Z3_ast const*"> - array of length <c>num_ids</c> containing terms that are fixed in the current scope </param>
    /// <param name="numEqs" ctype="unsigned"> - number of equalities used as premise to propagation </param>
    /// <param name="eqLhs" ctype="Z3_ast const*"> - left side of equalities </param>
    /// <param name="eqRhs" ctype="Z3_ast const*"> - right side of equalities </param>
    /// <param name="conseq" ctype="Z3_ast"> - consequence to propagate. It is typically an atomic formula, but it can be an arbitrary formula. </param>
    /// <returns ctype="bool">bool value</returns>
    /// <remarks>
    /// The solver might discard the propagation in case it is true in the current state. The function returns false in this case; otw. the function returns true. At least one propagation in the final callback has to return true in order to prevent the solver from finishing.
    /// </remarks>
    public bool SolverPropagateConsequence(IntPtr c, IntPtr cb, uint numFixed, out IntPtr @fixed, uint numEqs, out IntPtr eqLhs, out IntPtr eqRhs, IntPtr conseq)
    {
        var result = nativeLibrary.SolverPropagateConsequence(c, cb, numFixed, out @fixed, numEqs, out eqLhs, out eqRhs, conseq);
        CheckError(c);
        return result;
    }

    /// <summary>
    ///  provide an initialization hint to the solver. The initialization hint is used to calibrate an initial value of the expression that represents a variable. If the variable is Boolean, the initial phase is set according to <c>value</c> . If the variable is an integer or real, the initial Simplex tableau is recalibrated to attempt to follow the value assignment.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="v" ctype="Z3_ast">ast parameter</param>
    /// <param name="val" ctype="Z3_ast">ast parameter</param>
    public void SolverSetInitialValue(IntPtr c, IntPtr s, IntPtr v, IntPtr val)
    {
        nativeLibrary.SolverSetInitialValue(c, s, v, val);
        CheckError(c);
    }

    /// <summary>
    ///  Check whether the assertions in a given solver are consistent or not.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_lbool">lbool value</returns>
    /// <remarks>
    /// The function <see cref="SolverGetModel"/> retrieves a model if the assertions is satisfiable (i.e., the result is <c>Z3_L_TRUE</c> ) and model construction is enabled. Note that if the call returns <c>Z3_L_UNDEF</c> , Z3 does not ensure that calls to <see cref="SolverGetModel"/> succeed and any models produced in this case are not guaranteed to satisfy the assertions. The function <see cref="SolverGetProof"/> retrieves a proof if proof generation was enabled when the context was created, and the assertions are unsatisfiable (i.e., the result is <c>Z3_L_FALSE</c> ).
    /// </remarks>
    /// <seealso cref="SolverCheckAssumptions"/>
    public Lbool SolverCheck(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverCheck(c, s);
        CheckError(c);
        return (Lbool)result;
    }

    /// <summary>
    ///  Check whether the assertions in the given solver and optional assumptions are consistent or not.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="numAssumptions" ctype="unsigned">unsigned parameter</param>
    /// <param name="assumptions" ctype="Z3_ast const[]">ast parameter</param>
    /// <returns ctype="Z3_lbool">lbool value</returns>
    /// <remarks>
    /// The function <see cref="SolverGetUnsatCore"/> retrieves the subset of the assumptions used in the unsatisfiability proof produced by Z3.
    /// </remarks>
    /// <seealso cref="SolverCheck"/>
    public Lbool SolverCheckAssumptions(IntPtr c, IntPtr s, uint numAssumptions, IntPtr[] assumptions)
    {
        var result = nativeLibrary.SolverCheckAssumptions(c, s, numAssumptions, assumptions);
        CheckError(c);
        return (Lbool)result;
    }

    /// <summary>
    ///  Retrieve congruence class representatives for terms.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="numTerms" ctype="unsigned">unsigned parameter</param>
    /// <param name="terms" ctype="Z3_ast const[]">ast parameter</param>
    /// <param name="classIds" ctype="unsigned[]">unsigned parameter</param>
    /// <returns ctype="Z3_lbool">lbool value</returns>
    /// <remarks>
    /// The function can be used for relying on Z3 to identify equal terms under the current set of assumptions. The array of terms and array of class identifiers should have the same length. The class identifiers are numerals that are assigned to the same value for their corresponding terms if the current context forces the terms to be equal. You cannot deduce that terms corresponding to different numerals must be all different, (especially when using non-convex theories). All implied equalities are returned by this call. This means that two terms map to the same class identifier if and only if the current context implies that they are equal. A side-effect of the function is a satisfiability check on the assertions on the solver that is passed in. The function return <c>Z3_L_FALSE</c> if the current assertions are not satisfiable.
    /// </remarks>
    public Lbool GetImpliedEqualities(IntPtr c, IntPtr s, uint numTerms, IntPtr[] terms, uint[] classIds)
    {
        var result = nativeLibrary.GetImpliedEqualities(c, s, numTerms, terms, classIds);
        CheckError(c);
        return (Lbool)result;
    }

    /// <summary>
    ///  retrieve consequences from solver that determine values of the supplied function symbols.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="assumptions" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="variables" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="consequences" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <returns ctype="Z3_lbool">lbool value</returns>
    public Lbool SolverGetConsequences(IntPtr c, IntPtr s, IntPtr assumptions, IntPtr variables, IntPtr consequences)
    {
        var result = nativeLibrary.SolverGetConsequences(c, s, assumptions, variables, consequences);
        CheckError(c);
        return (Lbool)result;
    }

    /// <summary>
    ///  extract a next cube for a solver. The last cube is the constant <c>true</c> or <c>false</c> . The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="vars" ctype="Z3_ast_vector">ast_vector parameter</param>
    /// <param name="backtrackLevel" ctype="unsigned">unsigned parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    /// <remarks>
    /// The third argument is a vector of variables that may be used for cubing. The contents of the vector is only used in the first call. The initial list of variables is used in subsequent calls until it returns the unsatisfiable cube. The vector is modified to contain a set of Autarky variables that occur in clauses that are affected by the (last literal in the) cube. These variables could be used by a different cuber (on a different solver object) for further recursive cubing. The last argument is a backtracking level. It instructs the cube process to backtrack below the indicated level for the next cube.
    /// </remarks>
    public IntPtr[] SolverCube(IntPtr c, IntPtr s, IntPtr vars, uint backtrackLevel)
    {
        var result = nativeLibrary.SolverCube(c, s, vars, backtrackLevel);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverCube));
        return AstVectorToArray(c, result);
    }

    /// <summary>
    ///  Retrieve the model for the last <see cref="SolverCheck"/> or <see cref="SolverCheckAssumptions"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_model">model value</returns>
    /// <remarks>
    /// The error handler is invoked if a model is not available because the commands above were not invoked for the given solver, or if the result was <c>Z3_L_FALSE</c> .
    /// </remarks>
    public IntPtr SolverGetModel(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetModel(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(SolverGetModel));
    }

    /// <summary>
    ///  Retrieve the proof for the last <see cref="SolverCheck"/> or <see cref="SolverCheckAssumptions"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_ast">ast value</returns>
    /// <remarks>
    /// The error handler is invoked if proof generation is not enabled, or if the commands above were not invoked for the given solver, or if the result was different from <c>Z3_L_FALSE</c> .
    /// </remarks>
    public IntPtr SolverGetProof(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetProof(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(SolverGetProof));
    }

    /// <summary>
    ///  Retrieve the unsat core for the last <see cref="SolverCheckAssumptions"/> The unsat core is a subset of the assumptions <c>a</c> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_ast_vector">ast_vector value</returns>
    /// <remarks>
    /// By default, the unsat core will not be minimized. Generation of a minimized unsat core can be enabled via the <c>"sat.core.minimize"</c> and <c>"smt.core.minimize"</c> settings for SAT and SMT cores respectively. Generation of minimized unsat cores will be more expensive.
    /// </remarks>
    public IntPtr[] SolverGetUnsatCore(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetUnsatCore(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverGetUnsatCore));
        return AstVectorToArray(c, result);
    }

    /// <summary>
    ///  Return a brief justification for an "unknown" result (i.e., <c>Z3_L_UNDEF</c> ) for the commands <see cref="SolverCheck"/> and <see cref="SolverCheckAssumptions"/> .
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    public string SolverGetReasonUnknown(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetReasonUnknown(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverGetReasonUnknown));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Return statistics for the given solver.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_stats">stats value</returns>
    /// <remarks>
    /// User must use <see cref="StatsIncRef"/> and <see cref="StatsDecRef"/> to manage Z3_stats objects.
    /// </remarks>
    public IntPtr SolverGetStatistics(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverGetStatistics(c, s);
        CheckError(c);
        return CheckHandle(result, nameof(SolverGetStatistics));
    }

    /// <summary>
    ///  Convert a solver into a string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    /// <seealso cref="SolverFromFile"/>
    /// <seealso cref="SolverFromString"/>
    public string SolverToString(IntPtr c, IntPtr s)
    {
        var result = nativeLibrary.SolverToString(c, s);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverToString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

    /// <summary>
    ///  Convert a solver into a DIMACS formatted string.
    /// </summary>
    /// <param name="c" ctype="Z3_context">context parameter</param>
    /// <param name="s" ctype="Z3_solver">solver parameter</param>
    /// <param name="includeNames" ctype="bool">bool parameter</param>
    /// <returns ctype="Z3_string">string value</returns>
    public string SolverToDimacsString(IntPtr c, IntPtr s, bool includeNames)
    {
        var result = nativeLibrary.SolverToDimacsString(c, s, includeNames);
        CheckError(c);
        result = CheckHandle(result, nameof(SolverToDimacsString));
        return Marshal.PtrToStringAnsi(result) ?? throw new InvalidOperationException("Failed to marshal string from native code.");
    }

}
