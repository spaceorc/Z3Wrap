#!/usr/bin/env python3
"""
Z3Library2 Generator

This script generates Z3Library2 partial class files from NativeZ3Library.
"""

import re
from dataclasses import dataclass
from pathlib import Path
from typing import List, Dict, Tuple


@dataclass
class EnumValue:
    """Represents a single enum value."""
    name: str
    value: str
    summary: str
    remarks: str


@dataclass
class EnumDefinition:
    """Represents a parsed enum definition."""
    name: str
    summary: str
    see_also: List[str]
    values: List[EnumValue]


def parse_native_enums_file(file_path: Path) -> List[EnumDefinition]:
    """
    Parse NativeZ3Library.Enums.generated.cs and extract all enum definitions.
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    enums = []

    # Find all enum blocks: from "/// <summary>" to the closing "}"
    # Pattern: summary comments + "internal enum Name" + "{" + values + "}"
    enum_pattern = r'((?:[ \t]*///.*?\n)+)[ \t]*internal enum (\w+)\s*\{(.*?)\n[ \t]*\}'

    for match in re.finditer(enum_pattern, content, re.MULTILINE | re.DOTALL):
        doc_block = match.group(1)
        enum_name = match.group(2)
        values_block = match.group(3)

        # Parse documentation block
        summary_lines = []
        see_also = []
        in_summary = False

        for line in doc_block.split('\n'):
            line = line.strip()
            if not line.startswith('///'):
                continue
            line = line[3:].strip()

            if '<summary>' in line:
                in_summary = True
                continue
            elif '</summary>' in line:
                in_summary = False
                continue
            elif in_summary:
                summary_lines.append(line)
            elif '<seealso cref=' in line:
                # Extract cref value
                cref_match = re.search(r'<seealso cref="([^"]+)"', line)
                if cref_match:
                    see_also.append(cref_match.group(1))

        summary = '\n'.join(summary_lines).strip()

        # Parse enum values
        values = []
        # Pattern: optional doc comments + "Name = value,"
        value_pattern = r'((?:[ \t]*///.*?\n)+)?[ \t]*(\w+)\s*=\s*([^,\n]+),'

        for value_match in re.finditer(value_pattern, values_block, re.MULTILINE | re.DOTALL):
            value_doc_block = value_match.group(1) or ''
            value_name = value_match.group(2)
            value_value = value_match.group(3).strip()

            # Parse value documentation
            value_summary_lines = []
            value_remarks_lines = []
            in_value_summary = False
            in_value_remarks = False

            for line in value_doc_block.split('\n'):
                line = line.strip()
                if not line.startswith('///'):
                    continue
                line = line[3:].strip()

                if '<summary>' in line:
                    in_value_summary = True
                    # Check if it's single-line <summary>...</summary>
                    single_match = re.search(r'<summary>(.*?)</summary>', line)
                    if single_match:
                        value_summary_lines.append(single_match.group(1))
                        in_value_summary = False
                    continue
                elif '</summary>' in line:
                    in_value_summary = False
                    continue
                elif '<remarks>' in line:
                    in_value_remarks = True
                    continue
                elif '</remarks>' in line:
                    in_value_remarks = False
                    continue
                elif in_value_summary:
                    value_summary_lines.append(line)
                elif in_value_remarks:
                    value_remarks_lines.append(line)

            value_summary = '\n'.join(value_summary_lines).strip()
            value_remarks = '\n'.join(value_remarks_lines).strip()

            values.append(EnumValue(
                name=value_name,
                value=value_value,
                summary=value_summary,
                remarks=value_remarks
            ))

        enums.append(EnumDefinition(
            name=enum_name,
            summary=summary,
            see_also=see_also,
            values=values
        ))

    return enums


def generate_enums_file(output_dir: Path, enums: List[EnumDefinition]):
    """
    Generate Z3Library2.Enums.generated.cs with actual public enum definitions.
    """
    file_path = output_dir / "Z3Library2.Enums.generated.cs"

    with open(file_path, 'w', encoding='utf-8') as f:
        # Header
        f.write("// <auto-generated>\n")
        f.write("// This file was generated by scripts/generate_library.py\n")
        f.write("// Source: NativeZ3Library.Enums.generated.cs\n")
        f.write("// DO NOT EDIT - Changes will be overwritten\n")
        f.write("// </auto-generated>\n\n")

        f.write("namespace Spaceorc.Z3Wrap.Core.Library;\n\n")

        f.write("public sealed partial class Z3Library2\n")
        f.write("{\n")

        # Generate each enum
        for i, enum_def in enumerate(enums):
            # Add blank line between enums
            if i > 0:
                f.write("\n")

            # Enum summary
            if enum_def.summary:
                f.write("    /// <summary>\n")
                for line in enum_def.summary.split('\n'):
                    f.write(f"    /// {line}\n" if line else "    ///\n")
                f.write("    /// </summary>\n")

            # See also references
            for see_ref in enum_def.see_also:
                f.write(f'    /// <seealso cref="{see_ref}"/>\n')

            # Enum declaration
            f.write(f"    public enum {enum_def.name}\n")
            f.write("    {\n")

            # Generate enum values
            for j, value in enumerate(enum_def.values):
                # Add blank line between values if there's documentation
                if j > 0 and (value.summary or value.remarks):
                    f.write("\n")

                # Value documentation
                if value.summary:
                    if value.remarks:
                        # Multi-line: summary + remarks
                        f.write("        /// <summary>\n")
                        for line in value.summary.split('\n'):
                            f.write(f"        /// {line}\n" if line else "        ///\n")
                        f.write("        /// </summary>\n")
                        f.write("        /// <remarks>\n")
                        for line in value.remarks.split('\n'):
                            f.write(f"        /// {line}\n" if line else "        ///\n")
                        f.write("        /// </remarks>\n")
                    else:
                        # Single-line summary
                        if '\n' in value.summary:
                            f.write("        /// <summary>\n")
                            for line in value.summary.split('\n'):
                                f.write(f"        /// {line}\n" if line else "        ///\n")
                            f.write("        /// </summary>\n")
                        else:
                            f.write(f"        /// <summary>{value.summary}</summary>\n")
                elif value.remarks:
                    # Only remarks
                    f.write("        /// <remarks>\n")
                    for line in value.remarks.split('\n'):
                        f.write(f"        /// {line}\n" if line else "        ///\n")
                    f.write("        /// </remarks>\n")

                # Value declaration
                f.write(f"        {value.name} = {value.value},\n")

            f.write("    }\n")

        f.write("}\n")

    return file_path


def main():
    """Main entry point."""
    # Paths
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    native_enums_file = project_root / "Z3Wrap" / "Core" / "Interop" / "NativeZ3Library.Enums.generated.cs"
    output_dir = project_root / "Z3Wrap" / "Core" / "Library"

    print("Z3Library2 Generator")
    print("=" * 80)
    print(f"Source: {native_enums_file}")
    print(f"Output: {output_dir}")
    print()

    # Parse native enums
    print("Parsing NativeZ3Library enums...")
    enums = parse_native_enums_file(native_enums_file)
    print(f"✓ Found {len(enums)} enum definitions")

    for enum_def in enums:
        print(f"  - {enum_def.name} ({len(enum_def.values)} values)")
    print()

    # Generate enums file
    print("Generating Z3Library2.Enums.generated.cs...")
    generated_file = generate_enums_file(output_dir, enums)
    print(f"✓ Generated {generated_file.name}")
    print()

    print(f"✅ Done! Generated 1 file with {len(enums)} public enums")


if __name__ == "__main__":
    main()
